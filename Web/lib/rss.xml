<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Course-Notes]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>Course-Notes</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Fri, 21 Jun 2024 11:50:31 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Fri, 21 Jun 2024 11:50:14 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Vim Cheatsheet]]></title><description><![CDATA[ 
 <br>
初识Vim娘，很可能觉得很沮丧，因为用尽浑身解数也不能让她笑一笑，难道注定与她无缘？No！任何想要接近她的人都要学习一张密密麻麻、五颜六色的秘笈……然后为了能够和她更好的性……嗯，幸福生活，可能还需要自己创造秘笈。
<br>
由ChrisWhite翻译自<a data-tooltip-position="top" aria-label="https://quickref.me/vim" rel="noopener" class="external-link" href="https://quickref.me/vim" target="_blank">Vim&nbsp;cheatsheet</a>
<br><br>▼/▶ Cursor   ▽/▷ Target
Copy<br><br>┌───────────── |      
├───────────── 0      $ ──────────────┐ 
│  ┌────────── ^      fe ────────┐    │
│  │  ┌─────── Fo     te ───────┐│    │
│  │  │┌────── To     30| ───┐  ││    │
│  │  ││ ┌──── ge     w ───┐ │  ││    │
│  │  ││ │ ┌── b      e ─┐ │ │  ││    │
│  │  ││ │ │  ┌h      l┐ │ │ │  ││    │
▽  ▽  ▽▽ ▽ ▽  ▽▼      ▼▽ ▽ ▽ ▽  ▽▽    ▽
   echo "A cheatsheet from quickref.me"
Copy<br><br>                 - SCREEN 1 START
   ┌─┬─────────▷ #!/usr/bin/python
   │ │     ┌───▷     
   │ │     │     print("Hello")
   │ │     { } ▶ print("Vim")
   │ │       │   print("!")
   │ │       └─▷    
   │ │ ┌───┬───▷ print("Welcome")
G gg H M L k j ▶ print("to")
│        │   └─▷ print("quickref.me")
│        │       print("/vim")
│        │     
│        └─────▷ 
│                - SCREEN 1 END
└──────────────▷ print("SCREEN 2")
Copy<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>不仅是 i ，你可以设置宏为任何字母<br><br><br><br>将操作符和动作符结合来使用<br><br><br><br><br><br>[count] &lt;operator&gt; &lt;motion&gt;
&lt;operator&gt; [count] &lt;motion&gt;
Copy<br><br><br><br><br><br>操作属性为inner或者around的文本块<br><br><br>详见 :help text-objects<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>:[range]s/{pattern}/{str}/[flags]
Copy<br><br><br><br>:%s/{pattern}/{str}/[flags]
Copy<br><br><br><br><br><br>:[range]g/{pattern}/[command]
Copy<br><br><br><br>:[range]v/{pattern}/[command]
Copy<br><br><br><br><br><br><br><br>:s/a\|b/xxx\0xxx/g		         # Modifies "a b"      to "xxxaxxx xxxbxxx"
:s/test/\U&amp; file/                # Modifies "test"     to "TEST FILE"
:s/\(test\)/\U\1\e file/         # Modifies "test"     to "TEST file"
:s/\v([abc])([efg])/\2\1/g	     # Modifies "af fa bg" to "fa fa gb"
:s/\v\w+/\u\0/g		             # Modifies "bla bla"  to "Bla Bla"
:s/\v([ab])|([cd])/\1x/g         # Modifies "a b c d"  to "ax bx x x"
:%s/.*/\L&amp;/                      # Modifies "HTML"     to "html"
:s/\v&lt;(.)(\w*)/\u\1\L\2/g        # Make every first letter of a word uppercase
:%s/^\(.*\)\n\1/\1/              # Remove duplicate lines
:%s/&lt;\/\=\(\w\+\)\&gt;/\U&amp;/g        # Convert HTML-Tags to uppercase
:g/^pattern/s/$/mytext           # Find and append text to the end
:g/pattern/norm! @i              # Run a macro on matching lines
/^\(.*\)\(\r\?\n\1\)\+$          # View the duplicates lines
/\v^(.*)(\r?\n\1)+$              # View the duplicates lines (very magic)
:v/./,/./-j                      # Compress blank lines into a blank line
:g/&lt;p1&gt;/,/&lt;p2&gt;/d                 # Delete inclusively from &lt;p1&gt; to &lt;p2&gt;
Copy<br><br><br>
$ vimdiff file1 file2 [file3]
$ vim -d file1 file2 [file3]
Copy<br><br>:[range]diffget [bufspec]
:[range]diffput [bufspec]
Copy<br><br><br>See: <a class="internal-link" data-href="#ranges" href="/#ranges" target="_self" rel="noopener">Ranges</a><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>详见 :help formatting<br><br><br><br><br>在插入模式下进行以上操作<br><br><br><br><br><br>移除重复行<br>:sort | %!uniq -u
Copy<br>在文件中给行编号<br>:%!cat -n
Copy<br>拷贝整个文档到剪贴板<br>:%w !pbcopy            # Mac OS X
:%w !xclip -i -sel c   # GNU/Linux
:%w !xsel -i -b        # GNU/Linux
Copy<br><br>
<br><a data-tooltip-position="top" aria-label="https://devhints.io/vim" rel="noopener" class="external-link" href="https://devhints.io/vim" target="_blank">Devhints</a> (devhints.io)
<br><a data-tooltip-position="top" aria-label="https://vim.rtorr.com/" rel="noopener" class="external-link" href="https://vim.rtorr.com/" target="_blank">Vim cheatsheet</a> (vim.rotrr.com)
<br><a data-tooltip-position="top" aria-label="http://vimdoc.sourceforge.net/htmldoc/" rel="noopener" class="external-link" href="http://vimdoc.sourceforge.net/htmldoc/" target="_blank">Vim documentation</a> (vimdoc.sourceforge.net)
<br><a data-tooltip-position="top" aria-label="http://openvim.com/" rel="noopener" class="external-link" href="http://openvim.com/" target="_blank">Interactive Vim tutorial</a> (openvim.com)
]]></description><link>campus/chinese-notes/计算机科学/杂项/vim-cheatsheet.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/杂项/Vim Cheatsheet.md</guid><pubDate>Fri, 22 Dec 2023 11:04:19 GMT</pubDate></item><item><title><![CDATA[程序装入的方式]]></title><description><![CDATA[ 
 <br><br><br>
<br>编译程序生成绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存
<br>只适用于单道程序的环境
<br><br>
<br>编译、链接后的装入模块的地址从 0 开始，根据内存的当前状况，将装入模块装入到内存的适当位置，装入时对地址进行重定位
<br>在作业装入内存时，必须分配要求的全部空间
<br>作业进入内存不可以移动
<br><br>
<br>装入内存后所有的地址依然是逻辑地址，把地址转换推迟到程序真正要执行时才进行
<br>需要重定位寄存器的支持
<br>可以把程序分配到不连续的存储区中
<br>便于程序段的运行
<br><br>
<br>静态链接：程序运行之前，先将各目标模块及库函数链接成一个完整的可执行文件，之后不再拆开
<br>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
<br>运行时动态链接：在程序执行中需要目标模块才进行链接
<br><br>
<br>操作系统负责内存空间的分配与回收
<br>操作系统需要提供某种技术从逻辑上对内存空间进行扩充
<br>操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
<br>操作系统要保证各个进程在各自存储空间内运行，互不干扰，提供内存保护

<br>设置上下限寄存器
<br>采用重定位寄存器和界地址寄存器


<br><br><img alt="Pasted image 20240604190834.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240604190834.png"><br>
<br>常量变量的值不能改变，会被存储在只读代码/数据区域中
<br>读/写数据和只读代码/数据中在进程启动时就确定大小
<br><br><br>
<br>用来解决程序大小超过物理内存总和的问题
<br>内存中分为固定区和覆盖区
<br>程序的调用结构由程序员显式声明，对用户不透明<br>
<img alt="Pasted image 20240604191915.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240604191915.png">
<br><br>
<br>内存空间紧张，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存
<br>具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分，文件区追求存储空间的利用率，采用离散分配方式。对换区主要追求换入换出速度，通常对对换区采用连续分配方式
<br>交换发生在系统有许多进程运行并且内存吃紧时 
<br>可优先换出阻塞进程，换出优先级低的进程，有些系统还会考虑进程在内存的驻留时间
<br>PCB 不会被换出内存
<br><br>
<br>内部碎片：分配给某进程的内存区域中，有些部分没有用上
<br>外部碎片：内存中的某些空闲分区由于太小而难以利用
<br><br>
<br>内存被分为系统区和用户区
<br>内存中只能有一道用户程序，用户程序独占整个用户区空间
<br>优点：实现简单，无外部碎片，不一定实现内存保护
<br>缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率低
<br><br>
<br>系统将整个用户空间划分为若干个固定大小的分区，在那个分区中只装入一道作业
<br>可以划分为分区大小相等和不等两种
<br>操作系统建立分区说明表来实现各个分区的分配与回收
<br>优点：实现简单，无外部碎片
<br>缺点：当用户程序太大时，需要采用覆盖技术满足要求，但又会降低性能，会产生内部碎片，内存利用率低
<br><br>
<br>根据进程的大小动态地建立分区
<br>操作系统使用空闲分区表或空闲分区链记录内存的使用情况
<br>把新作业装入内存时，须按照一定的动态分区分配算法
<br>各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定
<br>动态分区分配没有内部碎片，但是有外部碎片，可用“紧凑”技术来解决
<br><br><br>
<br>每次从低地址开始查找，找到一个能满足大小的空闲分区
<br>空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链
<br><br>
<br>尽可能留下大片的空闲区，优先使用更小的空闲区
<br>空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链
<br>缺点：每次都选择最小的分区进行分配，会留下很多外部碎片
<br><br>
<br>每次分配时优先使用最大的连续空闲区
<br>空闲分区按容量递减次序链接，每次分配内存时顺序查找空闲分区链
<br>缺点：如果有大进程到达没有分区可用
<br><br>
<br>空闲分区以地址递增的顺序排列，每次分配内存时从上次查找结束的位置开始查找空闲分区链
<br><br>
<br>系统将内存空间氛围一个个大小相等的分区 (比如 4 KB)，每个分区是一个页框 (页框=页帧=内存块=物理块=物理页面)
<br>将进程的逻辑地址空间分为与页框大小相等的一个个部分，每个部分称为一个页，每个页面用页号编号
<br>进程的页面与内存的页框有一一对应的关系
<br><br>
<br>一个进程对应一张页表
<br>进程的每个页面对应一个页表项
<br>每个页表项由"页号"和"块号"组成
<br>为了方便页表的查询，常常会让一个页表项占据更多的字节，使得每个页面恰好可以装得下整数个页表项
<br>页表记录进程页面和实际存放的内存块见的映射关系
<br>页表项连续存放，页号可以是隐含的，不占存储空间，只有块号占用存储空间
<br>页表记录的是内存块号，不是内存块的起始地址
<br>为了方便找到页表项，页表一般是放在连续的内存块中的
<br><br>
<br>进程的各个页面是离散存放的，但是页面内部是连续存放的
<br>要访问逻辑地址 A 

<br>确定逻辑地址 A 对应的页号 P
<br>找到 P 号页面在内存中的起始地址 (查页表)
<br>确定逻辑地址 A 的页内偏移量 W
<br>物理地址  = P 号页面在内存中的起始地址 + 页内偏移量 W
<br>页号 = 逻辑地址 / 页面长度
<br>页内偏移量 = 逻辑地址 % 页面长度


<br>如果每个页面大小为  B，用二进制数表示逻辑地址，末尾 K 位即为页内偏移量，其余部分为页号
<br><br>
<br>系统中设置一个页表寄存器，用于存放页表在内存中的起始地址 F 和页表长度 M 
<br>进程未执行时，F 和 M 存放在 PCB 中<br>
<img alt="Pasted image 20240605103936.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240605103936.png">
<br><br>
<br>页面大小为 L ，逻辑地址 A 到物理地址 E 的变换过程如下
<br>计算页号和页内偏移量
<br>比较页号和页表长度 M，P &gt;= M 则产生越界中断 (页号从 0 开始，页表长度至少是 1)
<br>页号 P 对应的页表项地址 = 页表起始地址 F + 页号 P * 页表项长度 (注意与页表长度区分)，取出该页表项内容 b，即内存块号
<br>E = b * L + W
<br><br>
<br>快表，又称为联想寄存器 (TLB, translation lookaside buffer)，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，可以加速地址变换的速度，内存中的页表常称为慢表
<br>进程切换时进程会清空快表的内容
<br>最近使用过的页表项会放入快表，快表中存放的时页表的一部分副本
<br>若快表命中，访问某个逻辑地址只需要一次访存即可
<br>支持快表与慢表同时查找的系统，未命中时不需要加入查询快表的时间
<br>TLB 和普通 Cache 的区别：TLB 中只有页表项的副本，普通 Cache 中可能有其他各种数据的副本<br>
<img alt="Pasted image 20240605122553.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240605122553.png">
<br><br>int i = 0;
int a[100];
while (i &lt; 100) {
	a[i] = i;
	i++;
}
Copy<br>
<br>时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问
<br>空间局部性：程序访问了某个存储单元后，不久之后其附近的存储单元也很有可能被访问
<br><br>
<br>若采用多级页表机制，则各级页表的大小不能超过一个页面
<br>两级页表的访存次数分析，N 级页表访问一个逻辑地址需要 N + 1 次访存 
<br><br>
<br>单级页表大占用多个连续的页框
<br>没必要让整个页表常驻内存，进程在一段时间内只需要访问某几个特定的页面
<br>可以在需要访问页面时才把页面掉入内存，可以在页表项中增加一个标志位，用于表示该页面是否已经掉入内存，若想访问的页面不在内存中，则产生缺页中断，操作系统将目标页面从外存调入内存
<br>因此需要为离散分配的页表再建立一张页表，称为页目录表 (外层页表，顶层页表)
<br><br>
<br>按照地址结构将逻辑地址拆分成三部分
<br>从 PCB 中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置
<br>根据二级页号查表，找到最终想访问的内存块号
<br>结合页内偏移量得到物理地址
<br><br>
<br>进程的地址空间，按照程序自身的逻辑关系分为若干个段，每个段都有一个段名，每段从 0 开始编址
<br>内存分配以段为单位分配，每个段在内存中占据连续地址空间，但各段之间可以不相邻
<br>用户编程更方便，程序可读性高
<br>逻辑地址结构由段号 (段名) 和段内地址 (段内偏移量) 组成
<br>操作系统需要从物理内存中找到各个逻辑段的存放位置，需要为每个进程建立一张段映射表，简称段表
<br>段号可以是隐含的，不占存储空间
<br>需要对段内地址进行越界检查<br>
<img alt="Pasted image 20240605154846.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240605154846.png">
<br><br>
<br>页是信息的物理单位，主要为了实现离散分配，提高内存利用率，分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的
<br>段是信息的逻辑单位，分段对用户是可见的
<br>分页的用户进程的地址空间是一维的
<br>分段的用户进程的地址空间是二维的
<br>分段比分页更容易实现信息的共享和保护
<br>在分段系统中也可引入快表机构，减少一次访存加快地址变换速度
<br><br>
<br>将进程按逻辑模块分段，再将各段分页
<br>再将内存空间分为大小相同的内存块/页框/页帧/物理块
<br>进程将各页面分别装入各内存块中
<br>段页式系统的逻辑地址由段号、页号、页内偏移量组成
<br>段页式管理的地址结构是一维的
<br>需要检查页号是否越界<br>
<img alt="Pasted image 20240605162233.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240605162233.png">
]]></description><link>campus/chinese-notes/计算机科学/考研/os/内存管理.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/考研/OS/内存管理.md</guid><pubDate>Wed, 05 Jun 2024 08:26:28 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240604190834.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240604190834.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[文件管理]]></title><description><![CDATA[ 
 <br><br>
<br>文件名：同一目录下不允许有重名文件
<br>标识符：用于唯一确定文件
<br>类型：指明文件的类型
<br>位置：文件的存放路径、外存中的地址
<br>大小：指明文件大小
<br>保护信息
<br><br>
<br>无结构文件：由一系列二进制或字符流组成
<br>有结构文件：考虑文件的逻辑结构
<br><br>
<br>创建文件：create
<br>删除文件：delete
<br>读文件： read 
<br>写文件：write
<br>打开文件：open
<br>关闭文件：close
<br>文件共享
<br>文件保护
<br><br>
<br>在用户看来，文件内部的数据是怎样组织起来的
<br>有结构文件：由一组相似的记录组成，又称"记录式文件"。每条记录又由若干个数据项组成，根据记录的长度，又可分为定长记录和可变长记录
<br><br>
<br>串结构：记录之间的顺序与关键字无关
<br>顺序结构：记录之间的顺序按关键字顺序排列
<br>链式存储无法实现随机存取，只能从第一个记录开始一次往后找
<br>顺序存储的文件，如果是可变长的则无法实现随机存取
<br>定长记录若采用顺序结构，可以快速找到某关键字对应的记录
<br>考试中指的顺序文件是物理上顺序存储的顺序文件
<br>顺序文件的缺点是增加/删除一个记录比较困难
<br><br>
<br>解决可变长记录查找速度慢的问题
<br>建立一张索引表加快文件检索速度
<br>索引表本身是定长记录的顺序文件
<br><br>
<br>一组记录对应一个索引表项
<br>提高检索效率可以建立多级索引表
<br><br><br>
<br>目录本身就是一种有结构文件，由一条条记录组成，每条记录对应一个在该存放目录下的文件
<br>目录表项中存放了目录项在外存中的存放位置
<br>FCB 的有序集合称为"文件目录"，一个 FCB 就是一个文件目录项，包含了文件的基本信息，存取控制信息和使用信息
]]></description><link>campus/chinese-notes/计算机科学/考研/os/文件管理.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/考研/OS/文件管理.md</guid><pubDate>Fri, 07 Jun 2024 03:25:28 GMT</pubDate></item><item><title><![CDATA[基本概念]]></title><description><![CDATA[ 
 <br><br>
<br>传统存储管理方式的特征

<br>一次性：作业必须一次性全部装入内存后才能运行，大作业无法运行，并且多道程序并发度下降
<br>驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束，内存中会驻留大量用不到的数据


<br><br>
<br>时间局部性
<br>空间局部性
<br><br>
<br>将程序中很快就会用到的部分装入内存，暂时用不到的部分留在外存
<br>当访问的信息不再在内存时，由操作系统负责将所需信息从外存调入内存 (请求调页)
<br>内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存 (页面置换)
<br><br>
<br>多次性：作业分多次调入内存
<br>对换行：作业无需一直常驻内存
<br>虚拟性：从逻辑上扩展的内存容量
<br><br>
<br>页表项新增状态位，访问字段，修改位和外存地址
<br>当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断程序处理中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列
<br>此时内存中有空闲块，为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应的页表项
<br>如果没有空闲块，需要由页面置换算法选择一个页面淘汰，若页面在内存期间被修改过，则要将其写回外存
<br>快表中有的页面一定是在内存中的，若某个页面被换出外存，则快表中对应的相应表项也要删除，否则可能访问错误的页面
<br>只有写指令才需要修改"修改位"，一般只要修改快表中的数据，只有将快表项删除时才需要写回内存中的慢表，这样可以减少缓存次数
<br>页面调入内存中时，需要修改慢表，同时也需要将表项复制到快表中
<br><br>
<br>好的页面置换算法应该追求更少的缺页率
<br><br>
<br>淘汰页面后选择永不使用，或在最长时间内不再被访问的页面
<br>缺页时未必发生页面置换，如果有可用的空闲内存块，就不用进行页面置换
<br>操作系统无法预判访序列，在实际中是无法实现的
<br><br>
<br>每次选择淘汰的页面是最早进入内存的页面
<br>Belady 异常：当进程分配的物理块数增大时，缺页次数不减反增的异常现象
<br>实现简单但算法性能差
<br><br>
<br>每次淘汰的页面时最近最久未使用的页面
<br>算法性能好，但实现困难，开销大
<br>做题时在逆向扫描过程中最后一个出现的页号就是要淘汰的页面
<br><br><br>
<br>每个页面设置一个访问位，内存中的页面通过链接指针链接成一个循环队列
<br>当某页的访问位置为 1 时将它置为 0 ，暂不换出，若第一轮扫描中所有的页面都是 1，则将页面的访问位依次置 0 后在进行第二轮扫描，第二轮扫描中一定会有访问位为 0 的页面
<br><br>
<br>如果被淘汰的页面没有被修改过，就不用执行 I/O 操作写回外存，只有被淘汰的页面被修改过时，才考虑写回外存
<br>使用 (访问位，修改位) 的形式表示各页面状态
<br>算法规则：将所有可能被置换的页面排成一个循环队列

<br>第一轮： 从当前位置开始扫描到第一个 (0, 0) 的帧用于替换，不修改任何标志位
<br>第二轮： 若第一轮扫描失败，重新扫描查找第一个 (0, 1) 的帧用于替换，将所有扫描过的帧访问位设为 0
<br>第三轮：查找第一个(0, 0) 的帧用于替换，本轮扫描不修改任何标志位
<br>第四轮：查找第一个(0, 1) 的帧用于替换


<br>第三轮，第四轮中一定会有一个帧被选中
<br><br><br>
<br>驻留集：请求分页存储管理中给进程分配的物理块的集合
<br>若驻留集太小会导致缺页频繁。驻留集太大会导致多道程序并发度下降，资源利用率降低
<br>固定分配：驻留集大小不变
<br>可变分配：驻留集大小可变
<br>局部置换：发生缺页时选进程自己的物理块进行置换
<br>全局置换：将操作系统保留的空闲物理块分配给缺页进程，也可以将别的进程持有的物理块置换到外存，再分配给缺页进程
<br>固定分配局部置换：很难再开始就确定为每个进程分配多少物理块
<br><br>
<br>预调页策略：根据局部性原理，一次调入若干个相邻的页面可能比一次调入一个页面更高效，由于预测成功率较低主要用于进程的首次调入
<br>请求调页策略：进程在运期间发现缺页才调入内存
<br><br>
<br>系统有足够的对换区空间：页面的调入调出在内存与对换区间进行，在进程运行前需要将进程相关的数据从文件区复制到对换区
<br>系统缺少足够的对换区空间：不会被修改的数据直接从文件区调入，可能被修改的部分换出时写回磁盘对换区
<br>UNIX 方式：未使用过的页面存放在文件区，使用过的页面换出时写回对换区，需要时从对换区调入
<br><br>
<br>刚换出的页面马上换入内存，刚换入的页面马上要换出外存
<br>主要原因是因为进程频繁访问的页面数目高于可用的物理块数
<br><br>
<br>进程在某段时间间隔内，实际访问页面的集合
<br>工作集的大小可能小于窗口尺寸，系统可以根据检测工作集的大小调整分配的内存块
<br>驻留集大小不能小于工作集大小，否则运行过程中会频繁缺页
<br><br>
<br>操作系统提供的系统调用
<br>open()：打开文件
<br>mmap()：将文件映射到进程的虚拟地址空间
<br>以访问内存的方式访问文件数据
<br>如果访问的数据没有调入主存，会发生缺页异常，操作系统将文件读入内存
<br>进程关闭文件时，操作系统自动将文件中被修改的数据写回磁盘
<br>多个进程可以映射同一个文件，实现共享
]]></description><link>campus/chinese-notes/计算机科学/考研/os/虚拟内存.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/考研/OS/虚拟内存.md</guid><pubDate>Fri, 07 Jun 2024 02:30:53 GMT</pubDate></item><item><title><![CDATA[基本概念]]></title><description><![CDATA[ 
 <br><br><br>
<br>操作系统 (Operation System, OS) 定义：控制和管理整个计算机系统的硬件和软件资源，并合理地组织调度计算机的工作和资源的分配；以提供给用户和其他软件方便的接口和环境；它是计算机系统中最基本的系统软件 <img alt="Pasted image 20240408191455.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408191455.png" style="width: 200px; max-width: 100%;">
<br><br>
<br>提供的管理功能包括

<br>处理机 (CPU) 管理
<br>存储器管理
<br>文件管理
<br>设备管理


<br><br>
<br>向上层提供方便易用的服务体现了封装的思想。将丑陋的硬件功能封装成简单易用的服务，用户无需关注底层系统的细节

<br>GUI (Graphical User Interface)
<br>联机命令接口：Terminal 等
<br>脱机命令接口：批处理文件
<br>程序接口：系统调用，应用程序请求操作系统服务的唯一方式


<br><br>
<br>将底层硬件组织起来提供更复杂的功能
<br><br><br>
<br>两个或多个事件在同一时间间隔内发生，在宏观上同时发生，微观上交替发生
<br>并行：两个或多个事件在同一时刻同时发生
<br>操作系统的并发性指操作系统的程序在宏观上是同时运行着，但微观上是交替运行的

<br>单核 CPU 同一时刻只能执行一个程序，程序只能并发执行
<br>多核 CPU 同一时刻能执行多个程序，程序可以并行执行


<br><br>
<br>互斥共享方式
<br>同时共享方式：有时宏观上同时，微观上交替访问
<br>并发性与共享性互为存在条件
<br><br>
<br>把一个物理上的实体变为若干个逻辑上的对应物
<br>时分复用技术 (虚拟处理器技术)
<br>空分复用技术 (虚拟存储技术)
<br>没有并发性，虚拟性就失去了意义
<br><br>
<br>系统资源有限，进程的执行以不可预知的速度向前推进，有进程会被阻塞
<br>只有系统拥有并发性，才有可能导致异步性
<br><br><br>
<br>计算机速度快，资源利用率低，计算机大量时间处于空闲状态<br>
<img alt="Pasted image 20240408200542.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408200542.png">
<br><br>
<br>引入脱机输入/输出技术 (外围机 + 磁带)
<br>读取作业花费时间短效率高
<br>程序串行执行，CPU 仍有大量时间等待 I/O<br>
<img alt="Pasted image 20240408200824.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408200824.png">
<br><br>
<br>操作系统支持多道程序并发运行
<br>每次向内存中读入多道程序并发执行
<br>资源利用率大幅提升，但没有人机交互功能<br>
<img alt="Pasted image 20240408202050.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408202050.png" style="width: 400px; max-width: 100%;">
<br><br>
<br>以时间片为单位轮流为各个用户/作业服务
<br>用户请求可以立刻被响应。解决了人机交互问题
<br>不能优先处理一些紧急任务
<br><br>
<br>能够优先响应一些紧急任务，不需要时间片排队
<br>计算机系统收到外部信号后需要在严格的时限内处理完事件
<br>主要它特点是及时性和可靠性
<br>硬实时操作系统和软实时操作系统

<br>硬实时操作系统：在绝对严格的规定时间内完成处理
<br>软实时操作系统：接收偶尔违反时间规定


<br><br>
<br>网络操作系统
<br>分布式操作系统
<br>个人计算机操作系统
<br><br><br>参考 <a rel="noopener" class="external-link" href="https://blog.men.ci/x86-userland-and-syscall/" target="_blank">https://blog.men.ci/x86-userland-and-syscall/</a><br><br>
<br>内核程序

<br>内核是操作系统最重要最核心的部分
<br>让 CPU 执行一些特权指令


<br>应用程序
<br><br>
<br>特权指令
<br>非特权指令
<br><br>
<br>内核态
<br>用户态
<br>程序字状态寄存器 (PSW) 储存 CPU 的状态
<br>CPU 从内核态切换为用户态需要执行特权指令修改 PSW 的标志位为用户态。意味着操作系统让出 CPU 使用权
<br>用户态到内核态的切换由中断引发
<br><br><br>
<br>中断时让操作系态内核夺回 CPU 使用权的唯一途径
<br>中断技术实现了操作系统的并发性
<br><br>
<br>内中断 (异常)

<br>包括陷入 (trap) 、故障 (fault) 和终止 (abort)

<br>陷入：由陷入指令引起，由应用程序故意引发的
<br>故障：由错误条件引起的，可能被内核程序修复，如缺页故障
<br>终止：由致命错误引起，内核程序无法修复改故障，应用程序被终止


<br>CPU 在执行指令时，由指令引发了中断 (指令本身或参数非法)
<br>应用程序想请求操作系统内核的服务，执行陷入指令引发一个内部中断信号(系统调用通过陷入指令完成)


<br>外中断 (中断)

<br>时钟中断：由时钟部件发送的中断信号，实现应用程序的上下文切换
<br>I/O 中断：由输入/输出设备发送的中断信号


<br><br>
<br>CPU 根据不同的中断信号，使用不同的中断处理程序来处理，CPU 会根据中断信号查询中断向量表，查找中断程序在内存中的存放位置
<br><br>
<br>系统调用是应用程序 (程序员) 请求操作系统服务的途径。可以通过系统调用请求操作系统内核的服务<img alt="Pasted image 20240408212837.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408212837.png">
<br>凡是与共享资源有关的操作(如储存分配、I/O 操作、文件管理等)，都必须通过系统调用的方式向操作系统内核提出服务请求，可以保证系统的稳定性和安全性。
<br>应用程序通过传参指令和陷入指令引发内中断，CPU 转入系统调用入口程序，入口程序根据寄存器的参数判断用户需要哪种系统调用服务<img alt="Pasted image 20240415102712.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415102712.png">
<br>陷入指令是非特权指令，对系统调用的响应处理在核心态下完成
<br><br><img alt="Pasted image 20240415103251.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415103251.png"><br>
<br>执行原语的过程中即使有外部信号，CPU 也会执行完原语程序再去处理中断信号
<br>内核是操作系统最基本、最核心的部分
<br>将所有的功能都包含在内核中称大内核，只将与硬件关系最紧密的部分包含在内核中成为微内核
<br>变态的过程是有成本的，频繁切换 CPU 状态会降低系统性能 <img alt="Pasted image 20240415103934.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415103934.png"><img alt="Pasted image 20240415104056.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415104056.png"><img alt="Pasted image 20240415104227.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415104227.png">
<br><br>
<br>每一层只能调用相邻的层级提供的功能接口，而不能跨层调用
<br>便于调试和验证，易于扩充和维护(在两层之间扩充新的一层简单)
<br>难以合理定义各层的边界，效率低不可跨层调用
<br><br>
<br>内核由主模块和可加载内核模块组成
<br>便于多模块并行开发，加载新模块不用重新编译整个内核
<br>分层结构有很明显的单向依赖的关系，所以相较模块化易维护
<br><br>
<br>外核负责为用户进程分配未经抽象的硬件资源
<br>操作系统虚拟化存储器，会导致用户进程对于文件的随机访问效能降低
<br>外核能给用户进程直接分配未经抽象的存储资源
<br>外核仍需要保证硬件资源的使用安全
<br>操作系统需要查页表通过多级访存实现地址映射
<br><br>
<br>ROM 芯片 (BIOS) 中的数据不会因为开机而丢失，CPU 通电会从主存中寻找 ROM 引导程序 (自举程序)，会指示 CPU 将磁盘的主引导记录 (MBR) 读入内存，从而执行 MBR 中的磁盘引导程序，进而找到活动分区中的引导记录 PBR ，PBR 从根目录中找到启动管理器加载到内存中，随后完成操作系统初始化的一系列工作<img alt="Pasted image 20240415200330.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415200330.png">
<br>BIOS 会进行硬件的自检
<br><br>
<br>传统计算机一台物理机上只能运行一个操作系统
<br>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine, VM），每个虚拟机器都可以独立运行一个操作系统
<br>虚拟机管理程序 (Virtual Machine Monitor, VMM) 可以分为两类 <img alt="Pasted image 20240415201212.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415201212.png"><img alt="Pasted image 20240415201935.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240415201935.png">

<br>第一类 VMM：类似于操作系统，直接管理并分配硬件资源，只有虚拟机管理程序运行在内核态，才能使用特权指令。上层操作系统不知道自己运行在用户态，仍然会使用一些特权指令，该动作会由虚拟机管理程序截获并进行转换，上层操作系统运行在虚拟内核空间
<br>第二类 VMM：运行在宿主操作系统上，硬件资源仍然由宿主操作系统进行管理


]]></description><link>campus/chinese-notes/计算机科学/考研/os/计算机系统概述.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/考研/OS/计算机系统概述.md</guid><pubDate>Mon, 15 Apr 2024 12:19:37 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408191455.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240408191455.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[进程的概念]]></title><description><![CDATA[ 
 <br><br>进程时进程实体的运行过程，是系统进行资源分配和调度的一个独立单位<br><br>
<br>进程实体 (进程映像，进程运行某一时刻的快照) 由 PCB , 程序段和数据段组成
<br>操作系统需要对并发运行的进程进行管理，管理时所需要用到的信息都会被放在进程控制快 (Process Control Block, PCB) 中
<br>PCB 是进程存在的唯一标志，在进程创建时创建，在进程结束时回收
<br>Linux kernel 的进程数据结构可以在 <a data-tooltip-position="top" aria-label="https://github.com/torvalds/linux/blob/96fca68c4fbf77a8185eb10f7557e23352732ea2/include/linux/sched.h#L748" rel="noopener" class="external-link" href="https://github.com/torvalds/linux/blob/96fca68c4fbf77a8185eb10f7557e23352732ea2/include/linux/sched.h#L748" target="_blank">Github</a> 浏览
<br><br>
<br>动态性
<br>并发性：内存中有多个进程实体
<br>独立性
<br>异步性
<br>结构性：PCB
<br><br>
<br>进程的状态<br>
1. 创建态 (New) ：操作系统为进程分配资源，初始化 PCB<br>
2. 就绪态 (Ready)：已经具备运行条件，但没有空闲 CPU<br>
3. 运行态 (Running)：单 CPU 下，同一时刻只会有一个程序处于运行态<br>
4. 阻塞态 (Waiting / Blocked)：进程运行过程中主动请求 (系统调用) 等待某个事件的发生，当等待的时间发生，操作系态将进程转换为就绪态<br>
5. 终止态 (Terminated)<br>
<img alt="Pasted image 20240417205834.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240417205834.png">
<br><br>
<br>链式方式
<br>索引方式
<br><br>
<br>进程控制的主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能
<br>操作系统实现进程控制时内核程序需要做两件事，所以进程控制的过程需要用原语来实现，否则会出现关键数据结构信息不统一的情况

<br>修改进程状态变量
<br>变更进程所在队列


<br>原语的原子性由关中断和开中断两个特权指令实现

<br>正常情况下 CPU 每执行完一条指令后检查是否有外部中断信号需要处理
<br>执行关中断指令后，CPU 不再例行检查中断信号，直到执行开中断指令后才会恢复检查，并执行未执行的中断处理程序


<br><br>
<br>进程控制原语所做的事情

<br>更新 PCB 中的信息 (修改进程状态，保存 / 恢复运行环境)
<br>将 PCB 插入合适的队列
<br>分配 / 回收资源


<br><br><img alt="Pasted image 20240422103831.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422103831.png"><br>
<br>申请空白 PCB 
<br>为新进程分配所需资源
<br>初始化 PCB 
<br>将 PCB 插入就绪队列
<br><br>
<br>用户登录
<br>作业调度：多道批处理系统新的作业放入内存
<br>提供服务
<br>应用请求
<br><br><img alt="Pasted image 20240422103844.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422103844.png"><br>
<br>找到 PCB 
<br>若运行立即剥夺 CPU 并重新分配
<br>终止所有子进程
<br>将进程所有的资源归还给父进程或操作系统
<br>删除 PCB 
<br><br>
<br>正常结束：exit 调用
<br>异常结束：指令非法
<br>外界干预
<br><br><img alt="Pasted image 20240422104427.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422104427.png"><br>
<br>找到 PCB 
<br>保护进程运行现场
<br>PCB 插入等待队列
<br><br>
<br>找到 PCB 
<br>从等待队列移除并设置进程为就绪态
<br>将 PCB 插入就绪队列<br>
唤醒原语和阻塞原语成对出现
<br><br><img alt="Pasted image 20240422104527.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422104527.png"><br>
<br>运行环境信息存入 PCB 
<br>PCB 移入响应队列
<br>选择新进程并更新 PCB 
<br>根据 PCB 恢复新进程所需的运行环境
<br><br>
<br>进程间通信 (Inter-Process Communication, IPC) 是指两个进程之间产生数据交互，进程通信的实现需要操作系统的支持
<br>各进程拥有的内存地址空间相互独立
<br><br>
<br>进程可以申请一片共享存储区
<br>共享存储区可以被多个进程使用
<br>int shm_open();
void* mmap();
Copy<br>
<br>使用共享存储区通信时需要保证互斥访问，可以使用操作系统内核提供的同步互斥工具
<br><br>
<br>共享存储区数据的形式、存放位置都由通信进程控制，速度快，属于高级通信方式
<br><br>
<br>共享区域用数据结构的限制，可以理解为特殊的全局变量，共享方式速度慢，属于低级通信方式
<br><br>
<br>进程间的数据交换以格式化的消息 (Message) 为单位。进程通过操作系统提供的"发送消息 / 接收消息"两个原语进行数据交换
<br><br><img alt="Pasted image 20240422111623.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422111623.png"><br>
<br>发送进程需要指明接收进程的 ID
<br><br>
<br>通过信箱间接发送消息
<br>进程 P 通过 OS 申请邮箱
<br>在自己的地址空间内完善消息体的信息
<br>进程 P 通过发送原语指明发送的信箱
<br><br>
<br>写进程想管道一边写入数据，读进程从管道另一边取走数据，数据的流动是单向的
<br>管道是一个特殊的共享文件，实际上实在内存中开辟一个固定的内存缓冲区，和共享存储的区别是读取数据的顺序有限制，可以把管道的内存缓冲区理解为循环队列
<br>管道只能支持半双工通信，某一时间段内只能实现单向的传输，两个方向的数据传输不能同时进行
<br>各进程要互斥地访问管道 (操作系统实现)
<br>管道写满时，写进程需要被阻塞，管道读空时，读进程将阻塞
<br>多个读进程读一个管道时，会发生错乱，有两种解决方案

<br>一个管道允许的多个写进程，一个读进程
<br>一个管道允许多个写进程，多个读进程，操作系统会让各个读进程轮流从管道中读数据 (Linux)


<br><br><img alt="Pasted image 20240422123513.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422123513.png"><br>
<br>有的进程可能需要同时做很多事，传统的进程只能串行执行一系列程序，所以引入线程来增加并发度
<br>引入线程后，线程成为程序执行流的最小单位
<br>线程时一个基本的 CPU 执行单元，也是程序执行流的最小单位
<br>引入线程后进程作为除 CPU 之外系统资源的分配单元<br>
<img alt="Pasted image 20240422123552.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422123552.png">
<br><br><br>
<br>早期的操作系统线程是由线程库实现的
<br>操作系统层面只能看到一个进程，而程序员通过线程库实现了逻辑上的线程
<br>只有用户才能感知到用户级线程的存在
<br><br>
<br>优点：切换在用户空间即可完成，不需要变态，线程管理的系统开销小，效率高
<br>缺点：只要其中一个线程被阻塞，则整个进程都会被阻塞，多个线程不可在多处理机上并行运行
<br><br>
<br>操作系统为每个内核级线程建立相应的线程控制块 (Thread Control Block, TCB)
<br>操作系统只看得见内核级线程，只有内核级线程是处理机分配的单位
<br><br>
<br>优点：一个线程被阻塞其他线程仍能执行，并发能力强，多线程可在多核处理机上并行执行
<br>缺点：一个用户进程会占用多个内核级线程，线程切换优操作系统内核完成，需要切换到核心态，开销大
<br><br><br><br><br><img alt="Pasted image 20240422125608.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422125608.png"><br>
<br>N 用户级线程映射到 m 个内核级线程 (n &gt;= m)，每个用户线程对应 m 个内核级线程
<br>用户级线程是代码逻辑的载体，内核级线程是运行机会的载体
<br><br><img alt="Pasted image 20240422125847.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422125847.png"><br>
<br>线程的状态与转换与进程相类似<br>
<img alt="Pasted image 20240422125958.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240422125958.png">
<br><br>
<br>资源有限时，需要确定某种规则来决定处理任务的顺序
<br><br>
<br>作业：一个具体的任务
<br>高级调度 (作业调度)：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业在声明周期内只被调入调出一次
<br><br>
<br>低级调度 (进程调度 / 处理机调度)：按照某种策略从就绪队列中选择进程
<br><br>
<br>中级调度 (内存调度)：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存
<br><br><img alt="Pasted image 20240424095359.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240424095359.png"><br>
<br>挂起态又可以细分为就绪挂起和阻塞挂起两种状态
<br><br><br>
<br>CPU 处于忙碌的时间占总时间的比例
<br>


<br><br>
<br>单位时间内完成作业的数量
<br>


<br><br>
<br>作业被提交给系统，到作业完成为止的时间间隔
<br>包括高级调度，低级调度，上 CPU 执行，等待 IO 四个部分
<br>待权周转时间
<br><br>
<br>进程 / 作业处于等待处理机状态时间之和
<br>对于进程来说，指进程建立后等待被服务的时间之和，等待 IO 完成的期间进程被 IO 设备服务不计入等待时间
<br>对于作业来说，还需要加上在外存后备队列中等待的时间
<br><br>
<br>指用户提交请求到首次产生响应的时间
<br><br>
<br>当前已运行的进程主动放弃处理机

<br>进程正常终止
<br>运行过程中异常终止
<br>进程主动请求阻塞 (如等待 IO )


<br>被动放弃处理机

<br>时间片用完
<br>更紧急的事 (如 IO 中断)
<br>更高优先级的进程进入就绪队列


<br>不能进程调度和切换

<br>处理中断过程
<br>进程在操作系统内核程序临界区

<br>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
<br>临界区：访问临界资源的代码
<br>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，可以进行进程调度和切换


<br>在原子操作过程中


<br><br><br>
<br>只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态
<br>实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
<br><br>
<br>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程
<br>可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能
<br><br>
<br>狭义的进程调度：从就绪队列中选中一个要运行的进程
<br>进程切换：一个进程让出处理机，由另一个进程占用处理机的过程
<br>广义的进程调度包含选择一个进程和进程切换两个步骤
<br>进程切换的过程主要完成

<br>对原来运行进程各种数据的保存
<br>对新进程各种数据的恢复
<br>PSW PC REG 等保存在 PCB 中


<br>进程的切换是有代价的，如果调度过于频繁会导致系统效率降低
<br><br><img alt="Pasted image 20240424105033.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240424105033.png"><br><br>
<br>创建新进程
<br>进程退出
<br>进程阻塞
<br>I/O 中断发生
<br><br>
<br>没有其他进程运行时，运行闲逛进程
<br>优先级最低
<br>0 地址指令，占完整的指令周期，例行检查中断
<br>能耗低
<br><br>
<br>先来先服务、短作业优先和高响应比优先通常用于早期的批处理操作系统
<br>时间片轮转、优先级调度和多级反馈队列算法使用于交互式系统
<br><br>
<br>先到达后备队列 (作业调度) / 就绪队列 (进程调度) 先服务
<br>优点：公平，实现简单
<br>缺点：对长作业有利，对短作业不利
<br><br>
<br>追求更少的平均等待时间，平均周转时间，平均带权周转时间
<br>最短的作业/进程优先得到服务
<br>非抢占式算法 (默认)
<br>抢占式的短作业优先算法称为最短剩余时间优先算法 (SRTN)：当新来进程的剩余时间比当前运行进程的剩余时间更短，由新进程抢占处理机
<br>在所有进程几乎同时到达时，采用 SJF 调度算法的平均等待时间、平均周转时间最少
<br>抢占式短作业/进程优先调度算法的平均等待时间、平均周转时间最少
<br>优点：短的平均等待时间、平均周转时间
<br>缺点：不公平。对短作业有利，对长作业不利，可能产生饥饿现象
<br><br>
<br>在每次调度是计算各个作业的响应比，选择最高的作业/进程为其服务
<br>非抢占式的调度算法
<br>可用于作业调度，也可用于进程调度
<br><br>
<br>公平、轮流地为各个进程服务
<br>用于进程调度
<br>抢占式算法
<br>常用于分时操作系统，更注重响应时间
<br>在题目中默认新到达的进程先进入就绪队列
<br>时间片太大时间片轮转调度算法会退化为先来先服务调度算法，并且会增大进程响应时间
<br>时间片太小导致进程切换过于频繁
<br><br>
<br>为每个作业 / 进程设置优先级。调度时选择优先级最高的作业 / 进程
<br>有抢占式和非抢占式
<br>如何合理地设置各类进程的优先级

<br>系统进程高于用户进程
<br>前台进程高于后台进程
<br>操作系统更偏好 I/O 型进程


<br>采用动态优先级什么时候应该调整

<br>进程在就绪队列中等待了很长时间，适当提高
<br>占用处理机很长时间，适当降低
<br>进程 I/O 繁忙


<br><br>
<br>抢占式算法
<br>被抢占处理机的进程重新放回原队列队尾
<br>对各类进程相对公平，每个新到达的进程可以很快得到响应，短进程只用较少的时间就可完成，不必实现估计进程的运行时间
<br>可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程可以保持较高优先级
<br><br>
<br>系统按进程类型设置多个队列。进程创建成功后插入某个队列
<br>系统进程 &gt; 交互式进程 &gt; 批处理进程
<br>时间片划分，不同队列分配不同比例的时间
<br>各队列可以采用不同的调度策略
<br><br><br>
<br>进程具有异步性，进程推进的顺序是不可预知的
<br>同步也称直接制约关系，进程需要在某些位置上协调工作次序
<br><br>
<br>临界资源：一个时间段内只允许一个进程使用的资源
<br>临界区：访问临界资源的那段代码
<br>进入区和退出区是负责互斥的代码段
<br>对临界资源的互斥访问需要遵循一下原则

<br>空闲让进
<br>忙则等待
<br>有限等待
<br>让权等待


<br><br><br>
<br>通过 turn 表示当前允许进入临界区的进程号
<br>两个进程访问完临界区后会把使用临界区的权限转交给另一个进程
<br>该算法可以实现互斥
<br>违反了空闲让进的原则
<br><br>
<br>每个进程在进入区检查对方是否想进入临界区
<br>如果对方不想使用资源表达自己想使用资源的意愿
<br>当执行第一句时发生进程切换，两个并发进行的进程会同时进入临界区
<br>违反了忙则等待的原则，检查和上锁的动作不能同时完成
<br><br>
<br>先上锁后检查
<br>违背了空闲让进和有限等待原则，各进程会长期无法访问临界资源从而产生饥饿现象
<br><br>
<br>结合双标志法、单标志法的思想
<br>在进入区主动争取，主动谦让，检查对方是否也想使用
<br>用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待和有限等待三个原则，但并未遵守让权等待原则
<br><br><br>
<br>进程访问临界区之前执行关中断指令
<br>不适用于多处理机系统，只适用于操作系统内核进程，不适用于用户进程
<br>TestAndSet 指令，又称 TSL 指令，把上锁和检查操作用硬件的方式，变成了一气呵成的原子操作，实现简单，使用于多处理机环境，但不满足让权等待规则
<br>Swap (XCHG) 指令
<br><br>
<br>进程进入临界区时应获得锁，在退出临界区时释放锁
<br>需要循环忙等的互斥锁，都可成为自选锁，如 TSL 指令、swap 指令、单标志法
<br>违反让权等待
<br>等待期间不用切换进程上下文，多处理器系统中若上锁时间短，则等待代价很低
<br><br>
<br>用户可以通过操作系统提供的一对原语来对信号量进行操作
<br>信号量其实就是一个变量 (整型或记录型)，可以用信号量表示系统中某种资源的数量
<br>wait、signal 原语常简称为 P、V 操作
<br><br>int S = 1；

void wait (int S) {
	while (S &lt;= 0);
	S = S - 1;
}

void signal (int S) {
	S = S + 1;
}
Copy<br>
<br>两个操作和双标志先检查法的先检查后上锁是一样的，只是使用了原语实现避免了两个进程同时进入临界区的问题
<br>不满足让权等待原则
<br><br>typedef struct {
	int value;
	struct process *L; 
} semaphore;

void wait(semaphore S) {
	S.value--;
	if (S.value &lt; 0) {
		block(S.L);
	}
}

void signal(semaphore S) {
	S.value++;
	if (S.value &lt;= 0) {
		wakeup(S.L);
	}
}
Copy<br>
<br>记录型信号量遵循的让权等待原则
<br>考试中出现的 P(S)、V(S)的操作，除非特别说明，否则默认 S 为记录型信号量
<br><br><br>
<br>划定临界区
<br>对于不同的临界资源需要设置不同的互斥信号量
<br>semphore mutex = 1;

P1() {
	...
	P(mutex);
	临界区代码段
	V(mutex);
	...
}

P2() {
	...
	P(mutex);
	临界区代码段
	V(mutex);
	...
}
Copy<br><br>
<br>进程同步：让各并发进程按要求有序地推进
<br>分析需要实现同步关系的位置
<br>设置同步信号量 S ，初始值为 0
<br>前 V 后 P 
<br>semaphore S = 0;

P1() {
	code 1;
	code 2
	V(S);
	code 3;
}

P2() {
	P(S);
	code 4;
	code 5;
	code 6;
}
Copy<br><br><br><br>
<br>缓冲区没满生产者才能生产，缓冲区不空时，消费者才能从中取出产品，否则必须等待
<br>缓冲区是临界资源，各进程必须互斥地访问
<br>互斥关系是在同一进程中进行一对 PV 操作，同步关系是在一个进程中执行 P，一个进程中执行 V 
<br>semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;

producer () {
	while (1) {
		生产一个产品;
		P(empty);
		P(mutex);
		把产品放入缓冲区;
		V(mutex);
		V(full);
	}
}

consumer () {
	while (1) {
		P(full);
		P(mutex);
		从缓冲区中取出一个产品;
		V(mutex);
		V(empty);
		使用产品;
	}
}
Copy<br><br>
<br>如果在生产者消费者问题中出现缓冲区大于 1 的情况，需要设置一个互斥信号量 mutex 来保证缓冲区的互斥访问
<br>注意互斥的 P 操作一定要在实现同步的 P 操作之后，否则有可能引起死锁
<br><br>
<br>假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)
<br>同步关系

<br>桌上有组合一----第一个抽烟者取走东西
<br>桌上有组合二----第二个抽烟者取走东西
<br>...
<br>发出完成信号----供应者将下一个组合放到桌上


<br>semaphore offer1 = 0;
semaphore offer2 = 0;
semaphore offer3 = 0;
semaphore finish = 0;
int i = 0;

provider () {
	while (1) {
		if (i == 0) {
			将组合一放桌上;
			V(offer1);
		} else if (i == 1) {
			将组合二放桌上;
			V(offer2);
		} else if (i == 2) {
			将组合三放桌上;
			V(offer3);
		}
		i = (i + 1) % 3;
		P(finish);
	}
}

smoker1 () {
	while (1) {
		P(offer1);
		从桌上拿走组合一;
		卷烟;
		抽掉;
		V(finish);
	}
}

...
Copy<br><br>
<br>允许多个读者可以同时读文件
<br>允许一个写者往文件中写信息
<br>任一写者完成写操作前不允许其他读者或写者工作
<br>写者执行写操作前，应让已有的读者和写者全部退出
<br>核心思想在于设置了计数器 count 用来记录当前正在访问共享文件的读进程数
<br>semaphore rw = 1;
int count = 0;
semaphore mutex = 1;
semaphore w = 1; // 实现相对公平的先来先服务

writer () {
	while(1) {
		P(w);
		P(rw);
		写文件...
		V(rw);
		V(w);
	}
}

reader () {
	while(1) {
		P(w);
		P(mutex);
		if(count == 0)
			P(rw);
		count++;
		V(mutex);
		V(w);
		读文件...
		P(mutex);
		count--;
		if(count == 0)
			V(rw);
		V(mutex);
	}
}
Copy<br><br>
<br>防止死锁的状态的发生：

<br>最多允许四个哲学家同时进餐
<br>奇数号哲学家先拿左边的筷子，偶数号哲学家恰好相反
<br>仅当一个哲学家左右两支筷子都可用时才允许抓起筷子


<br>semaphore mutex = 1;
semaphore chopstick[5] = {1, 1, 1, 1, 1};

Pi () {
	while(1) {
		P(mutex);
		P(chopstick[i]);
		P(chopstick[(i + 1) % 5]);
		V(mutex);
		吃饭...
		V(chopstick[i]);
		V(chopstick[(i + 1) % 5]);
		思考...
	}
}
Copy<br><br><br>
<br>信号量机制编写程序困难、易出错
<br>管程是一种特殊的软件模块，由这些部分组成

<br>局部于管程的共享数据结构说明
<br>对该数据结构进行操作的一组过程
<br>对局部于管程的共享数据设置初始值的语句
<br>管程有一个名字


<br>基本特征

<br>每次仅允许一个进程在管程内执行某个内部过程
<br>由编译器负责实现各进程互斥地进入管程中的过程


<br><br><br>
<br>死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象，至少有两个或两个以上的进程同时发生死锁
<br>饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象，有可能是阻塞态(长期得不到需要的 I/O 设备)，也可能是就绪态(长期得不到处理机)
<br><br>
<br>互斥条件
<br>不剥夺条件
<br>请求和保持条件
<br>循环等待条件 (发生死锁一定有循环等待，但是发生循环等待时未必死锁)

<br>如果同类资源数大于 1，则即使有循环等待，也未必发生死锁


<br><br>
<br>预防死锁
<br>避免死锁 (银行家算法)
<br>死锁的检测和解除
<br><br><br>
<br>互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
<br>如 SPOOLing 技术可以把独占设备在逻辑上改造成共享设备
<br>缺点：不是所有资源都可以改造成可共享使用的资源。并且为了系统安全很多多方都比西保护这种互斥性
<br><br>
<br>方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时重新申请
<br>方案二：当某个进程需要的资源被其他进程所占有时，可以由操作系统协助，将想要的资源强行剥夺
<br>缺点

<br>实现复杂
<br>释放已获得的资源可能造成前一阶段工作的失败
<br>反复的申请和释放资源会增加系统开销，降低系统吞吐量
<br>采用方案一可能会导致进程饥饿


<br><br>
<br>采用静态分配方法进程在运行前一次申请完所需要的全部资源
<br>容易造成资源浪费，资源利用率低，有可能导致进程饥饿
<br><br>
<br>采用顺序资源分配法：规定每个进程必须按编号递增的顺序请求资源，同类资源需要一次申请完
<br>缺点：

<br>不方便增加新的设备
<br>进程实际使用资源的顺序可能与编号递增顺序不一致，会导致资源浪费
<br>必须按规定次序申请资源，用户编程麻烦


<br><br><br>
<br>核心思想：在进程提出资源申请时，预先判断此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待
<br>待补充
<br><br><br>
<br>用某种数据结构来保存资源的请求和分配信息
<br>提供一种算法，利用上述信息来检测系统是否已进入死锁状态
<br>资源分配图<img alt="Pasted image 20240603104619.png" src="/campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240603104619.png">
<br>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。如果最终能消除所有边，则称这个图是可完全简化的。此时一定没有发生死锁
<br><br>
<br>资源剥夺法：挂起某些死锁进程，并抢占它的资源
<br>撤销进程法
<br>进程回退法：操作系统需要记录进程的历史信息，设置还原点
<br>考虑对哪个进程进行操作

<br>进程优先级
<br>已执行多长时间
<br>还要多久完成
<br>交互式还是批处理式


]]></description><link>campus/chinese-notes/计算机科学/考研/os/进程与线程.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/考研/OS/进程与线程.md</guid><pubDate>Tue, 04 Jun 2024 03:14:32 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240417205834.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/考研/os/attachments/pasted-image-20240417205834.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dijkstra]]></title><description><![CDATA[ 
 
  
  
  
    
    
  
  ]]></description><link>campus/chinese-notes/计算机科学/计算机网络/excalidraw/dijkstra.excalidraw.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/Excalidraw/Dijkstra.excalidraw.md</guid><pubDate>Thu, 20 Jun 2024 13:38:15 GMT</pubDate></item><item><title><![CDATA[C++ Crash Course]]></title><description><![CDATA[ 
 <br><br><br>
<br>C++ 编译器在编译过程中将文本文件 (Text File) 转变为对象文件 (Object File)，随后产生的对象文件再被链接器处理
<br>在编译过程中会经过几个过程

<br>预处理 (Pre-Process)：所有预处理语句 (P-P Statement) 被评估 (Evaluate)，包括 Include / Define / If / Ifdef / Pragma 等
<br>标记解释 (Tokenizing)
<br>解析 (Parsing)


<br>编译器的工作是把代码转换为常量数据 (Constant Data) 或指令，将代码转换为抽象语法树 (abstract syntax tree) 的形式
<br>当编译过程完成时，编译器为每个编译单元 (translation unit)，也就是单个 .cpp 文件 (实际上与后缀名无关，文件只是用来给编译器提供源码的方法)，生成对应的对象文件 
<br>在一个 cpp 文件中 include 另一个 cpp 文件往往只是生成了一大的 cpp 文件，所以其中一共包含 1 个编译单元同时只会编译出一个对象文件
<br><br>
<br>预处理器打开被 include 的文件，读取所有内容并粘贴替换掉写 include 的语句
<br>代码示例
<br>.
├── EndBrace.h
├── Log.cpp
├── Math.cpp
├── main.cpp
└── rooster.dSYM
Copy<br>// EndBrace.h
}
Copy<br>// Math.cpp
int Multiply(int a, int b) {
    int result = a * b;
    return result;
#include "EndBrace.h"
Copy<br>&gt; g++ -c Math.cpp # 成功编译
&gt; g++ -E Math.cpp # 编译器只执行预处理过程
# 0 "Math.cpp"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "Math.cpp"
int Multiply(int a, int b) {
    int result = a * b;
    return result;
# 1 "EndBrace.h" 1
}                 # 实际上只是把 "}" 粘贴到 #include "EndBrace.h" 的位置
# 5 "Math.cpp" 2
Copy<br>// changed Math.cpp
#define INTEGER int
 INTEGER Multiply(int a, int b) {
    INTEGER result = a * b;
    return result;
}
Copy<br>&gt; g++ -E Math.cpp # 在经过预处理后将所有的 INTEGET 替换为了 int
# 0 "Math.cpp"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "Math.cpp"

 int Multiply(int a, int b) {
    int result = a * b;
    return result;
}
Copy<br>// changed Math.cpp
#if 1
int Multiply(int a, int b) {
	int result = a * b;
	return result;
}
#endif
Copy<br>&gt; g++ -E Math.cpp
# 0 "Math.cpp"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "Math.cpp"

int Multiply(int a, int b) {
 int result = a * b;
 return result;
}
Copy<br>// changed Math.cpp
#if 0
int Multiply(int a, int b) {
	int result = a * b;
	return result;
}
#endif
Copy<br>&gt; g++ -E Math.cpp
# 0 "Math.cpp"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "Math.cpp"
Copy<br>
<br>为什么包含了 &lt;iostream&gt; 头文件编译后得到的对象文件会这么大：编译器向原文件内插入了 iostream 中 (包括 iostream 中 include) 的代码 (三万多行) <img alt="Pasted image 20231202214923.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231202214923.png">
<br>// changed Math.cpp
#include &lt;iostream&gt;
int Multiply(int a, int b) {
	int result = a * b;
	return result;
}
Copy<br>&gt; g++-13 -E Math.cpp &gt;&gt; output
Copy<br><img alt="Pasted image 20231202220808.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231202220808.png"><br><br>
<br>在 M1 Pro Chip 上生成的 armv 8-a 指令集的代码
<br>int Multiply(int a, int b) {
	int result = a * b;
	return result;
}
Copy<br>&gt; g++-13 -S Math.cpp 
Copy<br>	.arch armv8-a
	.text
	.align	2
	.globl __Z8Multiplyii
__Z8Multiplyii:
LFB0:
	sub	sp, sp, #32
LCFI0:
	str	w0, [sp, 12]
	str	w1, [sp, 8]
	ldr	w1, [sp, 12]
	ldr	w0, [sp, 8]
	mul	w0, w1, w0
	str	w0, [sp, 28]
	ldr	w0, [sp, 28]
	add	sp, sp, 32
LCFI1:
	ret
LFE0:
	.section __TEXT,__eh_frame,coalesced,no_toc+strip_static_syms+live_support
EH_frame1:
	.set L$set$0,LECIE1-LSCIE1
	.long L$set$0
LSCIE1:
	.long	0
	.byte	0x1
	.ascii "zR\0"
	.uleb128 0x1
	.sleb128 -8
	.byte	0x1e
	.uleb128 0x1
	.byte	0x10
	.byte	0xc
	.uleb128 0x1f
	.uleb128 0
	.align	3
LECIE1:
LSFDE1:
	.set L$set$1,LEFDE1-LASFDE1
	.long L$set$1
LASFDE1:
	.long	LASFDE1-EH_frame1
	.quad	LFB0-.
	.set L$set$2,LFE0-LFB0
	.quad L$set$2
	.uleb128 0
	.byte	0x4
	.set L$set$3,LCFI0-LFB0
	.long L$set$3
	.byte	0xe
	.uleb128 0x20
	.byte	0x4
	.set L$set$4,LCFI1-LCFI0
	.long L$set$4
	.byte	0xe
	.uleb128 0
	.align	3
LEFDE1:
	.ident	"GCC: (Homebrew GCC 13.2.0) 13.2.0"
	.subsections_via_symbols
Copy<br><br>
<br>找到每个函数 (function) 和符号 (symbol) 的位置，并把它们链接到一起
<br>没有外部文件的函数时，应用程序仍然需要知道 entry point 在哪里，C 运行时库需要调用 main 函数 (entry point 不一定是 main 函数，例如 gcc 可以通过 -e entry_point_function 修改)，所以仍然需要链接过程
<br>// 当生成可执行文件的对象文件没有 entry point 时，会在链接阶段发生错误 
#include &lt;iostream&gt;

void Log(const char* message) {
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int Multiply(int a, int b) {
	int result = a * b;
	return result;
}
Copy<br>&gt; g++-13 Math.cpp
Undefined symbols for architecture arm64:
  "_main", referenced from:
     implicit entry/start for main executable
ld: symbol(s) not found for architecture arm64 # ld: GNU linker
collect2: error: ld returned 1 exit status
Copy<br>// 当源文件具有语法错误时，会在编译阶段发生错误
#include &lt;iostream&gt;

void Log(const char* message) {
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int Multiply(int a, int b) {
	int result = a * b;
	return result // 缺少";"
}
Copy<br>&gt; g++-13 Math.cpp
Math.cpp: In function 'int Multiply(int, int)':
Math.cpp:9:22: error: expected ';' before '}' token
    9 |         return result
      |                      ^
      |                      ;
   10 | }
      | ~           
Copy<br>// 修改程序添加 main 函数后，应用生成成功， 不指定 -o 则程序名称为 a.out
#include &lt;iostream&gt;

void Log(const char* message) {
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int Multiply(int a, int b) {
	int result = a * b;
	return result;
}

int main() {

}
Copy<br>
<br>知道自己的程序在编译阶段还是链接阶段发生错误很重要
<br><br>// Log.cpp
#include &lt;iostream&gt;

void Logrrrrrrrrrr(const char* message) {
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

// Math.cpp
#include &lt;iostream&gt;

void Log(const char* message);

static int Multiply(int a, int b) {
	Log("Multiply");
	return a * b;
}

int main() {
	//std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl; // 程序执行流中没有用到 Multiply 和 Log 不需要去别的编译单元中寻找 Log 的定义
	std::cin.get();                             // 其他的编译单元也不会使用 Multiply 函数的定义
}
Copy<br>
<br>在函数前加上 static 说明函数只是为当前的编译单元声明的，所以当链接器确保声明的函数不会被当前编译单元使用，也不会被其他编译单元使用时，在链接的过程中就不会报错
<br>函数的声明需要找到一模一样的函数定义，当函数定义的返回值类型和参数类型与声明不同时，链接就会报错
<br>当有两个一模一样的函数定义时，特别是个函数定义在多个 cpp 文件中时，就会发生链接错误
<br>// Log.h
void Log(const char* message) {
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

// Log.cpp
#include &lt;iostream&gt;
#include "Log.h"

void InitLog() {
	Log("Initialized Log")
}


// Math.cpp
#include &lt;iostream&gt;
#include &lt;"Log.h"&gt;

void Log(const char* message);

static int Multiply(int a, int b) {
	Log("Multiply");
	return a * b;
}

int main() {
	std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;
	std::cin.get(); 
}
Copy<br>(base) ➜  3.4ErrorsWarnings clang++ Log.cpp Math.cpp
duplicate symbol 'Log(char const*)' in:
    /var/folders/fm/bbrq4pn10y39tjf0pf97xm4h0000gn/T/Log-1d2c94.o
    /var/folders/fm/bbrq4pn10y39tjf0pf97xm4h0000gn/T/Math-cd0cae.o
ld: 1 duplicate symbol for architecture arm64
clang: error: linker command failed with exit code 1 (use -v to see invocation)
Copy<br>
<br>两个文件中在源文件中都包含了 Log 的定义，所以在链接时会报错
<br>// Log.h
inline void Log(const char* message) {
    std::cout &lt;&lt; message &lt;&lt; std::endl;
}

// Log.cpp
#include &lt;iostream&gt;
#include "Log.h"

void InitLog() {
	// Log("Initialized Log") 
	std::cout &lt;&lt; "Initialized Log" &lt;&lt; std::endl;
}


// Math.cpp
#include &lt;iostream&gt;
#include &lt;"Log.h"&gt;

void Log(const char* message);

static int Multiply(int a, int b) {
	// Log("Multiply");
	std::cout &lt;&lt; "Multiply" &lt;&lt; std::endl;
	return a * b;
}

int main() {
	std::cout &lt;&lt; Multiply(5, 8) &lt;&lt; std::endl;
	std::cin.get(); 
}
Copy<br>
<br>使用 inline 时将函数体直接插入到函数调用中，不需要去寻找函数的定义所以就不会产生链接错误
<br>当然，将函数的定义移动到第三个翻译翻元中也同样可以解决这个问题
<br><br>
<br>C++中变量主要决定了划分存储空间的大小 (用 sizeof() 函数来查看)
<br>如果小数后不加"f"则是一个 double 类型的数据
<br>bool 类型的变量只占据一个字节，因为内存的最小寻址单元是一个字节，当要存储多个 bool 变量时，可以放在一个字节中
<br><br>
<br>在 Debug 模式下，只有主函数不用返回一个值，如果没有指定返回值会默认返回 0，其他有返回类型的函数都需要有返回值
<br>将函数分为声明和定义，通常声明会写在头文件里，定义会写在编译单元里
<br><br>
<br>头文件通常用于声明某些函数类型，以便可以用于整个程序中，因为在在链接时我们只能定义一个函数一次，所以需要一个共同的地方存放函数声明，告诉编译单元这个函数存在，就不需要将函数声明到处复制粘贴
<br>#pragma once 意味着一个翻译单元只包含一个头文件一次
<br>// Common.h
#pragma once
#include "Log.h"

// Log.h
void InitLog();
void Log(const char* message);

struct Player {};

// Main.cpp
#include "Common.h"
#include "Log.h"

#include &lt;iostream&gt;

void InitLog() {
	Log("Initializing Log");
}

void Log(const char* message) {
	std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int main()
{
	InitLog();
	return 0;
}
Copy<br>
<br>预处理后的编译单元中 struct 出现了两次
<br>......&lt;iostream&gt;

# 0 "main.cpp"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "main.cpp"
# 1 "Common.h" 1
       
# 1 "Log.h" 1
void InitLog();
void Log(const char* message);

struct Player {};
# 3 "Common.h" 2
# 2 "main.cpp" 2
# 1 "Log.h" 1
void InitLog();
void Log(const char* message);

struct Player {};
# 3 "main.cpp" 2



void InitLog() {
 Log("Initializing Log");
}

void Log(const char* message) {
 std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int main()
{
 InitLog();
 return 0;
}
Copy<br>
<br>Log.h 中加入 #pragma once 后可以看到第二处 struct 并没有在预编译时被加入
<br># 0 "main.cpp"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "main.cpp"
# 1 "Common.h" 1
       
# 1 "Log.h" 1
       
void InitLog();
void Log(const char* message);

struct Player {};
# 3 "Common.h" 2
# 2 "main.cpp" 2




void InitLog() {
 Log("Initializing Log");
}

void Log(const char* message) {
 std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int main()
{
 InitLog();
 return 0;
}
Copy<br>
<br>更传统的处理方法是使用 #if #endif
<br>#ifndef _LOG_H
#define _LOG_H

void InitLog();
void Log(const char* message);

struct Player {};

#endif
Copy<br>
<br>相当于将文件粘贴到源文件中，如果_LOG_H 被定义了，则不会被重复定义
<br>
#include &lt;iostream&gt;

#ifndef _LOG_H
#define _LOG_H

void InitLog();
void Log(const char* message);

struct Player {};

#endif

#ifndef _LOG_H
#define _LOG_H

void InitLog();
void Log(const char* message);

struct Player {};

#endif

void InitLog() {
	Log("Initializing Log");
}

void Log(const char* message) {
	std::cout &lt;&lt; message &lt;&lt; std::endl;
}

int main()
{
	InitLog();
	return 0;
}
Copy<br>
<br>尖括号是在编译时有办法告诉编译器的包含路径，而引号包含的文件存在于源文件的相对位置或者是编译器知道的包含路径
<br>为了区分 c 标准库和 c++ 标准库，c 库中的头文件一半有 .h 扩展名而 c++ 没有
<br><br>
<br>调试包括下断点和查看内存
<br>箭头表示在所指的代码上但是并没有实际执行那段代码
<br>调试时如何跳出循环：在想到达的地方下一个端点并 continue 
<br><br>
<br>条件结构就是当条件为真时执行一部分代码
<br>所有 c++ 中的运算符都某种方式被实现过了
<br>在检测两个 int 是否相等时，实际上是将每个值从内存中抓取出来并做逐字节的比较
<br>条件判断直接使用一个变量相当于直接去存储该变量的内存块中查看该变量是否为 0

<br>这种方法同时也能用来检验一个指针是否为空


<br>把判断语句和将要执行的语句放在一行在调试时无法查看执行语句的具体情况
<br>else if 只是把 else 和 if 结合起来了
<br>const char* white = "Moe";
else if (white == "Moe")
	Log("White is very cute.");
//等同于
else {
	if (white == "Moe")
		Log("White is very cute.");
}
Copy<br><br>
<br>for loop
<br>不用先声明变量或每次循环更新值时，用 while 通常是更好的选择
<br>do while 的 body 至少会被执行一次
<br><br>
<br>continue
<br>break
<br>return
<br><br>
<br>指针存储了内存地址的数值
<br>指针的类型只对操作内存有用
<br>
<br>可以使用 new 在让程序在堆上分配一段空间
<br>char* buffer = new char[8];
memset(buffer, 0, 8);

delete[] buffer;
Copy<br>
<br>二级指针只是指向一个指针，而这个指针又指向一个内存地址
<br>char* buffer = new char[8];
memset(buffer, 0, 8);

char** ptr buffer;

delete[] buffer;
Copy<br><br>
<br>在本质上来说，引用就是指针
<br>引用必须引用一个已经存在的变量，引用本身并不是一个新的变量，并不占据内存空间
<br>int a = 5;
int&amp; ref = a;
ref = 2;
Copy<br>
<br>Passing by reference, 所做的事情是相同的，引用只是指针的一种语法🍬，所以声明引用时必须立刻给引用赋值
<br>void Increment(int* value) {
	(*value)++;
}

int main() {
	int a = 5;
	Increment(&amp;a)
}
Copy<br>void Increment(int&amp; value) {
	value++;
}

int main() {
	int a = 5;
	Increment(a)
}
Copy<br>
<br>如果想改变引用指代的内容，需要用到指针才行
<br>	int a = 5;
	int b = 8;

	int&amp; ref = a;
	ref = b; // 变量 a 内存地址的值被赋为 8 

	int* ref = &amp;a;
	*ref = 2;
	ref = &amp;b;
	*ref = 1;
Copy<br><br>
<br>类是一种将数据和函数组织在一起的方式
<br>注意类的结尾还有一个分号
<br>创建类时可以指定类中成员的可见性，默认情况下类中的成员访问控制都是私有的
<br>类和结构的区别是默认情况下类的成员是私有的，C++ 中结构体存在的意义是保持和 C 的兼容性
<br>Cherno 在使用一些简单数据结构 POD (plain old data) 或者仅包含一些变量的结构
<br>如果需要用到继承，使用类比较合适
<br><br>#include &lt;iostream&gt;

class Log {
public:
	const int LogLevelError = 0;
	const int LogLevelWarning = 1;
	const int LogLevelInfo = 2;
private:
	int m_LogLevel = LogLevelInfo;
public:
	void SetLevel(int level) {
		m_LogLevel = level;
	}

	void Error(const char* message) {
		if (m_LogLevel &gt;= LogLevelError)
			std::cout &lt;&lt; "[Error]: " &lt;&lt; message &lt;&lt; std::endl;		
	} 
	void Warn(const char* message) {
		if (m_LogLevel &gt;= LogLevelWarning)
			std::cout &lt;&lt; "[Warning]: "&lt;&lt; message &lt;&lt; std::endl;		
	} 
	void Info(const char* message) {
		if (m_LogLevel &gt;= LogLevelInfo)
			std::cout &lt;&lt; "[Info]: "&lt;&lt; message &lt;&lt; std::endl;		
	} 
};

int main() {
	Log log;
	log.SetLevel(log.LogLevelError);
	log.Warn("Hello");
	log.Info("Hello");
	log.Error("Hello");
	std::cin.get();	
}
Copy<br><br>
<br>类外 static 关键字在链接阶段修饰的函数是局部的，只对定义它的编译单元可见
<br>类和结构体内部的 static 表示被修饰的这部分内存是这个类的所有实例共享的
<br><br>
<br>extern 关键字，在另外的编译单元中寻找该名称的定义，这又被称为 external linking
<br>什么时候用 static 就像对类成员使用 private 一样
<br><br>
<br>通过类实例引用静态变量是没有意义的 (this)
<br>静态方法不用通过类的实例就可以调用 (类名加规范解析运算符就可以访问)
<br>在静态方法内部也无法访问到类的实例，不能写引用类的实例的代码，也不能访问非静态变量
<br>不同类实例中使用的静态变量指向同一个内存空间，就像在命名空间里一样，通常使用 [Class Name]::[Variable] 来调用
<br>本质上在类里写的每个非静态方法都会获得当前的类实例作为参数 (this 指针)，静态方法因为并没有传入隐藏参数 (this) 所以不知道怎么访问类实例中的数据
<br><br>
<br>之前了解的是全局作用域中的 static 以及类和结构体内的 static 
<br>生命周期：变量在被删除之前在内存中停留多久
<br>作用域：可以访问这个变量的范围
<br>local static 变量允许声明一个生命周期是整个程序的生存期的变量，但是作用域被限制在声明变量的函数中 (不一定是函数，if 语句之类的也行)
<br>#include &lt;iostream&gt;

void Function() {
	static int i = 0;
	i++;
	std::cout &lt;&lt; i &lt;&lt; std::endl
}

int main() {
	Function();
	std::cin.get();
	return 0;
}
Copy<br>
<br>当然可以通过声明全局变量来做到这一点，但是在任何地方都能访问到这个变量
<br>不使用静态局部变量时，如果要创建一个单例类，需要写很多的代码
<br>#include &lt;iostream&gt;

class Singleton {
private:
	static Singleton* s_Instance;
public:
	static Singleton&amp; Get() { return *s_Instance; }
	void Hello() {}
};

class Singleton {
public:
	static Singleton&amp; Get() {
		static Singleton instance; //如果没有 static 关键字在跳出函数作用域时栈上的 instance 在一段时间后会被销毁，而这在C++中是不安全的，此时通过引用访问它可能会导致未定义的行为，一段时间后访问这个引用可能会出错
		return instance;
	}
	
	void Hello() {}
};

int main() {
	Singleton::Get().Hello();

	std::cin.get();
}
Copy<br>
<br>单例类（Singleton Class）是一种常见的设计模式，用来确保一个类只有一个实例，并且提供一个全局的访问点来获取这个唯一实例。单例模式通常用于管理共享资源，如数据库连接或文件系统，以及在应用程序中实现全局状态或配置管理
<br><br>
<br>用于给一个值指定一个名称，增加代码的可读性
<br>可以通过在名称后加入 : 指定枚举的数据类型
<br>枚举实际上就是整数
<br>enum Example : unsigned char {
	A = 5, B, C
}
Copy<br>#include &lt;iostream&gt;

class Log
{
public:
	enum Level
	{
		LevelError = 0, // 和方法名存在命名冲突，此时加入前缀比较好
		LevelWarning,
		LevelInfo
	};

private:
	Level m_LogLevel = LevelInfo; // 如果需要将 LogLevel 的取值范围限制在 enum 的范围内可以将 m_LogLevel 的类型设置为 Level
public:
	void SetLevel(Level level)
	{
		m_LogLevel = level;
	}

	void Error(const char *message)
	{
		if (m_LogLevel &gt;= LevelError)
			std::cout &lt;&lt; "[Error]: " &lt;&lt; message &lt;&lt; std::endl;
	}
	void Warn(const char *message)
	{
		if (m_LogLevel &gt;= LevelWarning)
			std::cout &lt;&lt; "[Warning]: " &lt;&lt; message &lt;&lt; std::endl;
	}
	void Info(const char *message)
	{
		if (m_LogLevel &gt;= LevelInfo)
			std::cout &lt;&lt; "[Info]: " &lt;&lt; message &lt;&lt; std::endl;
	}
};

int main()
{
	Log log;
	log.SetLevel(Log::LevelError); // Error 枚举值存在于 Log类的命名空间，也有枚举类但是对于普通的 Level 枚举不能将其当作命名空间
	log.Warn("Hello");
	log.Info("Hello");
	log.Error("Hello"); 
	std::cin.get();
}
Copy<br><br>
<br>构造函数没有返回类型，并且命名需要和类名相同
<br>没有指定构造函数实际上会使用一个空的默认构造函数
<br>不像 Java 中，C++中必须手动初始化所有基本类型，所以不要忘记初始化
<br>使用类的静态方法时构造函数不会被调用
<br>#include &lt;iostream&gt;

class Entity
{
public:
	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f;
	}

	// 函数重载
	Entity(float x, float y)
	{
		X = x;
		Y = y;
	}

	void Print()
	{
		std::cout &lt;&lt; X &lt;&lt; ", " &lt;&lt; Y &lt;&lt; std::endl;
	}
};

int main()
{
	Entity e;
	e.Print();
	std::cin.get();
}
Copy<br>
<br>如果不想使用类的时候将实例化，有两种方法：

<br>将构造函数设置为私有
<br>使用 delete 删除默认构造函数


<br>class Log {
private:
	Log() {}
public:
	Log() = delete;
};
Copy<br><br>
<br>析构函数同时适用于栈和堆分配的内存，当用 new 关键字在堆上创建一个对象，调用 delete 时析构函数会被调用，对于栈上的对象当跳出作用域对象被删除时析构函数也会被调用
<br>在构造函数中进行初始化工作后需要在析构函数中释放内存，否则容易造成内存泄露，如果手动在堆上分配了任何类型的内存空间，也需要手动进行清除操作
<br>#include &lt;iostream&gt;

class Entity
{
public:
	float X, Y;

	Entity()
	{
		X = 0.0f;
		Y = 0.0f;
		std::cout &lt;&lt; "Created Entity!" &lt;&lt; std::endl;

	}

	~Entity() {
		std::cout &lt;&lt; "Destroyed Entity!" &lt;&lt; std::endl;
	}

	void Print()
	{
		std::cout &lt;&lt; X &lt;&lt; ", " &lt;&lt; Y &lt;&lt; std::endl;
	}
};

void Function() {
	Entity e;
	e.Print();
}

int main()
{
	Function();
	std::cin.get();
}
Copy<br><br>
<br>类继承使类之间存在相互关联的层级关系
<br>可以帮助避免很多重复代码
<br>继承可以将一系列通用代码放入基类中
<br>#include &lt;iostream&gt;

class Entity
{
public:
	float X, Y;

	void Move(float xa, float ya) {
		X += xa;
		Y += ya;
	}
};

class Player : public Entity // Player不仅仅是Player类，同时也是Entity类，Entity中的任何公有成员Player都能访问到，Player是Entity的一个超集
{							 // 多态是使用一个符号表示多种类型
public:
	const char* Name;

	void PrintName() {
		std::cout &lt;&lt; Name &lt;&lt; std::endl;
	}
};

int main()
{
	std::cout &lt;&lt; sizeof(Player) &lt;&lt; " " &lt;&lt; sizeof(Entity) &lt;&lt; std::endl; // 类的大小是可变化的，如果要重写Player中的函数就要维护一个虚函数表，会占用额外的内存

	std::cin.get();
}
Copy<br><br>
<br>虚函数可以在子类中重写方法
<br>虚函数引入了动态分配，通过虚表 (vtable) 来实现编译，虚表是包含类中所有虚函数映射的列表，可以通过虚表在运行时找到正确的被重写的函数，如果要重写一个函数，需要把基类中的原函数设置为虚函数
<br>使用虚函数时的额外开销，需要额外的内存来存储虚表，基类中还有一个指针成员指向虚表，每次调用虚函数时必须遍历虚表去找到最终要运行的函数，在一些嵌入式平台上虚函数的开销可能成为考虑的内容
<br>#include &lt;iostream&gt;

class Entity
{
public:
	virtual std::string GetName() { return "Entity"; };
};

class Player : public Entity
{
private:
	std::string m_Name;

public:
	Player(const std::string &amp;name)
		: m_Name(name) {} // 初始化列表，用于在构造函数体执行前初始化成员变量和基类

	std::string GetName() override { return m_Name; }
};

void PrintName(Entity* entity) {
	std::cout &lt;&lt; entity-&gt;GetName() &lt;&lt; std::endl;
}


int main()
{
	Entity* e = new Entity();
	PrintName(e);

	Player* p = new Player("Cherno");
	PrintName(p);						//在类中正常声明的函数或方法调用方法时会去调用属于该类型的方法

	std::cin.get();
}
Copy<br><br>
<br>纯虚函数允许定义一个在基类中没有实现的函数，强制子类去实现这个函数
<br>在 <a data-tooltip-position="top" aria-label="C++ Crash Course > 虚函数" data-href="C++ Crash Course#虚函数" href="/campus/chinese-notes/计算机科学/计算机网络/c++-crash-course.html#虚函数" class="internal-link" target="_self" rel="noopener">虚函数</a> 实现的 GetName() 方法对于子类的重写是没有强制的
<br>有时候需要强制子类为某个特定的函数提供自己的定义
<br>接口：只包含为实现的方法并作为一个模版的类，由于接口类实际上不包含方法实现，所以无法实例化这个类
<br>只能实例化实现了所有纯虚函数的类，纯虚函数只要在一条继承链上被实现过就可以，重点是虚函数必须被实现
<br>#include &lt;iostream&gt;

class Printable
{
public:
	virtual std::string GetClassName() = 0;
};

class Entity : public Printable
{
public:
	std::string GetClassName() override { return "Entity"; }
};

class Player : public Entity
{
private:
	std::string m_Name;

public:
	Player(const std::string &amp;name)
		: m_Name(name) {}

	std::string GetClassName() override { return "Player"; }
};

void Print(Printable *obj)
{
	std::cout &lt;&lt; obj-&gt;GetClassName() &lt;&lt; std::endl;
}

int main()
{
	Entity *e = new Entity();
	Player *p = new Player("Cherno");

	Print(e);
	Print(p);

	std::cin.get();
}
Copy<br><br>
<br>指一个类中的成员和方法是否可见 (能够被访问、调用或使用)
<br>可见性对于程序程序的性能不会造成影响
<br>三种基础的可见修饰符 private protected public
<br>private：只有当前类可以访问到这些变量 (friend 允许其他类访问该类的私有成员)
<br>protected：可见性比 private 更高，但要低于 public，当前类以及当前类的派生类都能访问到这些成员
<br>可见性更方便维护、理解和拓展代码，确保他人不会调用不应该被调用的代码
<br>class Entity
{
protected:
	int X, Y;
public:
	Entity() {
		X = 0;
	}
};

class Player : Entity
{
public:
	Player() {
		X = 2;
	}
};
Copy<br><br>
<br>数组是一些元素的集合，是按照特定顺序排列的东西
<br>当索引一个数组中的元素时，会得到一个底层的数据类型
<br>当访问一个不在数组中的索引时会产生内存访问冲突 (memory access violation) ，所以要确定在数组的规定范围内操作
<br>数组常伴随 for 循环，可以在特定范围内使用索引进行遍历
<br>数组就是一个指针，指向一个连续的数据块
<br>内存间接寻址，比如在类的地址处存储一个指针指向数组的内存地址，间接寻址会影响性能
<br>C++11 中的数组 std::array ，有边界检查并且记录数组的大小，使用普通的堆上数组无法得知数组的大小，需要手动维护数组大小，而栈上数组又存在作用域限制
<br>当在栈中用数组申请内存时，数组大小需要是一个编译时就知道的常量，需要使用关键字 constexpr ，同时类中的 constexpr 变量需要是静态的
<br>#include &lt;iostream&gt;
#include &lt;array&gt;

class Entity
{
public:
	static const int exampleSize = 5;
	int example[exampleSize];

	std::array&lt;int, 5&gt; another;

	Entity() {
		for (int i = 0; i &lt; another.size(); i++) {
			example[i] = 2;
		}
	}
}
Copy<br><br>
<br>可以用最多 N 个可转换为 T 的初始值进行聚合初始化 std::array&lt;int, 3&gt; a = {1, 2, 3};
<br>N == 0 时 array.begin() == array.end() , front() 和 back() 的结果是未定义的
<br><br>
<br>字符串是一种能够表示和处理文本的方法，是一个字符数组
<br>C++中处理字符的编码方式是 ASCII
<br>字符串结束的位置有一个空中止符 (the null termination character)
<br>std::string 本质上是 std::basic_string 将 char 作为模版参数 (template specializaton) 的模版类实例
<br>#include &lt;iostream&gt;
// #include &lt;string&gt;

/*
把类对象传给一个函数实际上是创建了这个对象的拷贝然后再传给函数，
复制string意味着要在堆上创建全新的 char 数组来存储得到的完全相同的文本
这非常慢
*/
void PrintString(std::string&amp; string) { 
	std::cout &lt;&lt; string &lt;&lt; std::endl;
}

int main()
{
	// C++中用字符串定义时实际的类型是 const char*
	std::string name = "Cherno"; // name 是在栈上分配的，无法使用 delete
	name += "Hello";
	name.size();
	bool contains = name.find("no") != std::string::npos; // find 返回文本的位置
	std::cout &lt;&lt; name &lt;&lt; std::endl; // string头文件重载了 &lt;&lt; 操作符，允许将字符串传入输出流

	std::cin.get();
}
Copy<br><br>
<br>字符串字面量是在双引号之间的字符
<br>#include &lt;iostream&gt;

int main()
{
	using namespace std::string_literals;

	std::string name0 = "Cherno"s + "hello";
	std::wstring name0 = L"Cherno"s + L"hello";
	std::u32string name0 = U"Cherno"s + U"hello";

	const char* example = R"(Line1
Line2
Line3
Line4)";

	const char* ex = "Line1\n"
		"Line2\n"
		"Line3\n";

	const char* name = "Cherno";
	// name[2] = 'a'; // 不可以，实际上指针指向了字符串字面量的位置，但字符串字面量存储在内存的只读部分不可以修改
	const wchar_t* name2 = L"Cherno"; //表示字符串字面量是由宽字符组成的，wchar_t 的大小是由编译器决定的

	// C++11引入的新类型
	const char16_t* name3 = u"Cherno";
	const char32_t* name4 = U"Cherno";

	std::cin.get();
}
Copy<br><br>
<br>const 像一个假关键字，因为在生成代码时并没有做什么
<br>与类和结构体成员的可见性相似，是对开发人员的限制，可以简化代码
<br>const 即开发人员做出承诺某些东西是不会改动的，但可以绕过
<br>#include &lt;iostream&gt;

class Entity
{
private:
	int m_X, m_Y;
	int* p_X, p_Y; // p_Y 仍然是 int 类型
	// int *p_X, *p_Y;
	mutable int var;
public:
	int GetX() const // 用在方法之后，表示这个方法不会修改任何实际的类，这是一个只读的方法
	{
		var = 2; // mutable 的变量在 const 方法中仍然可以被修改
		// m_X = 2;     // 不行
		return m_X;
	}

	int GetX() // 所以在类中有可能存在同一个函数的两个版本
	{

	}

	const int* const GetpX() const // 返回了一个不能修改的指针，指针指向的内存也不能被修改，也不会修改 Entity 类
	{

	}

	void SetX(int x)
	{

	}
};

void PrintEntity(const Entity&amp; e) {
	e = Entity(); // 不可以改变 e 的内容
	// 不仅不可以直接修改，通过方法间接修改也是不允许的
	std::cout &lt;&lt; e.GetX() &lt;&lt; std::endl; // 移除 GetX 后的 const 则该方法不能被调用，因为不能保证 GetX 不改变 e 的内容
}

int main()
{
	const int MAX_AGE = 90;

	int* a = new int;
	*a = 2;                // 不使用 const 可以做两件事，这里可以改变指针指向内存的内容
	a = (int *)&amp;MAX_AGE;   // 也可以改变指针指向的内存地址

	const int* b = new int;
	// int const* b = new int;
	*b = 2;                // 在指针之前加上 const 以后无法修改内存位置的数据
	b = (int *)&amp;MAX_AGE;   // 但是可以改变指针的地址

	int* const c = new int;
	*c = 2;                // 但是可以修改指向地址的内容
	c = (int*)&amp;MAX_AGE;    // 在指针之后加上 const 无法修改指针指向的地址
	c = nullptr;           // 不可以

	std::cin.get();
}
Copy<br><br>
<br>与 const 一起使用
<br>在 lambda 中使用
<br>#include &lt;iostream&gt;

class Entity
{
private:
	std::string m_Name;
	mutable int m_DebugCount;

public:
	const std::string &amp;GetName() const
	{
		m_DebugCount++;
		return m_Name;
	}
};

int main()
{
	const Entity e;
	e.GetName();

	int x = 8;
	auto f = [=]() mutable // &amp;x引用传递 x值传递 &amp;所有变量引用传递 =所有变量值传递
	{
		x++; // 不使用 mutable 会报错

		int y = x;
		y++;		//和使用 mutable 的结果是相同的，使用 mutable 简洁一些
		std::cout &lt;&lt; x &lt;&lt; std::endl;
	};

	f();
	//x = 8

	std::cin.get();
}
Copy<br><br>#include &lt;iostream&gt;

class Example
{
public:
	Example()
	{
		std::cout &lt;&lt; "Created Entity!" &lt;&lt; std::endl;
	}
	Example(int x)
	{
		std::cout &lt;&lt; "Created Entity with " &lt;&lt; x &lt;&lt; "!" &lt;&lt; std::endl;
	}
};

class Entity
{
private:
	std::string m_Name;
	Example m_Example;

public:
	Entity() : m_Name("Unknown") // 尽量保持初始化列表和成员变量的声明顺序相同
	{
		// m_Name = "Unknown"; // 如果写在函数中字符串对象会被构造两次，造成性能浪费
		m_Example = Example(8);
	}

	Entity(const std::string &amp;name) : m_Name(name)
	{
	}

	const std::string &amp;GetName() const { return m_Name; }
};

int main()
{
	Entity e;
	std::cin.get();
}
Copy<br>(base) ➜  Dev ./a.out        
Created Entity!
Created Entity with 8!
Copy<br><br>
<br>三元运算符只是 if 语句的语法糖
<br>#include &lt;iostream&gt;

static int s_Level = 1;
static int s_Speed = 2;

int main()
{
	s_Speed = s_Level &gt; 5 ? 10 : 5;
	s_Speed = s_Level &gt; 5 ? s_Level &gt; 10 ? 15 : 10 : 5;

	std::string rank = s_Level &gt; 10 ? "Master" : "Beginner"; // 没有构建中间字符串的原因和返回值优化有关

	std::cin.get();
}
Copy<br><br>
<br>栈对象的生命周期是由声明的地方的作用域决定的，如果超出作用域，对象的内存会被释放
<br>在堆上创建的对象会在程序运行过程中一直存在直到被手动释放
<br>#include &lt;iostream&gt;

using String = std::string;

class Entity
{
private:
	String m_Name;
public:
	Entity() : m_Name("Unknown") {}
	Entity(const String&amp; name) : m_Name(name) {}

	const String&amp; GetName() const {return m_Name;}

};

int main()
{
	Entity* e;
	{
		Entity entity("Cherno");
		e = &amp;entity;
		std::cout &lt;&lt; entity.GetName() &lt;&lt; std::endl;
	}                   // 跳出作用域时 entity 被销毁了，e 变成了野指针
	std::cin.get();
}
Copy<br>
<br>如果想让 entity 离开作用域就需要把它分配到堆上
<br>如果有很多的 Entity 栈空间可能太小不足以分配，不得不在堆上分配
<br>在堆上创建的对象需要手动释放，如果忘记 delete 就会造成内存泄露，所以也可以使用智能指针，在指针超出作用域时，对象会被自动删除，或者使用共享指针，如果没有指向他的引用时也会被自动删除
<br>如果对象非常大或需要显示控制对象的生命周差就需要在堆上分配
<br><br>
<br>new 的主要目的是在堆上分配内存，根据所写的类型以字节为单位决定要分配内存的大小
<br>使用 new 分配空间，不仅分配了空间，还调用了构造函数
<br>new 只是一个操作符，通常使用 new 会调用底层的 C 函数 malloc
<br>#include &lt;iostream&gt;

using String = std::string;

class Entity
{
private:
	String m_Name;
public:
	Entity() : m_Name("Unknown") {}
	Entity(const String&amp; name) : m_Name(name) {}

	const String&amp; GetName() const {return m_Name;}

};

int main()
{
	int a = 2;
	int* b = new int[50]; // 200B

	Entity* e = new(b) Entity(); // placement new
	Entity* e = new Entity();
	// Entity* e = (Entity*)malloc(sizeof(Entity)); // 两者的区别是 new 还调用了构造函数

	delete e;
	delete[] b;
	
	std::cin.get();
	delete e;
}
Copy<br><br>
<br>C++允许编译器对代码进行一次隐式的转换
<br>使用 explicit 关键字后需要显式调用构造函数, 写低级封装时会派上用场，防止偶然转换或导致性能问题 
<br>#include &lt;iostream&gt;

using String = std::string;

class Entity
{
private:
	String m_Name;
	int m_Age;
public:
	Entity(const String&amp; name) : m_Name(name), m_Age(-1) {}
	explicit Entity(int age) : m_Name("Unknown"), m_Age(age) {}

	const String&amp; GetName() const {return m_Name;}

};

void PrintEntity(const Entity&amp; entity) {

}

int main()
{
	PrintEntity(22); // 构造函数加上 explicit 无法隐式转换 
	PrintEntity(Entity(22));
	//PrintEntity("Cherno"); //不可以工作，因为 Cherno 的类型是 const char*，并不是 std::string 类型，C++需要做两次隐式转换，是不符合要求的
	PrintEntity(String("Cherno"));
	PrintEntity(Entity("Cherno"));


	Entity a = String("Cherno");
	Entity b = 22; // 将 int 隐式转换为了 Entity，加上 explicit 关键字后无法隐式转换
	Entity b(22);
	Entity b = Entity(22);
	
	std::cin.get();
}
Copy<br><br>
<br>操作符是代替函数执行某些事情的符号
<br>操作符重载指给操作符一个新的含义，定义或更改一个操作符的行为
<br>当操作符重载非常有意义时才使用
<br>#include &lt;iostream&gt;

struct Vector2
{
	float x, y;

	Vector2(float x, float y) : x(x), y(y) {
	}

	Vector2 Add(const Vector2&amp; other) const {
		// return *this + other;
		// return operator+(other); // 像函数一样调用
		return Vector2(x + other.x, y + other.y);
	}

	Vector2 operator+(const Vector2&amp; other) const {
		return Add(other);
	}

	Vector2 Multiply(const Vector2&amp; other) const {
		return Vector2(x * other.x, y * other.y);
	}

	Vector2 operator*(const Vector2&amp; other) const {
		return Multiply(other);
	}

	bool operator==(const Vector2&amp; other) const {
		return x == other.x &amp;&amp; y == other.y;
	}

	bool operator!=(const Vector2&amp; other) const {
		return !(*this == other);
		// return !operator==(other);
	}
};

// 要重载操作符的原始定义
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Vector2&amp; other) {
	stream &lt;&lt; other.x &lt;&lt; ", " &lt;&lt; other.y;
	return stream;
}

int main()
{
	Vector2 position(4.0f, 4.0f);
	Vector2 speed(0.5f, 1.5f);
	Vector2 powerup(1.1f, 1.1f);

	Vector2 result2 = position + speed * powerup;

	std::cout &lt;&lt; result2 &lt;&lt; std::endl;
	std::cin.get();
}
Copy<br><br>
<br>this 是函数所属当前对象实例的指针
<br>#include &lt;iostream&gt;

class Entity
{
public:
	int x, y;

	Entity(int x, int y);

	int GetX() const // 不能修改这个类，所以需要在 Entity* 前加上 const
	{
		const Entity *e = this;
		return x;
	}

	const Entity* const SoManyConst(const Entity* const &amp; e) const
	{
	}
};

void PrintEntity(const Entity&amp; e);

Entity::Entity(int x, int y)
{
	// Entity *const e = this; // const 在右边意味着不能改变 e 的指向
	// this = nullptr 不可以
	// Entity*&amp; const e = this;
	// [const] (常量引用) [Entity* const] (引用类型)
	// const Entity *const &amp;e = this; // 指向 Entity 对象的常量指针的引用，不能改变
	this-&gt;x = x;
	this-&gt;y = y;
	PrintEntity(*this);
}

void PrintEntity(const Entity&amp; e)
{
	// ...
}

int main()
{
	std::cin.get();
}
Copy<br><br>
<br>C++每次进入一个作用域时实际上是在 push 栈帧
<br>作用域可以是类作用域，函数作用域，if / for /while 作用域等等
<br>在栈上创建的变量如果离开作用域这个变量就不存在了
<br>#include &lt;iostream&gt;

class Entity
{
public:
	Entity()
	{
		std::cout &lt;&lt; "Created Entity!" &lt;&lt; std::endl;
	}

	~Entity()
	{
		std::cout &lt;&lt; "Destroyed Entity!" &lt;&lt; std::endl;
	}
};

class ScopedPtr
{
private:
	Entity* m_Ptr;
public:
	ScopedPtr(Entity* ptr)
		: m_Ptr(ptr)
	{

	}

	~ScopedPtr()
	{
		delete m_Ptr;
	}
};

int main()
{
	{
		ScopedPtr e = new Entity(); // e 超出作用域后调用析构函数在堆上分配的 Entity() 也被销毁了
	}
	std::cin.get();
}
Copy<br><br>
<br>使用智能指针的情况下当调用 new 时不用调用 delete 
<br>unique_ptr 作用域指针，当指针超出作用域时就会被销毁，同时不能拷贝一个作用域指针，因为它是 unique ，不会产生野指针
<br>unique_ptr 只是一个栈分配对象，当栈分配对象死亡时，会调用 delete 删除对象
<br>shared_ptr 的实现方式取决于编译器和编译器中的标准库，但是几乎在所有系统中都使用引用计数来实现
<br>引用计数 (reference counting) 是一种跟踪统计指针有多少引用的方法，如果计数为 0 那就会被删除
<br>weak_ptr 不增加 shared_ptr 的引用计数
<br>按照先 unique_ptr 后 shared_ptr 的顺序来考虑
<br>#include &lt;iostream&gt;
#include &lt;memory&gt;oo

class Entity
{
public:
	Entity()
	{
		std::cout &lt;&lt; "Created Entity!" &lt;&lt; std::endl;
	}

	~Entity()
	{
		std::cout &lt;&lt; "Destroyed Entity!" &lt;&lt; std::endl;
	}

	void Print() {}
};

int main()
{

	{
		std::shared_ptr&lt;Entity&gt; e0;
		{
			// std::unique_ptr&lt;Entity&gt; entity = new Entity();  unique_ptr 的构造函数是 explicit 的
			// std::unique_ptr&lt;Entity&gt; entity(new Entity());  显式调用构造函数
			std::unique_ptr&lt;Entity&gt; entity = std::make_unique&lt;Entity&gt;(); // 出于异常安全考虑，在构造函数抛出异常时更加安全，不会得到一个没有引用的空指针导致内存泄露
			std::shared_ptr&lt;Entity&gt; sharedEntity = std::make_shared&lt;Entity&gt;(); // shared_ptr 会额外分配一块内存用于存储引用计数，如何先构造一个对象再进行隐式转换会造成两次内存分配
			// std::shared_ptr&lt;Entity&gt; e0 = sharedEntity;  当然 shared_ptr 可以被复制
			e0 = sharedEntity;
			std::weak_ptr&lt;Entity&gt; weakEntity = sharedEntity; // 不会增加 shared_ptr 的引用计数，但是可以问 weak_ptr 是否过期
			entity-&gt;Print();
		}
	}
	std::cin.get();
}
Copy<br><br>
<br>复制指的是拷贝内存中的数据，从而在内存中拥有多个副本
<br>复制需要时间，要尽量避免不必要的复制
<br>除了引用外，当写下赋值运算符时，总是在复制不管是赋值地址还是其他值
<br>当试图创建一个新的变量并把另一个相同类型的变量赋值给它时，会调用拷贝构造函数
<br>C++默认提供的拷贝构造函数的作用是内存复制，将 other 对象的内存浅拷贝进成员变量，我们更想拷贝的是指针指向的内存
<br>总是通过 const 引用去传递对象，没有理由到处复制对象
<br>#include &lt;iostream&gt;
#include &lt;cstring&gt;

class String
{
private:
	char* m_Buffer;
	unsigned int m_Size;
public:
	String(const char* string)
	{
		m_Size = strlen(string);
		m_Buffer = new char[m_Size];
		memcpy(m_Buffer, string, m_Size);
		m_Buffer[m_Size] = 0;
	}

	~String()
	{
		delete[] m_Buffer;
	}

	// String(const String&amp; other) = delete;  不允许拷贝

	String(const String&amp; other)
		: m_Size(other.m_Size)
	{
		std::cout &lt;&lt; "Copied String!" &lt;&lt; std::endl;

		m_Buffer = new char[m_Size + 1];
		memcpy(m_Buffer, other.m_Buffer, m_Size + 1);
	}

	char&amp; operator[](unsigned int index)
	{
		return m_Buffer[index];
	}

	friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; string);

};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const String&amp; string)
{
	stream &lt;&lt; string.m_Buffer;
	return stream; 
}

void PrintString(const String&amp; string)
{
	String copy = string;
	std::cout &lt;&lt; string &lt;&lt; std::endl;
}

int main()
{
	String string = "Cherno";
	String second = string;  // 将成员变量拷贝到一块新的内存中，浅拷贝时只复制了指向字符串地址的指针，所以内存中的两个 String 具有相同的 char * 

	PrintString(string);
	PrintString(second);
	std::cin.get();			// 当到达程序末尾时 delete[] 被调用了两次，程序崩溃
}
Copy<br><br>
<br>有时可以重载箭头操作符让代码更简洁
<br>#include &lt;iostream&gt;
#include &lt;cstring&gt;

class Entity
{
public:
	void Print() const { std::cout &lt;&lt; "Hello!" &lt;&lt; std::endl; }
};

class ScopedPtr
{
private:
	Entity* m_Obj;
public:
	ScopedPtr(Entity* entity)
		: m_Obj(entity)
	{

	}

	~ScopedPtr()
	{
		delete m_Obj;
	}

	Entity* GetObject() { return m_Obj; }
	
	Entity* operator-&gt;()
	{
		return m_Obj;	
	}

	const Entity* operator-&gt;() const
	{
		return m_Obj;
	}
};

int main()
{
	// Entity* ptr = &amp;e;
	// Entity&amp; entity = *ptr;

	// ptr-&gt;Print(); // 只是一个快捷方式
	// entity.Print();
	// (*ptr).Print();

	const ScopedPtr entity = new Entity();
	// entity.GetObject()-&gt;Print(); // 这太麻烦了
	entity-&gt;Print();
	
	std::cin.get();
}
Copy<br>
<br>箭头操作符也可以用来找出变量在内存中的偏移量 (相对于类起始位置)
<br>#include &lt;iostream&gt;
#include &lt;cstring&gt;

struct Vector3
{
	float x, y, z;
};


int main()
{
	int offset = (int)&amp;((Vector3*)nullptr)-&gt;x;
	std::cout &lt;&lt; offset &lt;&lt; std::endl;
	std::cin.get();
}
Copy<br><br>
<br>标准模版库可以模版化任何东西，容器的底层数据类型由程序员决定，所有东西都由模版组成
<br>模版可以处理程序员提供的底层数据类型
<br>vector 更应该被称为 arraylist 动态数组，跟原始的 array 类型不同，vector 可以动态调整大小
<br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Vertex
{
	float x, y, z;
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Vertex&amp; vertex)
{
	stream &lt;&lt; vertex.x &lt;&lt; ", " &lt;&lt; vertex.y &lt;&lt; ", " &lt;&lt; vertex.z;
	return stream;
}

void Function(const std::vector&lt;Vertex&gt;&amp; vertices)
{

}

int main()
{
	/*
	应该存储堆分配的指针还是对象视情况而定，当然存储对象是理想的，
	因为动态数组的内存是连续分配的，如果要遍历、读取等更方便，但是如果要调整 vector 的大小时开销更大
	*/
	std::vector&lt;Vertex&gt; vertices; 
	vertices.push_back({ 1, 2, 3 }); // 列表初始化
	Function(vertices); // 确保通过引用传递
	vertices.push_back({ 4, 5, 6 });

	for (int i = 0; i &lt; vertices.size(); i++)
	{
		std::cout &lt;&lt; vertices[i] &lt;&lt; std::endl;
	}

	for (const Vertex&amp; v : vertices)
		std::cout &lt;&lt; v &lt;&lt; std::endl; // 如果直接使用变量实际上将每个 Vertex 都复制到了 v 中，所以使用引用可以得到相同的结果但没有拷贝过程

	vertices.erase(vertices.begin() + 1);
	vertices.clear();

	std::cin.get();
}
Copy<br><br>
<br>向 vector 中 push_back 元素时，如果 vector 不够大，需要分配新的内存，并将当前的内容复制到新内存的位置，然后释放旧位置的内存
<br>降低运行速度的原因是需要不断重新分配内存并复制元素，所以优化的方案是如何避免拷贝，需要知道拷贝是什么时候发生的
<br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

struct Vertex
{
	float x, y, z;

	Vertex(float x, float y, float z)
		: x(x), y(y), z(z)
	{

	}

	Vertex(const Vertex&amp; vertex)
		: x(vertex.x), y(vertex.y), z(vertex.z)
	{
		std::cout &lt;&lt; "Copied!" &lt;&lt; std::endl;
	}
};

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; stream, const Vertex&amp; vertex)
{
	stream &lt;&lt; vertex.x &lt;&lt; ", " &lt;&lt; vertex.y &lt;&lt; ", " &lt;&lt; vertex.z;
	return stream;
}

int main()
{
	std::vector&lt;Vertex&gt; vertices; 
	vertices.reserve(3); // 确保拥有足够的内存 优化策略2
	// 创建 vertex 时实际上是在主函数的栈帧上创建(main)，所以 push 时需要将 Vertex 拷贝到 vector 分配的内存中
	/*
	优化策略1：在适当的位置构造 Vertex ，在 vector 分配的内存中
	优化策略2：如果了解环境，直接告诉 vector 不用再调整大小
	*/
	vertices.emplace_back(1, 2, 3); // 仅传递了构造函数的参数列表
	vertices.push_back(Vertex(4, 5, 6)); // 每次 push 一个元素，vertices 的 capacity 就增加 1
	vertices.push_back(Vertex(7, 8, 9));

	std::cin.get();
}
Copy<br><br>
<br>在实际的解决方案的文件夹中，最好保留使用的库的版本
<br>有条件的情况下最好是实际构建源代码，将其编译为静态或动态库，如果没有库的源码，链接二进制文件可能是比较好的选择
<br>使用的是 32 位还是 64 位的库取决于目标应用程序的架构
<br>C++ 库通常由两部分包含目录 (includes) 和库目录 (library) ，include 目录中存放需要使用的头文件，lib 目录中有预构建的二进制文件，通常有静态库和动态库
<br>静态链接会将库放入可执行文件，动态链接库在程序运行时被链接
<br>使用库的时候需要包含头文件，同时将链接器指向库文件
<br>引号包含头文件会先检查相对路径，再去检查编译器的 include 路径
<br>cpp 中使用 c 语言库需要使用 extern "C"
<br><br>
<br>静态链接在编译时发生，动态链接在运行时发生，静态链接和动态链接存在性能差异，静态链接允许更多优化发生
<br>动态库具有静态的动态库版本，即应用程序已经知道动态库中存在什么函数，或可以使用什么函数，另一种是任意加载这个动态库，但不知道里面有什么
<br>头文件同时支持动态链接和动态链接
<br>Windows 使用动态链接库可以将 dll 文件放在可执行程序的同一目录下
<br><br>
<br>Cherno 如果包含了 VS 解决方案外的东西 (完全与项目无关的外部依赖项) 会使用尖括号，如果是在解决方案中找到的会使用引号
<br><br>
<br>具有多返回值时可以通过参数传递而不使用返回值，最好在参数之前加上 out
<br>返回一个数组，但是使用 new 导致堆分配的发生，也可以返回 array 和 vector ，由于 array 在栈上创建而 vector 数据存储在堆中，所以 array 通常会更快
<br>使用 tuple 或 pair，tuple 是一个包括多个变量的类但是不关心变量的类型
<br>使用结构体返回
<br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

struct RetString
{
	std::string string1;
	std::string string2;
};

std::tuple&lt;std::string, std::string&gt; RetMultStringWithTuple()
{
	std::string string1("Hello");
	std::string string2("Hello");

	return std::make_pair(string1, string2);
}

std::pair&lt;std::string, std::string&gt; RetMultStringWithPair()
{
	std::string string1("Hello");
	std::string string2("Hello");

	return std::make_pair(string1, string2);
}

RetString RetMultStringWithStruct()
{
	std::string string1("Hello");
	std::string string2("Hello");

	return { string1, string2 }; 
}

int main()
{
	// std::tuple&lt;std::string, std::string&gt; sources = RetMultString();
	auto sources = RetMultStringWithTuple();
	std::string string1 = std::get&lt;0&gt;(sources);

	auto sources_pair = RetMultStringWithPair();
	std::string string2 = sources_pair.second; // 但是将返回值传入新函数时容易搞混每个变量分别是什么

	auto sources_struct = RetMultStringWithStruct();
	std::string string3 = sources_struct.string1;

	std::cin.get();
}
Copy<br><br>
<br>模版和宏有点类似，但模版被 evaluate 的时间更晚
<br>模版允许定义一个根据用途进行编译的模版，基于提供给编译器的规则让编译器写代码
<br>#include &lt;iostream&gt;

/*
三个函数的不同是输入参数，实际上定义了三个 Print 的重载函数
*/
// void Print(int value)
// {
// 	std::cout &lt;&lt; value &lt;&lt; std::endl;
// }

// void Print(std::string value)
// {
// 	std::cout &lt;&lt; value &lt;&lt; std::endl;
// }

// void Print(float value)
// {
// 	std::cout &lt;&lt; value &lt;&lt; std::endl;
// }

/*
在被调用时函数才被创建
*/
template &lt;typename T&gt; // &lt;&gt;中的是模版参数，类型为 typename / class ，名称是 T
void Print(T value) // 当调用函数时传入的参数就时模版中的参数类型，Print方法只是一个模版，当被调用时模版才真正被创建
{
	std::cout &lt;&lt; value &lt;&lt; std::endl;
}

void Print(int value) // 被调用时相当于进行了填空，在模版实例化阶段被创建
{
	std::cout &lt;&lt; value &lt;&lt; std::endl;
}

template &lt;typename T&gt;
void Printerr(T value) // 不调用函数，编译不会报错 (由编译器决定)
{
	std::cout &lt;&lt; val &lt;&lt; std::endl;
}

int main()
{
	Print(5);  // 根据传递参数的不同，函数被创建并作为源代码被编译
	Print("Hello"); // 自动根据传递的参数类型进行推导
	Print(5.5f);
	
	Print&lt;int&gt;(5); // 显式指定类型
	Print&lt;std::string&gt;("Hello");
	std::cin.get();
}
Copy<br>
<br>模版也可以使用在类上
<br>#include &lt;iostream&gt;

template&lt;typename T, int N&gt;
class Array
{
private:
	T m_Array[N]; // 栈分配的数组所以在编译的时候就必须知道大小
public:
	int GetSize() const { return N; }
};

int main()
{
	Array&lt;int, 5&gt; array;
	Array&lt;std::string, 50&gt; array;

	std::cin.get();
}
Copy<br>
<br>当模版变的越来越复杂时，需要花很多时间搞清楚哪些东西被编译了，所以要适度使用模版
<br><br>
<br>new 关键字实际上调用了 malloc 函数，随后调用操作系统底层的函数在堆上分配内存，程序维护一个空闲列表，使用 malloc 时程序浏览空闲列表找到空闲内存返回一个指针
<br>使用堆容易出现缓存不命中
<br>#include &lt;iostream&gt;

struct Vector3
{
	float x, y, z;
	Vector3()
		: x(10), y(11), z(12)
	{

	}
};

int main()
{
	int value = 5;
	int array[5];
	array[0] = 1;
	array[1] = 2;
	array[2] = 3;
	array[3] = 4;
	array[4] = 5;
	int* hvalue = new int;
	*hvalue = 5;
	int* harray = new int[5];
	harray[0] = 1;
	harray[1] = 2;
	harray[2] = 3;
	harray[3] = 4;
	harray[4] = 5;

	Vector3* hvector = new Vector3();

	delete hvalue;
	delete[] harray;
	delete hvector;

	std::cin.get();
}
Copy<br><br>
<br>使用预处理器实现自动化
<br>预处理阶段实际上是文本编辑的阶段，可以控制输入给编译器的文本
<br>使用宏可以将代码中的文本替换为其他东西，就像遍历代码执行查找和替换
<br>#include &lt;iostream&gt;

#define OPEN_CURLY {

int main()
OPEN_CURLY	
	std::cin.get();
}
Copy<br>#include &lt;iostream&gt;

#define PR_DEBUG 1 

#if PR_DEBUG == 1 // 如果仅仅判断是否定义了一个 value，如果要修改的话只能注释或者删除先前的定义，取值的话比较可控
#define LOG(x) std::cout &lt;&lt; x &lt;&lt; std::endl
#elif defined(PR_RELEASE)
#define LOG(x)
#endif

#define MAIN int main() \ // 宏定义可以用反斜杠(Enter 的转义)包含多行，不能 \[space] 会被作为空格的转义
{\
	std::cin.get();\
}

#if 0 // if 可以将整块代码禁用
void Print()
{

}
#endif

int main()
{
	LOG("Hello");
	std::cin.get();
}
Copy<br><br>
<br>使用 auto 可以让 C++ 自动推导出数据类型，不管是创建、初始化还是赋值时
<br>如果类型非常长使用 auto 能够简化代码，或者进入复杂的代码集包含了模版等，不得不使用 auto
<br>auto 也可以用于后置返回类型
<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;unordered_map&gt;

auto GetName() -&gt; char* // 后置返回类型
{

}

char* GetName() // 如果将 std::string 改为 char * 在 main 函数中使用 auto 就不用重复修改了
{
	return "Cherno";
}

class Device {};

class DeviceManager
{
private:
	std::unordered_map&lt;std::string, std::vector&lt;Device *&gt;&gt; m_Devices;
public:
	const std::unordered_map&lt;std::string, std::vector&lt;Device *&gt;&gt;&amp; GetDevices() const
	{
		return m_Devices;
	}
	
};

int main()
{
	int a = 5;
	auto b = a;

	std::cout &lt;&lt; b &lt;&lt; std::endl;

	/*
	如果改变 api 客户端不用做出任何改变，但是我也不知道返回值改变了，
	导致原来返回类型的一些方法可能无法使用，并破坏依赖于特定类型的代码
	所以是有两面性的
	*/
	auto name = GetName(); 
	std::string name1 = GetName();

	// name.size(); 不可以
	name1.size();

	std::vector&lt;std::string&gt; strings;
	strings.push_back("Apple");
	strings.push_back("Orange");

	// for (std::vector&lt;std::string&gt;::iterator it = strings.begin();
	// 		it != strings.end(); it++)
	// {
	// 	std::cout &lt;&lt; *it &lt;&lt; std::endl;
	// }

	for (auto it = strings.begin();
			it != strings.end(); it++)
	{
		std::cout &lt;&lt; *it &lt;&lt; std::endl;
	}

	using DeviceMap = std::unordered_map&lt;std::string. std::vector&lt;Device*&gt;&gt;;
	DeviceManager dm;
	const DeviceMap&amp;
		devices = dm.GetDevices();

	const auto&amp; devices_auto = dm.GetDevices();
	auto d =dm.GetDevices(); // 增加一次拷贝。返回引用时要给 auto 加上引用符号
	std::cin.get();
}
Copy<br><br>
<br>处理静态数组的类，不能改变大小
<br>std::array 有可选的边界检查
<br>size() 返回的类型是 constexpr 说明 size() 方法返回的就是一个数值
<br>      // Capacity.
      [[__nodiscard__, __gnu__::__const__, __gnu__::__always_inline__]]
      constexpr size_type
      size() const noexcept { return _Nm; }
Copy<br>#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;algorithm&gt;

void PrintArray(const std::array&lt;int, 5&gt;&amp;  data)
{
	
}

int main()
{

	std::array&lt;int, 5&gt; data;
	data.size();
	std::sort(data.begin(), data.end());
	data[0] = 2;
	data[4] = 1;

	std::cin.get();
}
Copy<br><br>
<br>函数指针是将一个函数赋值给一个变量的方法
<br>通过函数指针可以将函数赋值给一个变量，也可以将函数作为参数传递给其他函数
<br>在可执行文件中找到函数指令的内存地址
<br>#include &lt;iostream&gt;

void HelloWorld(int a)
{
	std::cout &lt;&lt; "Hello World! Value: " &lt;&lt; a &lt;&lt; std::endl;
}

int main()
{
	void(*chris)(int) = HelloWorld;

	auto chris = HelloWorld; // 函数只是 cpu 指令

	typedef void(*HelloWorldFunction)(int);
	HelloWorldFunction function = HelloWorld;

	function(8);

	std::cin.get();
}
Copy<br>#include &lt;iostream&gt;
#include &lt;vector&gt;

void PrintValue(int value)
{
	std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;
}

void ForEach(const std::vector&lt;int&gt;&amp; values, void(*func)(int))
{
	for (int value : values)
		func(value);
}

int main()
{
	std::vector&lt;int&gt; values = { 1, 5, 4, 2, 3 };
	ForEach(values, PrintValue);
	ForEach(values, [](int value){std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;}); // [] 捕获模式

	std::cin.get();
}
Copy<br><br>
<br>只要有函数指针就可以在 C++ 中使用 lambda
<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;
#include &lt;algorithm&gt;

void PrintValue(int value)
{
	std::cout &lt;&lt; "Value: " &lt;&lt; value &lt;&lt; std::endl;
}

void ForEach(const std::vector&lt;int&gt;&amp; values, const std::function&lt;void(int)&gt;&amp; func)
{
	for (int value : values)
		func(value);
}

int main()
{
	std::vector&lt;int&gt; values = { 1, 5, 4, 2, 3 };
	auto it = std::find_if(values.begin(), values.end(), [](int value){ return value &gt; 3; });
	std::cout &lt;&lt; *it &lt;&lt; std::endl;

	ForEach(values, PrintValue);

	int a = 5;
	auto lambda = [=](int value) mutable { a = 5; std::cout &lt;&lt; "Value: " &lt;&lt; a &lt;&lt; std::endl; };

	ForEach(values, lambda); // [] 捕获模式

	std::cin.get();
}
Copy<br><br>
<br>如果需要使用就尽量在较小的作用域下使用
<br>#include &lt;iostream&gt;
#include &lt;string&gt;

namespace apple {
	void print(const std::string&amp; text)
	{
		std::cout &lt;&lt; text &lt;&lt; std::endl;
	}
}

namespace orange {
	void print(const char* text)
	{
		std::string temp = text;
		std::reverse(temp.begin(), temp.end());
		std::cout &lt;&lt; temp &lt;&lt; std::endl;
	}
}

using namespace apple;
using namespace orange;

int main()
{
	print("Hello"); // 不使用 orange 命名空间时实际发生了隐式转换，当使用 orange 其提供的 print函数 更加匹配
	// 所以不要用 using namespace

	std::cin.get();
}
Copy<br><br>
<br>名称空间的作用是防止名称冲突
<br>类本身也是一个名称空间
<br>#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;

namespace apple {
	void print(const char* text)
	{
		std::cout &lt;&lt; text &lt;&lt; std::endl;
	}

	void print_again()
	{

	}
}

namespace orange {
	void print(const char* text)
	{
		std::string temp = text;
		std::reverse(temp.begin(), temp.end());
		std::cout &lt;&lt; temp &lt;&lt; std::endl;
	}
}

using namespace apple;
using namespace orange;

int main()
{
	using apple::print; // 如果仅仅想使用命名空间中的特定方法可以这么写
	namespace a = apple; // 当然命名空间可以嵌套 namespace a = apple::function ...

	print("Hello"); // C语言没有名称空间，所以不得不将库的名字放在 symbol 之前
	a::print("Hello");
	apple::print_again(); 

	std::cin.get();
}
Copy<br><br>#include &lt;iostream&gt;
#include &lt;thread&gt;

static bool s_Finished = false;

void DoWork()
{	
	using namespace std::literals::chrono_literals;

	std::cout &lt;&lt; "Started thread id =" &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;

	while (!s_Finished)
	{
		std::cout &lt;&lt; "Working...\n";
		std::this_thread::sleep_for(1s);
	}
}

int main()
{
	std::thread worker(DoWork);

	std::cin.get();
	s_Finished = true;

	worker.join(); // 在主线程上等待工作进程完成所有的执行后，再继续执行主线程

	std::cout &lt;&lt; "Finished." &lt;&lt; std::endl;
	
	std::cin.get();
}
Copy<br><br>
<br>如果需要高精确度的计时需要使用操作系统库
<br>#include &lt;iostream&gt;
#include &lt;chrono&gt;
#include &lt;thread&gt;

struct Timer
{
	std::chrono::_V2::system_clock::time_point start, end;
	std::chrono::duration&lt;float&gt; duration;

	Timer()
	{
		start = std::chrono::high_resolution_clock::now();
	}

	~Timer()
	{
		end = std::chrono::high_resolution_clock::now();
		duration = end - start;

		float ms = duration.count() * 1000.0f;
		std::cout &lt;&lt; "Timer took " &lt;&lt; ms &lt;&lt; "ms " &lt;&lt; std::endl; 
	}
};

void Function()
{
	Timer timer;
	for (int i = 0; i &lt; 100; i++)
		std::cout &lt;&lt; "Hello" &lt;&lt; std::endl; // io 多程序更慢
}

int main()
{
	using namespace std::literals::chrono_literals;

	Function();

	auto start = std::chrono::high_resolution_clock::now();

	std::this_thread::sleep_for(1s);
	
	
	auto end = std::chrono::high_resolution_clock::now();
	std::chrono::duration&lt;float&gt; duration = end - start;
	std::cout &lt;&lt; duration.count() &lt;&lt; "s" &lt;&lt; std::endl;
	
	std::cin.get();
}
Copy<br><br>#include &lt;iostream&gt;

int main()
{
	int* array = new int[5];
	int** a2d = new int*[5];
	for (int i = 0; i &lt; 5; i++) // 会造成内存碎片的问题
		a2d[i] = new int [5];

	for (int i = 0; i &lt; 5; i++)
	{
		delete[] a2d[i];
	}

	delete[] a2d;

	int*** a3d = new int**[5];
	for (int i = 0; i &lt; 5; i++)
	{
		a3d[i] = new int*[5];
		for (int j = 0; j &lt; 5; j++)
			a3d[i][j] = new int[5];
	}

	a3d[0][0][0] = 0;

	int* array = new int[5 * 5];
	for (int y = 0; y &lt; 5; y++)
	{
		for (int x = 0; x &lt; 5; x++)
		{
			array[x + y * 5] = 2;
		}
	}

	std::cin.get();
}
Copy<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;

int main()
{
	std::vector&lt;int&gt; values = {3, 5, 1, 4, 2};
	std::sort(values.begin(), values.end()); // 会使用 operator&lt; 进行排序
	std::sort(values.begin(), values.end(), std::greater&lt;int&gt;()); // 使用标准库的函数进行排序
	std::sort(values.begin(), values.end(), [](int a, int b){
		if (a == 1)
			return false; // a 要排在后面
		if (b == 1)
			return true; // a 要排在前面 true 就是 a, b 这个顺序 false 交换一下
		return a &lt; b; // 如果 a &gt; b 返回 false 把 a 排在 b 后面
	});

	for(int value : values)
	{
		std::cout &lt;&lt; value &lt;&lt; std::endl;
	}

	std::cin.get();
}
Copy<br><br>
<br>比如如果有一个类，想把这个类解释为一段字节流
<br>把拥有的一段内存当作不同类型的内存来对待，将原始类型作为指针，并且将其转换为另一个指针
<br>#include &lt;iostream&gt;

struct Entity
{
	int x, y;

	int* GetPositions()
	{
		return &amp;x;
	}
};

int main()
{
	int a = 50;
	// double value = a;  实际上做了一次隐式转换，在内存中的另一个地方存储了 value

	double value = *(double*)&amp;a; // int 占 4 字节 double 占 8 字节
	// double&amp; value = *(double*)&amp;a; // dangerous
	std::cout &lt;&lt; value &lt;&lt; std::endl;

	Entity e = { 1, 2 }; // 结构体 2 * 4B 没有多余的空间，可以把这个结构体当作一个一维数组
	int* position = (int *)&amp;e;

	int y = *(int*)((char*)&amp;e + 4);

	std::cout &lt;&lt; position[0] &lt;&lt; ", " &lt;&lt; position[1] &lt;&lt; std::endl;
	std::cout &lt;&lt; y &lt;&lt; std::endl;

	std::cin.get();
}
Copy<br><br>
<br>联合体只能拥有一个成员
<br>#include &lt;iostream&gt;

struct Vector2
{
	float x, y;
};

struct Vector4
{
	union
	{
		struct
		{
			float x, y, z, w;
		};
		struct
		{
			Vector2 a, b;
		};
	};

	// Vector2&amp; GetA()
	// {
	// 	return *(Vector2*)&amp;x;
	// }
};

void PrintVector2(const Vector2&amp; vector)
{
	std::cout &lt;&lt; vector.x &lt;&lt; ", " &lt;&lt; vector.y &lt;&lt; std::endl;
}

int main()
{
	struct Union
	{
		union
		{
			float a;
			int b;
		};
	};

	Union u;
	u.a = 2.0f;
	std::cout &lt;&lt; u.a &lt;&lt; ", " &lt;&lt; u.b &lt;&lt; std::endl;

	Vector4 vector = { 1.0f, 2.0f, 3.0f, 4.0f };
	vector.x = 2.0f;
	PrintVector2(vector.a);

	std::cin.get();
}
Copy<br><br>
<br>如果有一个类 A ，类 B 派生于类 A，想把类 B 引用为类 A，但是实际上是类 B ，然后决定删除 A 或者 A 以某种方式被删除了，但是还是希望运行 B 的析构函数，而不是运行 A 的析构函数
<br>只要允许一个类拥有子类，就需要声明析构函数为虚函数，否则无法安全地扩展这个类
<br>#include &lt;iostream&gt;

class Base
{
public:
	Base()
	{
		std::cout &lt;&lt; "Base Constructor\n";
	}
	virtual ~Base()
	{
		std::cout &lt;&lt; "Base Destructor\n";
	}
};

class Derived : public Base
{
public:
	Derived()
	{
		m_Array = new int[5];
		std::cout &lt;&lt; "Derived Constructor\n";
	}
	~Derived()
	{
		delete[] m_Array;
		std::cout &lt;&lt; "Derived Destructor\n";
	}

private:
	int *m_Array;
};

int main()
{
	Base *base = new Base();
	delete base;
	std::cout &lt;&lt; "---------------------\n";
	Derived *derived = new Derived();
	delete derived;

	/*
	Base Constructor
	Base Destructor
	---------------------
	Base Constructor
	Derived Constructor
	Derived Destructor
	Base Destructor
	*/

	std::cout &lt;&lt; "---------------------\n";
	Base *poly = new Derived();
	delete poly;

	/*
	---------------------
	Base Constructor
	Derived Constructor
	Base Destructor &lt;-- 内存泄漏
	*/

	/* 使用虚析构函数后
	---------------------
	Base Constructor
	Derived Constructor
	Derived Destructor
	Base Destructor
	*/

	std::cin.get();
}
Copy<br><br>
<br>显式类型转换有 C 风格的还有 C++ 风格的
<br>#include &lt;iostream&gt;

class Base
{
public:
	Base() { }
	virtual ~Base() { }
};

class Derived : public Base
{
public:
	Derived() { }
	~Derived() { }
};

class AnotherClass : public Base
{
public:
	AnotherClass() { }
	~AnotherClass() { }
};

int main()
{

	int a = 5;
	double value = a;

	double value = 5.25;
	double a = (int)value + 5.3; // C Style Cast

	double s = static_cast&lt;int&gt;(value) + 5.3; // C++ Style Cast Syntax Sugar 方便的地方可以更快地找到转换的位置，增加代码可读性

	double s_inv = static_cast&lt;Derived*&gt;(value); // 可以检查转换是否合法
	Derived* ss = reinterpret_cast&lt;Derived*&gt;(&amp;value); // 参考类型双关


	Derived* derived = new Derived();
	Base* base = derived;
	AnotherClass* ac = dynamic_cast&lt;AnotherClass*&gt;(base); // 做运行时检查，可以检查转换的派生类是否一致，不一致返回一个空指针
	Derived* ac = dynamic_cast&lt;AnotherClass*&gt;(base); // OK

	std::cin.get();
}
Copy<br><br>
<br>条件断点是设置一个断点，当满足特定条件时触发，操作断点允许遇到断点时进行某些操作
<br>有两种类型的操作断点，一种是输出需要的东西后继续执行，或者输出后仍然中断程序
<br><br>
<br>抓取一堆头文件，并转换成编译器可以使用的格式，不用一遍又一遍读取这些头文件
<br>例如每次包含 vector 头文件时，需要读取整个头文件并编译它，vector 还包含了一些头文件也需要被读取，所有的代码都需要被拷贝到编译单元中进行编译
<br>每次对源文件进行修改，整个文件都需要被重新编译
<br>当项目文件很多时，需要一遍又一遍地解析并编译同一个头文件，需要花费很多时间
<br>预编译头文件的作用是接收一堆头文件，只编译一次以二进制格式存储, 可以大大加速编译时间
<br>如果放入预编译头文件中的内容发生变化，需要重新构建预编译的头文件，会导致编译速度变慢
<br>预编译头文件可能会隐藏实际使用的库，阅读的时候会无法辨别需要什么依赖
<br><br>
<br>无论在测试什么，都要确保确实做了这个事情 (有可能有编译优化存在实际上程序并没有按照预想的方式执行)
<br>#include &lt;iostream&gt;

#include &lt;chrono&gt;

#include &lt;array&gt;
#include &lt;memory&gt;


class Timer
{
public:
	Timer()
	{
		m_StartTimepoint = std::chrono::high_resolution_clock::now();
	}

	~Timer()
	{
		Stop();
	}

	void Stop()
	{
		auto endTimepoint = std::chrono::high_resolution_clock::now();
		auto start = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(m_StartTimepoint).time_since_epoch().count();
		auto end = std::chrono::time_point_cast&lt;std::chrono::microseconds&gt;(endTimepoint).time_since_epoch().count();

		auto duration = end - start;
		double ms = duration * 0.001;

		std::cout &lt;&lt; duration &lt;&lt; "us (" &lt;&lt; ms &lt;&lt; "ms)\n";
	}
private:
	std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; m_StartTimepoint;

};

int main()
{
	int value = 0;
	{
		Timer timer;
		for (int i = 0; i &lt; 1000000; i++)
			value += 2;
	}

	std::cout &lt;&lt; value &lt;&lt; std::endl;

	struct Vector2
	{
		float x, y;
	};

	std::cout &lt;&lt; "Make Shared\n";

	{
		std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs;
		Timer timer;
		for (int i = 0; i &lt; sharedPtrs.size(); i++)
			sharedPtrs[i] = std::make_shared&lt;Vector2&gt;(); 
	}

	std::cout &lt;&lt; "New Shared\n";

	{
		std::array&lt;std::shared_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs;
		Timer timer;
		for (int i = 0; i &lt; sharedPtrs.size(); i++)
			sharedPtrs[i] = std::shared_ptr&lt;Vector2&gt;(new Vector2);
	}

	std::cout &lt;&lt; "Make Unique\n";

	{
		std::array&lt;std::unique_ptr&lt;Vector2&gt;, 1000&gt; sharedPtrs;
		Timer timer;
		for (int i = 0; i &lt; sharedPtrs.size(); i++)
			sharedPtrs[i] = std::make_unique&lt;Vector2&gt;();
	}
	__builtin_trap();
}
Copy<br>(base) ➜  Dev g++-13 main.cpp -o main
(base) ➜  Dev ./main
2215us (2.215ms)
2000000
Make Shared
77us (0.077ms)
New Shared
63us (0.063ms)
Make Unique
61us (0.061ms)
[1]    97000 trace trap  ./main
(base) ➜  Dev g++-13 -O2 main.cpp -o main
(base) ➜  Dev ./main                     
0us (0ms)
2000000
Make Shared
40us (0.04ms)
New Shared
119us (0.119ms)
Make Unique
46us (0.046ms)
[1]    97076 trace trap  ./main
Copy<br><br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

struct Person
{
	std::string Name;
	int Age;
};

std::tuple&lt;std::string, int&gt; CreatePerson()
{
	return { "Cherno", 24 };
}


int main()
{
	auto person = CreatePerson();
	std::string&amp; name = std::get&lt;0&gt;(person);
	int age = std::get&lt;1&gt;(person);

	std::string name;
	int age;
	std::tie(name, age) = CreatePerson();
}
Copy<br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;tuple&gt;

std::tuple&lt;std::string, int&gt; CreatePerson()
{
	return { "Cherno", 24 };
}

int main()
{
	auto[name, age] = CreatePerson();
	std::cout &lt;&lt; name &lt;&lt; std::endl;
}
Copy<br><br>#include &lt;iostream&gt;
#include &lt;fstream&gt;
#include &lt;optional&gt;


std::string ReadFileAsString(const std::string&amp; filepath)
{
	std::ifstream stream(filepath);
	if (stream)
	{
		std::string result;
		// read file
		stream.close();
		return result;
	}
	
	return std::string();
}

std::string ReadFileAsString2(const std::string&amp; filepath, bool&amp; outSuccess)
{
	std::ifstream stream(filepath);
	if (stream)
	{
		std::string result;
		// read file
		stream.close();
		outSuccess = true;
		return result;
	}
	
	outSuccess = false;
	return std::string();
}

std::optional&lt;std::string&gt; ReadFileAsString3(const std::string&amp; filepath)
{
	std::ifstream stream(filepath);
	if (stream)
	{
		std::string result;

		stream.close();
		return result;

	}
	return {};
}

int main()
{
	// bool fileOpenSuccessfully;
	// std::string data = ReadFileAsString2("data.txt", fileOpenSuccessfully);
	// if(fileOpenSuccessfully)
	// {

	// }

	std::optional&lt;std::string&gt; data = ReadFileAsString3("data.txt");

	std::string value = data.value_or("Not Present"); // 如果没有值就返回一个默认值
	std::cout &lt;&lt; value &lt;&lt; std::endl;
	if (data)
	{
		std::cout &lt;&lt; "File read successfully!\n";
	}
	else
	{
		std::cout &lt;&lt; "FIle could not be opened\n";
	}

	std::cin.get();
}
Copy<br><br>#include &lt;iostream&gt;
#include &lt;variant&gt;
#include &lt;optional&gt;

enum class ErrorCode
{
	None = 0, NotFound = 1, NoAccess = 2
};

std::variant&lt;std::string, ErrorCode&gt; ReadFileString()
{
	return {};
}

int main()
{
	std::variant&lt;std::string, int&gt; data;

	std::cout &lt;&lt; sizeof(int) &lt;&lt; "\n";
	std::cout &lt;&lt; sizeof(std::string) &lt;&lt; "\n";
	std::cout &lt;&lt; sizeof(data) &lt;&lt; "\n";

	data = "Cherno";
	std::cout &lt;&lt; std::get&lt;std::string&gt;(data) &lt;&lt; std::endl;
	if (auto value = std::get_if&lt;std::string&gt;(&amp;data))
	{
		std::string&amp; v = *value;		
	}
	

	data = 2;
	data.index(); // 1

	std::cout &lt;&lt; std::get&lt;std::string&gt;(data) &lt;&lt; std::endl;
	std::cout &lt;&lt; std::get&lt;int&gt;(data) &lt;&lt; std::endl;

	std::cin.get();
}
Copy<br><br>#include &lt;iostream&gt;
#include &lt;any&gt;
#include &lt;variant&gt;

struct CustomClass
{
	std::string s0, s1;
};

int main()
{
	std::any data; // 对于小类型 any 将变量存储为一个 Union，对于大类型，会使用大空间 void *，动态分配内存 
	data = 2;
	data = std::string("Cherno");
	data = CustomClass(); // 当超过 32 字节，会调用 new 动态分配内存

	std::string string = std::any_cast&lt;std::string&gt;(data);
	std::string&amp; string = std::any_cast&lt;std::string&amp;&gt;(data);

	std::cin.get();
}
Copy]]></description><link>campus/chinese-notes/计算机科学/计算机网络/c++-crash-course.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/C++ Crash Course.md</guid><pubDate>Wed, 27 Mar 2024 00:28:44 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231202214923.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231202214923.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[什么是因特网]]></title><description><![CDATA[ 
 <br><br>
<br>根据构成因特网的基本硬件和软件组件描述
<br>根据为分布式应用提供服务的互联网基础设施描述
<br>因特网是一个世界范围的计算机网络
<br><br><br>
<br>网络提供者与接收者
<br>计算设备类型：嵌入式设备、计算机···
<br>端系统通过通信链路和分组交换机连接到一起
<br><br>
<br>物理媒体构成

<br>同轴电缆 (Coaxial cable)<br>
<img alt="Pasted image 20231101104608.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101104608.png">
<br>双绞铜线 (末端常连接 (<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Registered_jack#RJ45S" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Registered_jack#RJ45S" target="_blank">RJ-45</a>) 等接口) <img alt="h300" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101104900.png"> <img alt="Pasted image 20231031154330.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031154330.png"> <img alt="Pasted image 20231031154345.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031154345.png">
<br>光纤：用于路由与路由之间的传输，抗干扰性好<img alt="Pasted image 20231101105041.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101105041.png">

<br>单模光纤：发生漫反射概率低，性能更高传输速率快
<br>多模光纤：价格低性价比高<br>
<img alt="Pasted image 20231101172100.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101172100.png" style="width: 500px; max-width: 100%;">


<br>无线电频谱


<br>传输速率(transmission rate)

<br>单位：bit/s or bps


<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Duplex_" rel="noopener" class="external-link" title="telecommunications" href="https://en.wikipedia.org/wiki/Duplex_" target="_blank">信号传输方式</a> (FROM: gpt-4-1106-preview)：

<br>单工 (Simplex)： 单工通信是一种单向通信方式，数据只能在一个方向上流动，无法实现双向交流。接收方不具备向发送方回传信息的能力。比如，电视和无线电广播就是单工通信的例子。观众只能接收信息，不能通过同样的频道向电视台或广播站发送信息 
<br>半双工 (Half-Duplex)： 半双工通信允许数据在两个方向上传输，但是在同一时刻只能有一个方向上的数据传输。换言之，通信设备在一段时间内只发送数据或只接收数据。这就像对讲机的工作方式，两个人不能同时说话，一个人说话时另一个人必须等待并听 <img alt="Pasted image 20231108105121.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108105121.png">  
<br>全双工 (Full-Duplex)： 全双工通信允许数据同时在两个方向上流动。在全双工模式下，发送和接收可以同时进行，比如，电话就是全双工通信的例子，双方可以同时进行对话，彼此的话语可以实时交叠并被听到 <img alt="Pasted image 20231108105132.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108105132.png"> ^86 d 918


<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Channel#Communications" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Channel#Communications" target="_blank">信道</a> (FROM: gpt-4-1106-preview)：信息从一个地点传输到另一个地点的路径，在不同的背景下，信道的定义略有不同

<br>无线通信信道：指电磁波在空气中的传播路径。在这个路径上可能存在各种衰减、散射、反射、折射和衍射现象，这些现象影响着信号的传输质量
<br>有线通信信道：指电信号在导线（如同轴电缆、双绞线等）或光信号在光纤中的传输路径
<br>数字通信信道：在数字通讯中，信道指的是传输比特序列的媒介，它可以是物理的，也可以是通过编码实现的逻辑信道


<br><br>
<br>⚠️如果对书中的分组 (packet)，报文(message)感到困惑，请看<a data-tooltip-position="top" aria-label="因特网 > ^23aa67" data-href="因特网#^23aa67" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^23aa67" class="internal-link" target="_self" rel="noopener">这里</a>和配图
<br>
<br>分组(packet)：发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包
<br>组成部分：

<br>路由器：路由器通常用于网络核心<br>
中
<br>链路层交换机：通常用于接入网中


<br><br>
<br>从发送端系统到接收端系统，一个分组经过的一系列通信链路和分组交换机
<br><br>
<br>端系统通过ISP接入互联网，ISP自身是一个由多台分组交换机和多段通信链路组成的网络，运行IP协议，为端系统提供了不同类型的网络接入，较低层ISP通过较高层ISP互联
<br>较高层ISP是通过高速光纤链路互联的高速路由器组成
<br>互联的ISP

<br>协议：控制因特网中信息的接收和发送，互联网主要协议统称为TCP/IP

<br>TCP(Transmission Control Protocol)：传输控制协议
<br>IP(Internet Protocol)：网际协议


<br>因特网标准：

<br>研发者：互联网工程任务组(Internet Engineering Task Force, IETF)
<br>IETF标准文档：请求评论(Request For Comment, RFC)，定义了TCP、IP、HTTP、SMTP等协议




<br><br><br>
<br>分布式应用程序(distributed application)：涉及多个相互交换数据的端系统
<br><a data-tooltip-position="top" aria-label="应用层 > 进程和计算机网络间的接口" data-href="应用层#进程和计算机网络间的接口" href="/campus/chinese-notes/计算机科学/计算机网络/应用层.html#进程和计算机网络间的接口" class="internal-link" target="_self" rel="noopener">套接字接口</a> (socket interface) ：规定了运行在一个端系统上的应用程序请求互联网基础设施向运行在另一个端系统上的特定目的地程序交付数据的方式，是一套发送程序必须遵循的规则集合
<br><br>
<br>协议定义了在两个或多个通信实体之间交换报文 (messages) 的格式和顺序，以及报文发送和/或接收一条报文或其他事件所采取的动作 (event) 
<br>Windows CMD 中的 ipconfig 命令显示了诸多协议和协议中定义的地址

以太网适配器 以太网:

连接特定的 DNS 后缀 . . . . . . . : localdomain
描述. . . . . . . . . . . . . . . : Parallels VirtIO Ethernet Adapter
物理地址. . . . . . . . . . . . . : 00-1C-42-93-74-7A
DHCP 已启用 . . . . . . . . . . . : 是
自动配置已启用. . . . . . . . . . : 是
IPv6 地址 . . . . . . . . . . . . : fdb2:2c26:f4e4:0:ddc:3de6:d7e:a5d1(首选)
临时 IPv6 地址. . . . . . . . . . : fdb2:2c26:f4e4:0:c432:6bdb:fd11:a161(首选)
本地链接 IPv6 地址. . . . . . . . : fe80::ddc:3de6:d7e:a5d1%12(首选)
IPv4 地址 . . . . . . . . . . . . : 10.211.55.4(首选)
子网掩码  . . . . . . . . . . . . : 255.255.255.0
获得租约的时间  . . . . . . . . . : Wednesday, September 14, 2022 9:07:05 AM
租约过期的时间  . . . . . . . . . : Wednesday, September 14, 2022 9:48:34 AM
默认网关. . . . . . . . . . . . . : 10.211.55.1
DHCP 服务器 . . . . . . . . . . . : 10.211.55.1
DHCPv6 IAID . . . . . . . . . . . : 100670530
DHCPv6 客户端 DUID  . . . . . . . : 00-01-00-01-2A-AB-CE-AD-00-1C-42-93-74-7A
DNS 服务器  . . . . . . . . . . . : 10.211.55.1
TCPIP 上的 NetBIOS  . . . . . . . : 已启用
Copy


<br><br><br>
<br>端系统也称主机
<br>主机(host)：客户(client)和服务器(server)
<br><br>
<br>将端系统连接到边缘路由器(edge router)的网络
<br>边缘路由器：端系统到任何其他远程端系统的路径上的第一台路由器
<br><br>
<br>家庭接入

<br>数字用户线接入 (Digital Subscriber Line)：利用电话公司现有的本地电话基础设施

<br>本地电话公司为 ISP，DSL 调制解调器使用现有的电话线与位于电话公司的本地中心局 (CO)中的数字用户线接入复用器 (DSLAM: Digital Subscriber Line Access Multiplexer)交换数据
<br>使用频分复用技术：现有电话0-4kHz 为电话，4-50kHz 为上行数据，50kHz-1MHz 为下行数据，上行速率与下行速率不对称


<br>电缆因特网接入 (cable Internet access)：利用有线电视公司现有的有线电视基础设施 

<br>采用了光纤和同轴电缆，通常被称为 HFC (Hybrid Fiber Coax)混合光纤同轴系统
<br>光缆将电缆头端连接到地区枢纽，再使用传统的同轴电缆到达家庭
<br>家庭端需要电缆调制解调器 (cable modem)，将 HFC 网络分为上下两个信道
<br>电缆头端有电缆调制解调器端接系统 (Cable Modem Termination System, CMTS)将模拟信号转换为数字信号 <img alt="cable-modem.jpeg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/cable-modem.jpeg">
<br>重要特征：共享广播媒体，需要分布式多路访问协议来协调传输和避免碰撞


<br>光纤到户 (Fiber to the Home, FTTH)

<br>直接光纤
<br>竞争性的光纤分布体系结构

<br>主动光纤网络 (Active Optical Network)：本质上是交换因特网
<br>被动光纤网络 (Passive Optical Network)


<br>光纤网络端接器 (Optical Network Terminator, ONT)
<br>光纤线路端接器 (Optical Line Terminator, OLT)
<br>光纤分配器 (splitter)：相当于电缆头端


<br>卫星接入
<br>拨号接入


<br>企业接入

<br>使用局域网(LAN)将端系统连接到边缘路由器
<br>有线LAN：以太网用户使用双绞铜线与以太网交换机相连
<br>无线LAN：无线用户从/到一个接入点(Access Point)发送/接收分组，接入点与企业网连接

<br>WIFI：基于IEEE802.11技术的无线LAN接入 
<br>现在许多家庭将宽带住宅接入(DSL或电缆调制解调器接入)和廉价无线局域网技术相结合，产生家庭网络




<br>广域无线接入

<br>3G：第三代无线技术
<br>LTE(Long-Term Evolution)


<br><br>
<br>物理媒体：用于传播电磁波和光脉冲的媒体
<br>导引性媒体(guided media)：电波沿着固定媒体前行

<br>双绞铜线：最便宜且最常用的导引型传输媒体

<br>无屏蔽双绞线(Unshielded Twisted Pair, UTP)常用于LAN中
<br>双绞线已成为高速LAN联网的主导性解决方案


<br>同轴电缆：两个同心的铜导体，能达到较高的数据传输速率

<br>能被用作导引性共享媒体


<br>光纤：信号衰减极低，难窃听，为长途导引性传输媒体

<br>广泛用于因特网主干
<br>光载波标准(Optical Carrier)链路速率：51.8Mbps～39.8Gbps




<br>非导引性媒体(unguided media)：电波在空气和外层空气中传播

<br>陆地无线电信道

<br>短距离
<br>局域：无线LAN技术
<br>广域：蜂窝接入技术


<br>卫星无线信道

<br>同步卫星(geostationary satellite)：信号传播时延较客、可观
<br>近地轨道卫星(Low-Earth Orbiting)




<br><br>由互联因特网端系统的分组交换机和链路构成的网状网络<br><br>
<br>在网络应用中端系统彼此交换报文(message)
<br>分组(packet)：源将长报文分成的较小数据块
<br>分组以等于该链路最大传输速率的传输速度通过通信链路
<br>细节

<br>存储转发传输(store-and-forward transmission):

<br>交换机向输出链路输出第一个比特之前，必须接收到整个分组
<br>该传输中路由器的任务：把一个入分组交换到一个出链路
<br>存储转发传输通过 N 条速率为 R 的链路组成的路径，端到端时延是 


<br>排队时延和分组丢失

<br>输出缓存/队列(output buffer/queue)：用于存储路由器即将发送的分组
<br>排队时延(queuing delay)：链路繁忙时分组需要在输出缓存中等待
<br>分组丢包(packet loss)：分组到达分组交换机后发现输出缓存已满，分组被丢弃


<br>转发表和路由选择协议

<br>分组首部包含了目的地的IP地址
<br>每个路由器具有一个转发表(forwarding table)：将目的地址映射为输出链路
<br>互联网具有一些特殊的路由选择协议用于自动地设置转发表 




<br><br>
<br>在端系统间通信会话期间，预留了端系统沿路径通信所需要的资源(缓存，传输速率)
<br>发送方和接收方之间建立一条连接(电路)，并为发送方和接收方预留了带宽，发送方能以确保的恒定速率向接收方传送数据
<br>在电路交换网络中则是建立一条端到端连接
<br>电路交换网络复用

<br>频分复用(Frequency-Division Multiplexing, FDM)：在连接期间链路为每条链接专用一个频段

<br>频段的宽度称为带宽(band-width)


<br>时分复用(Time-Division Multiplexing, TDM)：时间被划分为固定的帧，每个帧被划分为固定数量的时隙

<br>传播速率：帧速率✖️一个时隙中的比特数量
<br>电路交换的端到端时延与传输通过的链路数量无关




<br><br>
<br>分组交换不适合实时服务，端到端时延可变和不可预测
<br>分组交换提供了比电路交换更好的带宽共享
<br>比电路交换更简单更有效，实现成本更低
<br>分组交换按需分配链路使用，电路交换不考虑需求
<br><br>
<br>为让端系统连接至互联网ISP自身必须互联:借助路由器将同构或异构的网络实现互联互通
<br>网络结构1：单个全球传输ISP互联所有接入ISP

<br>接入ISP：客户(customer)
<br>全球传输ISP：提供商(provider)


<br>网络结构2：多个全球传输ISP和多个接入ISP
<br>网络结构3：多个竞争的第一层ISP和多个竞争的区域ISP
<br>网络结构4：跟今天因特网更为相似的网络，在网络结构3基础上增加存在点、多宿、对等和因特网交换 

<br>存在点(Point of Presence)：提供商网络中一台或多台相同位置路由器群组
<br>多宿(multi-home)：除了第一层ISP之外任何ISP可以选择与两个或多个提供商ISP连接
<br>对等(peer)：为了减少向提供商的付费，位于相同等级结构层次的临近一对ISP能够将网络连到一起

<br>因特网交换点(Internet Exchange Point, IXP)：多个ISP在一起对等




<br>网络结构5：现今的互联网，在网络结构4的顶部增加内容提供商网络

<br>减少内容提供商向顶层ISP支付的费用，对服务最终如何交付给端用户有了更多的控制


<br><br><br>
<br>节点处理时延(nodal processing delay)

<br>检测分组首部并决定将分组导向何处
<br>检查比特级别的差错


<br>排队时延(queuing delay)

<br>分组在链路上等待传输时造成的时延


<br>传输时延(transmission delay) 

<br>将一个分组的所有比特推向链路所需要的时间


<br>传播时延(propagation delay)

<br>一个比特由起点路由器传播至终点路由器所需要的时间


<br>节点总时延：
<br><br>
<br>排队时延取决于流量到达该队列的速率、链路的平均速率和到达流量的性质
<br>流量强度(traffic intensity)： 

<br>分组到达队列的平均速度：a(pkt/s)
<br>传输速率：R(bps)
<br>分组的比特数：L
<br>设计系统时流量强度不能大于1
<br>流量强度越接近1链路越容易拥塞


<br>丢包：路由器排队容量有限，若分组到达时队列已满，路由器将丢弃该分组
<br>节点的性能根据时延和丢包概率来度量
<br><br>
<br>假定源主机和目的主机之间有N-1台路由器，网络是无拥塞的

<br>端到端时延：


<br>端系统、应用程序和其他时延

<br>希望向共享媒体(WiFi或电缆调制解调器)传输分组的端系统
<br>媒体的分组化时延(VoIP)


<br><br>
<br>瞬时吞吐量(instantaneous throughput)和平均吞吐量(average throughput)
<br>简单的两链路网络吞吐量是瓶颈链路(bottleneck link)的传输速率(近似)
<br>吞吐量不仅取决于沿着路径的传输速率，而且取决于干扰流量
<br><br><br>
<br>利用分层体系结构，可以讨论一个大而复杂系统定义良好的特定部分
<br><br><img alt="Pasted image 20231031145614.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031145614.png"><img alt="Pasted image 20231108104004.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108104004.png"><br>
<br>分层(layer)：为了给网络设计的协议提供一个结构，网络设计者以分层(layer)的方式组织协议以及实现这些协议的硬件和软件
<br>服务模型(service model)：某层向他的上一层提供的服务
<br>物理层和数据链路层的通信通常在网络接口卡中实现
<br>优点：概念化和结构化
<br>缺点：一层可能冗余较低层的功能(eg. 在链路层和传输层的某些协议均实现了差错检测)、某层的功能可能需要仅在其他某层出现的信息
<br><a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">协议数据单元</a> (Protocol data unit)：⚠️本书用 packet (分组，我认为翻译为"封包"更加恰当) 统称 Layer 2+ 的所有的协议数据单元，在给出 Protocol 的 <a data-tooltip-position="top" aria-label="因特网 > ^845e9d" data-href="因特网#^845e9d" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^845e9d" class="internal-link" target="_self" rel="noopener">定义</a> 时还使用了报文 (message) 统称这些数据单元 (但在后文却专指应用层 PDU)，介绍协议分层时用 datagram 称呼网络层分组，请注意区分，避免与配图和网络资料(上面两张图的网络层 PDU 的表示方式就不同，图 1 为 Packet，图 2 为 IP Datagram)混淆，是 TCP/IP 5-layer reference model 和 OSI model 的差异和教材为了教学便利的简化造成的 <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Internet_protocol_suite#Layering_evolution_and_representations_in_the_literature" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Internet_protocol_suite#Layering_evolution_and_representations_in_the_literature" target="_blank">Layering evolution and representations in the literature</a> 

<br>The Layer 5：应用层 PDU 称为报文 (message)，也可称数据(data)
<br>The Layer 4 ：传输层 PDU 称为报文段 (segment, TCP) 或数据报 (datagram, UDP)，本书为了防止与网络层数据报混淆将两者统称为报文段 (segment)
<br>The Layer 3：网络层 PDU 称为分组 (packet)，本书中称为数据报 (datagram)(IP 协议中这么称呼它的封包)
<br>The Layer 2：链路层 PDU 称为帧 (frame)
<br>The Layer 1：物理层 PDU 称为比特 (bit)，或者更一般地称为符号 (symbol)


<br>协议栈(protocol stack)：协议分层后各层的所有协议，大黑皮使用了自顶向下的方法来组织内容

<br>物理层

<br>将链路层帧中的比特从一个节点移动到下一个节点
<br>以太网具有许多物理层协议：关于双绞铜线的、关于同轴电缆的、关于光纤的······


<br>链路层

<br>帧(frame)：链路层分组
<br>某些协议基于链路提供可靠传递，从传输节点跨越一条链路到接收节点


<br>网络层

<br>负责将称为数据报(datagram)的网络层分组从一台主机移动到另一台主机
<br>网际协议IP
<br>路由选择协议


<br>运输层

<br>在应用层端点(主机上的进程)间传送应用层报文
<br>TCP：提供了面向连接的服务，包括确保传递和流量控制
<br>UDP：提供无连接服务，没有流量控制和拥塞控制
<br>报文段(segment)：运输层的分组


<br>应用层

<br>存留网络应用程序及应用层协议(HTTP/SMTP/FTP/DNS)
<br>报文(message)：位于应用层的信息分组




<br>OSI模型

<br>20世纪70年代后期，ISO提出开放系统互联(OSI)模型
<br>OSI参考的7层：应用层、表示层、会话层、运输层、网络层、数据链路层和物理层
<br>表示层：使通信的应用程序能够解释交换数据的含义，包括数据压缩和数据加密以及数据描述
<br>会话层：提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法


<br><a data-tooltip-position="top" aria-label="https://www.xiaolincoding.com/network/1_base/what_happen_url.html#%E5%AD%A4%E5%8D%95%E5%B0%8F%E5%BC%9F-http" rel="noopener" class="external-link" href="https://www.xiaolincoding.com/network/1_base/what_happen_url.html#%E5%AD%A4%E5%8D%95%E5%B0%8F%E5%BC%9F-http" target="_blank">图解计算机网络</a> 给出的相对通俗易懂的解释可以作为参考
<br><br>
<br>每一层每个分组有两种类型的字段：首部字段和有效荷载字段(payload field)，有效荷载字段通常是来自上一层的分组
<br>发送主机端，应用层报文(application-layer message)被传送给运输层
<br>运输层报文段(transport-layer segment)：运输层收到应用层报文并附上运输层首部信息，封装了应用层报文
<br>网络层数据报(network-layer datagram)：网络层添加了如源和目的端系统地址等网络层首部信息
<br>链路层帧(link-layer frame)：链路层添加链路层首部信息
]]></description><link>campus/chinese-notes/计算机科学/计算机网络/因特网.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/因特网.md</guid><pubDate>Fri, 22 Dec 2023 11:04:20 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101104608.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101104608.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[应用层协议原理]]></title><description><![CDATA[ 
 <br><br>
<br>研发网络应用程序的核心是写出能够运行在不同的端系统和通过网络彼此通信的程序
<br>即将应用软件限制在端系统的方法．促进了大量的网络应用程序的迅速研发和部署
<br><br>
<br>从应用程序研发者角度看，网络体系结构是固定的，并为应用程序提供了特定的服务集合
<br>应用程序体系结构 (application architecture) ：由应用程序研发者设计，规定了如何在各端系统上组织该应用程序
<br><br>
<br>总是打开的主机——服务器，它服务于来自许多其他称为客户的主机的请求
<br>服务器具有固定周知的 IP 地址
<br>著名应用程序

<br>Web
<br>FTP
<br>Telnet
<br>电子邮件


<br>配备大量主机的数据中心 (data center) 常被用于创建强大的虚拟服务器
<br><br>
<br>应用程序在间断连接的主机对之间使用直接通信，这些主机对被称为对等方，这些对等方并不为服务提供商所有
<br>具有自扩展性: 每个对等方都由于请求文件产生工作负载，但通过向其他对等方分发文件为系统增加服务能力
<br><br><img alt="Pasted image 20231023191228.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231023191228.png"><br>
<br>进程 (<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Process_" rel="noopener" class="external-link" title="computing" href="https://en.wikipedia.org/wiki/Process_" target="_blank">process</a>): In computing, a process is the instance of a computer program that is being excuted by one or many threads.) 是运行在端系统上的程序，当多个进程运行在相同的端系统上时，它们使用进程间通信机制相互通信
<br>不同端系统上的进程，通过跨越计算机交换报文 (message) 而相互通信
<br><br>
<br>在一对进程之间的通信会话场景中，发起通信（即在该会话开始时发起与其他进程的联系）的进程被标识为客户，在会话开始时等待联系的进程是服务器。
<br><br>
<br>进程通过称为套接字 (socket) 的软件接口向网络发送报文和从网络接收报文

<br>套接是同一台主机内应用层与运输层之间的接口
<br>由于该套接字是建网络应用程序的可编程接口，因此套接字也称为应用程序和网络之间的应用程序编程接口 (Application Programming Interface, API)  


<br>应用程序开发者对运输层的控制仅限于于

<br>选择运输层协议
<br>设定几个参数，如最大缓存和最大报文长度等


<br><br>
<br>为了标识接受进程，需要定义两种信息

<br>主机的地址
<br>在目的主机中指定接收进程的标识符 (目的地端口号)


<br><br>
<br>通过研究可用的运输层协议提供的服务，选择一个最能为应用需求提供恰当服务的协议
<br>按照应用程序服务要求分类

<br>可靠数据传输
<br>吞吐量
<br>定时
<br>安全性


<br><br>
<br>如果一个协议提供了确保由应用程序的一端发送的数据正确、完全地交付给该应用程序的另一端的数据交付服务，就认为提供了可靠数据传输服务 (reliable data transfer)
<br>运输层协议向应用程序提供的一个重要服务是进程到进程的可靠数据传输
<br>容忍丢失的应用 (loss-tolerant application): 使用的运输层协议不提供可靠数据传输，发送进程的数据可能
<br><br>
<br>可用吞吐量：发送进程能够向接收进程交付比特的速率
<br>产生了一种能够以某种特定的速率提供确保的可用吞吐量的运输层协议，适用于带宽敏感的应用
<br>带宽敏感的应用 (bandwidth-sensitive application)：具有吞吐量要求的应用程序
<br>弹性应用(elastic application)：能够根据当时可用带宽或多或少地利用可供使用的吞吐量
<br><br>
<br>对于交互式实时应用程序有吸引力，如因特网电话、虚拟环境、电话会议和多方游戏
<br>定时保证：发送方注入套接字的每个比特到达接收方的套接字不迟于特定时间限制
<br><br>
<br>运输协议能够为应用程序提供一种或多种安全性服务
<br>发送主机中运输协议能够加密发送进程传输的所有数据
<br>接收主机中运输层协议能够将数据交付给接收进程前解密这些数据
<br>运输层协议能够提供机密性、数据完整性和端点鉴别等安全性服务
<br><br>
<br>因特网为应用程序提供了两个运输层协议，即 UDP 和 TCP
<br><br>
<br>TCP 服务模型包括面向连接服务和可靠数据传输服务
<br>面向连接的服务：

<br>握手过程：在应用层数据报文开始流动之前，TCP 让客户和服务器互相交换运输层控制信息
<br>握手阶段后，两个进程的套接字之间建立一个 <a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/zh-cn/%E9%9B%99%E5%B7%A5" rel="noopener" class="external-link" href="https://zh.wikipedia.org/zh-cn/%E9%9B%99%E5%B7%A5" target="_blank"><strong></strong></a>全双工 的 TCP 连接 (TCP connection)，当应用程序结束报文发送时，必须拆除该连接


<br>可靠的数据传送服务：<br>
<img alt="Pasted image 20231031150119.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031150119.png">

<br>通信进程能够依靠 TCP，无差错、按适当顺序交付所有发送的数据


<br>拥塞控制机制
<br>TCP 安全

<br>安全套接字层 (Secure Sockets Layer，SSL)：经过 SSL 增强的传输控制协议（TCP）不仅具备传统 TCP 的功能，而且还提供了关键的进程到进程安全性服务，包括加密、数据完整性和端点鉴别
<br>SSL 在应用层上实现


<br><br>
<br>UDP 无连接没有握手过程，没有拥塞控制机制，UDP 协议提供不可靠的数据传送服务<br>
<img alt="Pasted image 20231031152513.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031152513.png">
<br><br>
<br>今天的因特网通常能够为时间敏感应用提供满意的服务，但它不能提供任何定时或带宽保证
<br><br>
<br>应用层协议 (application-layer protocol) 定义了运行在不同端系统上的应用程序进程如何相互传递报文
<br>应用层协议定义了：

<br>交换的报文类型
<br>各种报文类型的语法
<br>字段的语义
<br>确定一个进程何时以及如何发送报文，对报文进行响应的规则


<br>应用层协议分为定义在公共域中的协议和专用的协议
<br>应用层协议只是网络应用的重要部分<br>
<img alt="network-protocol.gif" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/network-protocol.gif">
<br><br>
<br>万维网 (World Wide Web)是一个因特网应用，其使用的应用层协议是超文本传输协议(HyperText Transfer Protocol, HTTP) <a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">RFC 1945</a> <a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">RFC 2616</a>
<br>Web 具有按需操作，获取信息便捷等特点
<br>Web 页面由对象 (object) 组成，一个对象是一个文件，多数 Web 页面含有一个 HTML 基本文件以及几个引用对象
<br>White 的静态博客的文件结构(入口是 index.html)<br>
<img alt="Pasted image 20231031154854.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031154854.png">
<br>URL 地址由存放对象的服务器主机名和对象的路径名组成
<br><br>
<br>HTTP 定义了 Web 客户向 Web 服务器请求 Web 页面的方式，以及服务器向客户传送 Web 页面的方式
<br>HTTP 使用 TCP 作为它的支撑运输协议
<br>HTTP 不保存关于客户的任何信息，所以 HTTP 是一个无状态协议(stateless protocol)
<br><br>
<br>根据每个请求/相应对经一个单独的 TCP 连接发送还是经相同的 TCP 连接发送划分
<br>非持续连接 (non-persistent connection)：<img alt="Pasted image 20231031163253.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031163253.png"> <img alt="Pasted image 20231031164531.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031164531.png"> <img alt="Pasted image 20231031163437.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031163437.png"> <img alt="Pasted image 20231031163454.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031163454.png"> 针对不同的 HostName 建立了两个并行的 TCP 连接 (Q: 怎么通过工具观察图 2 和图 3 的两个连接是否是持续的) 

<br>用户可以配置现代浏览器来控制连接的并行度
<br>往返时间(Round-Trip Time, RTT)： 

<br>一个短分组从客户到服务器然后再返回客户所花费的时间。 
<br>RTT 包括分组传播时延、分组在中间路由器和交换机上的排队时延以及分组处理时延
<br>点击超链接引起浏览器和 Web 服务器间发起一个 TCP 连接，涉及一次"三次握手"的过程 <img alt="Pasted image 20231031165751.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031165751.png">
<br>总的响应时间是两个 RTT 加上服务器传输(?) HTML 文件的时间


<br>缺点：

<br>必须为每一个请求的对象建立和维护一个全新的连接
<br>每一个对象经受两倍 RTT 的交付时延




<br>持续连接(persistent connection)

<br>在采用 HTTP1.1 持续连接的情况下，服务器在发送响应后保持 TCP 连接打开，在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送 <img alt="Pasted image 20231031171140.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231031171140.png">


<br><br>
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages" target="_blank">MDN-HTTP消息</a>
<br>
<br>对 HTTP 报文格式的定义：<a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">RFC 1945</a> <a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">RFC 2616</a> <a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">RFC 7540</a>
<br><br>GET / HTTP/1.1
Host: cnhktrz3k5nc.hack-challenge.lug.ustc.edu.cn:13202
Cookie: session=eyJ0b2tlbiI6IjU2ODpNRVVDSVFEOUtzZWdBT2c5ZE9jdGkzUmJPSUVTSTdSTWQ5cDRQaW8vdWNxTXY3V0dhUUlnR0dIMHVROHhISWI4SzBNT2lidlFjVk0xaGoxZEdQZGNOYkpGbXJyZE45az0ifQ.ZUGxTw.PrwGL6P9rTzYpTfdu21r7irxBjQ
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/118.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Te: trailers
Connection: close


----------------------------------------------------------
🌟 加上不显示的回车和换行符后，报文中的空格也是真实存在的 (感谢ChatGPT的帮助)
GET / HTTP/1.1\r\n
Host: cnhktrz3k5nc.hack-challenge.lug.ustc.edu.cn:13202\r\n
Cookie: session=eyJ0b2tlbiI6IjU2ODpNRVVDSVFEOUtzZWdBT2c5ZE9jdGkzUmJPSUVTSTdSTWQ5cDRQaW8vdWNxTXY3V0dhUUlnR0dIMHVROHhISWI4SzBNT2lidlFjVk0xaGoxZEdQZGNOYkpGbXJyZE45az0ifQ.ZUGxTw.PrwGL6P9rTzYpTfdu21r7irxBjQ\r\n
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/118.0\r\n
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8\r\n
Accept-Language: en-US,en;q=0.5\r\n
Accept-Encoding: gzip, deflate\r\n
Upgrade-Insecure-Requests: 1\r\n
Sec-Fetch-Dest: document\r\n
Sec-Fetch-Mode: navigate\r\n
Sec-Fetch-Site: none\r\n
Sec-Fetch-User: ?1\r\n
Te: trailers\r\n
Connection: close\r\n\r\n 🌟 在表面上看来末尾有两个空行
Copy<br>🌟 使用ASCII编码转换为16进制，数据被注入套接字后穿过传输层、网络层、数据链路层、物理层(中间存在分组(?)等情况)以比特流的形式经过网络基础设施

G  E  T  SP /  SP H  T  T  P  /  1  .  1  CR LF ...
47 45 54 20 2f 20 48 54 54 50 2f 31 2e 31 0d 0a 48 6f 73 74 3a 20 63 6e 68 6b 74 72 7a 33 6b 35 6e 63 2e 68 61 63 6b 2d 63 68 61 6c 6c 65 6e 67 65 2e 6c 75 67 2e 75 73 74 63 2e 65 64 75 2e 63 6e 3a 31 33 32 30 32 0d 0a 43 6f 6f 6b 69 65 3a 20 73 65 73 73 69 6f 6e 3d 65 79 4a 30 62 32 74 6c 62 69 49 36 49 6a 55 32 4f 44 70 4e 52 56 56 44 53 56 46 45 4f 55 74 7a 5a 57 64 42 54 32 63 35 5a 45 39 6a 64 47 6b 7a 55 6d 4a 50 53 55 56 54 53 54 64 53 54 57 51 35 63 44 52 51 61 57 38 76 64 57 4e 78 54 58 59 33 56 30 64 68 55 55 6c 6e 52 30 64 49 4d 48 56 52 4f 48 68 49 53 57 49 34 53 7a 42 4e 54 32 6c 69 64 6c 46 6a 56 6b 30 78 61 47 6f 78 5a 45 64 51 5a 47 4e 4f 59 6b 70 47 62 58 4a 79 5a 45 34 35 61 7a 30 69 66 51 2e 5a 55 47 78 54 77 2e 50 72 77 47 4c 36 50 39 72 54 7a 59 70 54 66 64 75 32 31 72 37 69 72 78 42 6a 51 0d 0a 55 73 65 72 2d 41 67 65 6e 74 3a 20 4d 6f 7a 69 6c 6c 61 2f 35 2e 30 20 28 4d 61 63 69 6e 74 6f 73 68 3b 20 49 6e 74 65 6c 20 4d 61 63 20 4f 53 20 58 20 31 30 2e 31 35 3b 20 72 76 3a 31 30 39 2e 30 29 20 47 65 63 6b 6f 2f 32 30 31 30 30 31 30 31 20 46 69 72 65 66 6f 78 2f 31 31 38 2e 30 0d 0a 41 63 63 65 70 74 3a 20 74 65 78 74 2f 68 74 6d 6c 2c 61 70 70 6c 69 63 61 74 69 6f 6e 2f 78 68 74 6d 6c 2b 78 6d 6c 2c 61 70 70 6c 69 63 61 74 69 6f 6e 2f 78 6d 6c 3b 71 3d 30 2e 39 2c 69 6d 61 67 65 2f 61 76 69 66 2c 69 6d 61 67 65 2f 77 65 62 70 2c 2a 2f 2a 3b 71 3d 30 2e 38 0d 0a 41 63 63 65 70 74 2d 4c 61 6e 67 75 61 67 65 3a 20 65 6e 2d 55 53 2c 65 6e 3b 71 3d 30 2e 35 0d 0a 41 63 63 65 70 74 2d 45 6e 63 6f 64 69 6e 67 3a 20 67 7a 69 70 2c 20 64 65 66 6c 61 74 65 0d 0a 55 70 67 72 61 64 65 2d 49 6e 73 65 63 75 72 65 2d 52 65 71 75 65 73 74 73 3a 20 31 0d 0a 53 65 63 2d 46 65 74 63 68 2d 44 65 73 74 3a 20 64 6f 63 75 6d 65 6e 74 0d 0a 53 65 63 2d 46 65 74 63 68 2d 4d 6f 64 65 3a 20 6e 61 76 69 67 61 74 65 0d 0a 53 65 63 2d 46 65 74 63 68 2d 53 69 74 65 3a 20 6e 6f 6e 65 0d 0a 53 65 63 2d 46 65 74 63 68 2d 55 73 65 72 3a 20 3f 31 0d 0a 54 65 3a 20 74 72 61 69 6c 65 72 73 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a 0d 0a
Copy<br>
<br>一个简单 (大嘘，对我来说很复杂了) 的 HTTP 请求报文 (来自 USTC Hackergame 2023)，作为运输层的载荷被注入套接字

<br>由普通的 ASCII 文本书写
<br>请求行 (第一行)

<br>方法字段
<br>URL 字段
<br>HTTP 版本字段


<br>首部行 (后继行)


<br>GET / HTTP/1.1
Host: cnhktrz3k5nc.hack-challenge.lug.ustc.edu.cn:13202 🌟 Web代理高速缓存要求
Cookie: session=eyJ0b2tlbiI6IjU2ODpNRVVDSVFEOUtzZWdBT2c5ZE9jdGkzUmJPSUVTSTdSTWQ5cDRQaW8vdWNxTXY3V0dhUUlnR0dIMHVROHhISWI4SzBNT2lidlFjVk0xaGoxZEdQZGNOYkpGbXJyZE45az0ifQ.ZUGxTw.PrwGL6P9rTzYpTfdu21r7irxBjQ
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/118.0 🌟 用户代理/向服务器发送请求的浏览器类型
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5 🌟 表示用户想获得网页的语言版本
Accept-Encoding: gzip, deflate
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Te: trailers
Connection: close 🌟 不需要使用持续连接，发送完请求的对象后就关闭这条连接
Copy<br><br><img alt="Pasted image 20231101133831.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101133831.png"><br>
<br>在首部行后有实体体，当使用 GET 方法时实体体为空，使用 POST 方法时才使用实体体
<br>
<br>一段 POST 报文
<br>POST / HTTP/1.1
Host: 202.38.93.111:12345
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/118.0
Accept: */*
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
X-Requested-With: XMLHttpRequest 🌟 通常被用于识别AJAX(Asynchronous JavaScript and XML)请求
Content-Length: 48 🌟 说明发送给接收方的消息主体的大小，即用十进制数字表示的八位元组的数目
Origin: http://202.38.93.111:12345
Connection: close
Referer: http://202.38.93.111:12345/
Cookie: session=eyJ0b2tlbiI6IjU2ODpNRVVDSVFEOUtzZWdBT2c5ZE9jdGkzUmJPSUVTSTdSTWQ5cDRQaW8vdWNxTXY3V0dhUUlnR0dIMHVROHhISWI4SzBNT2lidlFjVk0xaGoxZEdQZGNOYkpGbXJyZE45az0ifQ.ZUHm-g.kVPjkYgY94gYkzV03PmLKCKWuhI

QW5zd2VyMT0yMDIzLTA4LTEwJkFuc3dlcjI9SUNSUg==.txt 🌟 实体体
Copy<br>
<br>服务器收到 HEAD 方法，用一个 HTTP 报文进行相应但不返回请求对象
<br>HEAD / HTTP/2
Host: cnhktrz3k5nc.hack-challenge.lug.ustc.edu.cn:13202
Cookie: session=eyJ0b2tlbiI6IjU2ODpNRVVDSVFEOUtzZWdBT2c5ZE9jdGkzUmJPSUVTSTdSTWQ5cDRQaW8vdWNxTXY3V0dhUUlnR0dIMHVROHhISWI4SzBNT2lidlFjVk0xaGoxZEdQZGNOYkpGbXJyZE45az0ifQ.ZUGxTw.PrwGL6P9rTzYpTfdu21r7irxBjQ
User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:109.0) Gecko/20100101 Firefox/118.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Upgrade-Insecure-Requests: 1
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Te: trailers


Copy<br>HTTP/2 200 OK
Server: nginx
Date: Wed, 01 Nov 2023 05:39:21 GMT
Content-Type: text/html; charset=utf-8
Vary: Accept-Encoding
Vary: Cookie
X-Xss-Protection: 1; mode=block
X-Content-Type-Options: nosniff
Referrer-Policy: no-referrer-when-downgrade
Permissions-Policy: interest-cohort=()


Copy<br>
<br>PUT 方法用于上传对象到 Web 服务器上的指定路径
<br>PUT /echo/put/json HTTP/1.1
Host: reqbin.com
Content-Type: application/json
Content-Length: 80

{
  "Id": 12345,
  "Customer": "John Smith",
  "Quantity": 1,
  "Price": 10.00
}
Copy<br>
<br>DELETE 方法删除 Web 服务器上的对象
<br>DELETE /echo/delete/json HTTP/1.1
Host: reqbin.com
Accept: */*
Authorization: Bearer mt0dgHmLJMVQhvjpNXDyA83vA_PxH23Y
Copy<br><br>
<br>这是一段 HTTP 响应报文
<br>HTTP/1.1 200 OK 🌟 协议版本 状态码 状态信息
Server: nginx
Content-Length: 90
Via: 1.1 google
Date: Tue, 31 Oct 2023 19:59:05 GMT 🌟 响应生成的时间
Age: 36693
Content-Type: text/html 🌟 实体体中的对象类型
Cache-Control: public,must-revalidate,max-age=0,s-maxage=3600
Connection: close 🌟 发送完报文后就关闭TCP连接

&lt;meta http-equiv="refresh" content="0;url=https://support.mozilla.org/kb/captive-portal"/&gt;
Copy<br>
<br>报文有三个部分

<br>状态行 (status line)

<br>协议版本
<br>状态码
<br>状态信息


<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers" target="_blank">首部行</a> (header line)
<br>实体体 (entity body)


<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status" target="_blank">状态码和状态信息</a>
<br><br>
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank">MDN-Cookie</a>
<br>
<br>HTTP 服务器无状态，Web 服务器为了跟踪用户使用 cookie 技术
<br>Cookie 技术的组件

<br>响应报文中的 cookie 首部行
<br>请求报文中的 cookie 首部行
<br>用户端系统浏览器管理的 cookie 文件 (macOS 保存在 ~/Library/Application Support/Google/Chrome/Default/Cookies 路径下)
<br>位于 Web 站点的后端数据库


<br>cookie 在无状态的 HTTP 之上建立了一个用户会话层
<br><br>
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Proxy_servers_and_tunneling" target="_blank">MDN-代理服务器和隧道</a>
<br>
<br>Web 缓存器 (Web cache) / 代理服务器 (proxy server)：能够代表初始 Web 服务器来满足 HTTP 请求的网络实体

<br>正向代理：代理服务器靠近客户端并代表客户端发送请求
<br><a data-tooltip-position="top" aria-label="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/" rel="noopener" class="external-link" href="https://www.cloudflare.com/zh-cn/learning/cdn/glossary/reverse-proxy/" target="_blank">反向代理</a>：当客户端将请求发送到网站的源服务器时，反向代理服务器会在<a data-tooltip-position="top" aria-label="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/" rel="noopener" class="external-link" href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/" target="_blank">网络边缘</a>拦截这些请求。然后，反向代理服务器将向源服务器发送请求并从源服务器接收响应。


<br>Web 缓存器的优点

<br>减少对客户请求的响应时间，特别是当客户与初始服务器之间的瓶颈带宽远低于客户与 Web 缓存器之间的瓶颈带宽时
<br>大大减少一个机构的接入到因特网的通信量
<br>大大减低因特网上的 Web 流量


<br><br><img alt="h500" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101163234.png"> <img alt="h500" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231101163308.png"><br>
<br>条件：假设对象的平均长度为 1Mb ，机构内的浏览器对初试服务器的平均访问速率为每秒 15 个请求，假设 HTTP 请求报文小到可以忽略，主要关注 HTTP 响应报文
<br>第一种情况下：

<br>局域网上的 <a data-tooltip-position="top" aria-label="因特网 > ^8065eb" data-href="因特网#^8065eb" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^8065eb" class="internal-link" target="_self" rel="noopener">流量强度</a>：(15 个请求 /s) x (1 Mb / 请求) / (100Mbps) = 0.15
<br>接入链路上的流量强度：(15 个请求 /s) x (1 Mb / 请求) / (15 Mbps) = 1


<br>优化方案：

<br>将接入链路从 15Mbps 升级为 100Mbps
<br>在机构网络中安装一个 Web 缓存器


<br>在安装 Web 缓存器的情况下

<br>假设该机构的缓存命中率为 0.4，40%的请求命中缓存响应在 10ms 内，剩下 60%需要请求初始服务器，平均时延为 0.4 x ( 0.010 s ) + 0.6 x (2.01 s) = 1.21 s
<br>接入链路上的流量强度下降为：(15 个请求 /s) x (1 Mb / 请求) x 0.6 / (15 Mbps) = 0.6


<br>通过使用内容分发网络(Content Distribution Network, CDN)，Web 缓存器在因特网上发挥着越来越重要的作用
<br><br>
<br><a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Conditional_requests" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Conditional_requests" target="_blank">MDN-HTTP条件请求</a>
<br>
<br>条件 GET (conditional GET) 方法：

<br>请求报文使用 GET 方法
<br>请求报文中包含一个 "If-Modified-Since: " 首部行 (?)


<br>条件请求：请求的执行结果会因特定首部的值不同而不同
<br>验证器：

<br>last-modified：文件的最后修改时间
<br>etag：可以用于提供资源或其衍生品的 MD5 散列值


<br>检查类型：HTTP 协议默认使用强验证类型

<br>强验证类型
<br>弱验证类型


<br>条件首部：

<br>If-Match
<br>If-None-Match
<br>If-Modified-Since：如果远端资源的&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank"><code></code></a>Last-Modified&nbsp;首部标识的日期比在该首部中列出的值要更晚，表示条件匹配成功。
<br>If-Unmodified-Since
<br>If-Range


<br>缓存更新

<br>当缓存为空或者无缓存时，被请求资源通过状态码为 200 OK 的 HTTP 响应报文返回 <img alt="Pasted image 20231102100948.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231102100948.png">
<br>验证器首部行也随着资源在 HTTP 响应中返回，和资源一起被缓存起来
<br>Cache-Control 首部控制缓存是否失效，一旦失效客户端就发起条件请求否则使用缓存值，验证器的值会用作条件请求中&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since" target="_blank"><code></code></a>If-Modified-Since&nbsp;和&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Match" target="_blank"><code></code></a>If-Match&nbsp;首部字段的参数
<br>如果资源未发生变化，服务器返回状态码为&nbsp;<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank"><code></code></a>304&nbsp;Not Modified&nbsp;的响应<img alt="Pasted image 20231102103202.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231102103202.png">
<br>如果资源发生变化，服务器返回 <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" rel="noopener" class="external-link" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank"><code></code></a>200&nbsp;OK&nbsp;响应码，连同新版本的资源，再次回到步骤 2 <img alt="Pasted image 20231102103136.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231102103136.png">


<br><br><img alt="Pasted image 20231103092045.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231103092045.png"><br>
<br><a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">Cloudflare-什么是SMTP</a>
<br>
<br>组成部分：

<br>用户代理 (user agent)：Outlook, Apple Mail
<br>邮件服务器 (mail server)
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Simple_Mail_Transfer_Protocol" target="_blank">简单邮件传输协议</a> (Simple Mail Transfer Protocol, SMTP)
<br>邮件访问协议 (mail access protocol)


<br>一个典型的邮件发送过程是：从发送方的用户代理开始，传输到发送方的邮件服务器，再传输到接收方的邮件服务器，然后在这里被分发到接收方的邮箱中
<br>如果邮件服务器客户端不能把邮件交付给接收方，则会在报文队列(message queue)中保持该报文并在以后尝试发送，如果一段时间后仍不成功，则客户端删除报文并以电子邮件形式通知发送方
<br><br>
<br>不妨试着运行一个简单的 SMTP 服务器并且用 telnet 交互
<br>import smtpd
import asyncore

class CustomSMTPServer(smtpd.SMTPServer):
    def process_message(self, peer, mailfrom, rcpttos, data):
        print('Received message from:', peer)
        print('Message addressed from:', mailfrom)
        print('Message addressed to  :', rcpttos)
        print('Message length        :', len(data))
        print('Data:')
        print(data)

server = CustomSMTPServer(('0.0.0.0', 25), None)

try:
    asyncore.loop()
except KeyboardInterrupt:
    server.close()
Copy<br>&gt; telnet localhost 25
Copy<br>
<br>这是一段 SMTP 客户端和 SMTP 服务端交互案例
<br>S: 220 smtp.example.com ESMTP Postfix
C: HELO relay.example.org
S: 250 Hello relay.example.org, I am glad to meet you
C: MAIL FROM:&lt;bob@example.org&gt;
S: 250 Ok
C: RCPT TO:&lt;alice@example.com&gt;
S: 250 Ok
C: RCPT TO:&lt;theboss@example.com&gt;
S: 250 Ok
C: DATA
S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;
C: `From: "Bob Example" &lt;bob@example.org&gt;`
C: `To: "Alice Example" &lt;alice@example.com&gt;`
C: `Cc: theboss@example.com`
C: `Date: Tue, 15 Jan 2008 16:02:43 -0500`
C: `Subject: Test message`
C:
C: Hello Alice.
C: This is a test message with 5 header fields and 4 lines in the message body.
C: Your friend,
C: Bob
C: .
S: 250 Ok: queued as 12345
C: QUIT
S: 221 Bye
{The server closes the connection}
Copy<br>
<br>HELO/EHLO：这些命令发出 “Hello” 并在客户端和服务器之间启动 SMTP 连接。“HELO” 是该命令的基本版本；“EHLO” 用于一种特别类型的 SMTP。
<br>MAIL FROM：这个命令告诉服务器谁在发送该电子邮件。如果 Alice 试图给她的朋友 Bob 发电子邮件，客户端可能会发送 “MAIL FROM：<a data-tooltip-position="top" aria-label="mailto:alice@example.com" rel="noopener" class="external-link" href="mailto:alice@example.com" target="_blank">alice@example.com</a>”。
<br>RCPT TO：这个命令用于列出电子邮件的收件人。如果有**多个收件人，客户端可多次发送该命令。如上例子中，Alice 的电子邮件客户端将发送： “RCPT TO: <a data-tooltip-position="top" aria-label="mailto:bob@example.com" rel="noopener" class="external-link" href="mailto:bob@example.com" target="_blank">bob@example.com</a>"。
<br>DATA：这个命令放在电子邮件的内容前，DATA 中的内容 (邮件报文格式)由 <a data-tooltip-position="top" aria-label="https://datatracker.ietf.org/doc/html/rfc5322" rel="noopener" class="external-link" href="https://datatracker.ietf.org/doc/html/rfc5322" target="_blank">RFC 5322 - Internet Message Format</a> 规定，并以 &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt; 结尾
<br>RSET：该命令重置连接，删除所有以前传输的信息，但不关闭 SMTP 连接。RSET&nbsp;在客户端发送了错误信息的情况下使用。
<br>QUIT：结束连接。
<br>HTTP 主要是一个拉协议 (pull protocol)，SMTP 主要是一个推协议 (push protocol)，可以想象一下木板和绳子的不同之处。一块木板可将某物向前推，但不能将它拉回来。绳子可以拉动某物，但不能推动它。SMTP 将电子邮件“推”到邮件服务器，而 HTTP 将 Web 对象“拉”到用户的应用程序中<br><br>
<br>流行的邮件访问协议包括第三版的邮局协议 ( Post Office Protocol—Version 3, POP3 ) 、因特网邮件访问协议 ( Internet Mail Access Protocol, IMAP) 以及 HTTP
<br>IMAP 和 POP3 的区别：
<br><br><br>
<br>工作阶段

<br>特许 (authorization)
<br>事务处理
<br>更新


<br>下面是一段 POP3 交互案例
<br>S: &lt;wait for connection on TCP port 110&gt;
C: &lt;open connection&gt;
S:    +OK POP3 server ready &lt;1896.697170952@dbc.mtview.ca.us&gt;
C:    APOP mrose c4c9334bac560ecc979e58001b3e22fb
S:    +OK mrose's maildrop has 2 messages (320 octets)
C:    STAT
S:    +OK 2 320
C:    LIST
S:    +OK 2 messages (320 octets)
S:    1 120
S:    2 200
S:    .
C:    RETR 1
S:    +OK 120 octets
S:    &lt;the POP3 server sends message 1&gt;
S:    .
C:    DELE 1
S:    +OK message 1 deleted
C:    RETR 2
S:    +OK 200 octets
S:    &lt;the POP3 server sends message 2&gt;
S:    .
C:    DELE 2
S:    +OK message 2 deleted
C:    QUIT
S:    +OK dewey POP3 server signing off (maildrop empty)
C: &lt;close connection&gt;
S: &lt;wait for next connection&gt;
Copy<br>
<br>APOP ：APOP 命令使用了一个加密的哈希值（MD 5 散列值）来验证用户的身份。当客户端连接到邮件服务器时，服务器会发送一个带有时间戳的随机字符串。然后客户端将该字符串和用户的密码进行组合，并使用 MD5 算法进行哈希运算。最后，客户端发送用户名和计算得到的哈希值给服务器，以完成身份验证。
<br>STAT：获取收件箱中邮件的统计信息
<br>LIST：请求邮件服务器列出所有存储的邮件及其长度
<br>RETR：发送对应的邮件
<br>DELE：给邮件做删除标记
<br>QUIT：结束该 POP3 会话并删除标记为删除的邮件
<br>
<br>POP3 在服务器端保留状态信息，但不在会话过程中携带状态信息，简化了 POP3 服务的实现
<br><br>
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Internet_Message_Access_Protocol" target="_blank">Wikipedia - IMAP</a>
<br>
<br>IMAP 协议为用户提供了创建文件夹以及将邮件从一个文件夹移动到另一个文件夹的命令
<br>IMAP 还为用户提供了在远程文件夹中查询邮件的命令，按指定条件去查询匹配的邮件
<br>IMAP 具有允许用户代理获取报文某些部分的命令
<br>IMAP 服务器维护了 IMAP 会话的用户状态信息
<br>C: &lt;open connection&gt;
S:   * OK IMAP4rev1 Service Ready
C:   a001 login mrc secret
S:   a001 OK LOGIN completed
C:   a002 select inbox
S:   * 18 EXISTS
S:   * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
S:   * 2 RECENT
S:   * OK [UNSEEN 17] Message 17 is the first unseen message
S:   * OK [UIDVALIDITY 3857529045] UIDs valid
S:   a002 OK [READ-WRITE] SELECT completed
C:   a003 fetch 12 full
S:   * 12 FETCH (FLAGS (\Seen) INTERNALDATE "17-Jul-1996 02:44:25 -0700"
      RFC822.SIZE 4286 ENVELOPE ("Wed, 17 Jul 1996 02:23:25 -0700 (PDT)"
      "IMAP4rev1 WG mtg summary and minutes"
      (("Terry Gray" NIL "gray" "cac.washington.edu"))
      (("Terry Gray" NIL "gray" "cac.washington.edu"))
      (("Terry Gray" NIL "gray" "cac.washington.edu"))
      ((NIL NIL "imap" "cac.washington.edu"))
      ((NIL NIL "minutes" "CNRI.Reston.VA.US")
      ("John Klensin" NIL "KLENSIN" "MIT.EDU")) NIL NIL
      "&lt;B27397-0100000@cac.washington.edu&gt;")
      BODY ("TEXT" "PLAIN" ("CHARSET" "US-ASCII") NIL NIL "7BIT" 3028
      92))
S:   a003 OK FETCH completed
C:   a004 fetch 12 body[header]
S:   * 12 FETCH (BODY[HEADER] {342}
S:   `Date: Wed, 17 Jul 1996 02:23:25 -0700 (PDT)`
S:   `From: Terry Gray &lt;gray@cac.washington.edu&gt;`
S:   `Subject: IMAP4rev1 WG mtg summary and minutes`
S:   `To: imap@cac.washington.edu`
S:   `Cc: minutes@CNRI.Reston.VA.US, John Klensin &lt;KLENSIN@MIT.EDU&gt;`
S:   `Message-Id: &lt;B27397-0100000@cac.washington.edu&gt;`
S:   `MIME-Version: 1.0`
S:   `Content-Type: TEXT/PLAIN; CHARSET=US-ASCII`
S:
S:   )
S:   a004 OK FETCH completed
C    a005 store 12 +flags \deleted
S:   * 12 FETCH (FLAGS (\Seen \Deleted))
S:   a005 OK +FLAGS completed
C:   a006 logout
S:   * BYE IMAP4rev1 server terminating connection
S:   a006 OK LOGOUT completed
Copy<br>
<br>From ChatGPT 3.5：在 POP3会话中，状态信息通常包括邮件的状态，比如已读或未读、已删除或未删除。这些信息保存在邮件服务器上，在会话期间，可以通过命令和响应来查询和修改这些状态。在 IMAP 会话中，状态信息更加灵活和丰富。它包括邮件夹（也称为邮箱或文件夹）的状态，比如邮件数、未读邮件数等，还包括每封邮件的状态，比如已读或未读、已删除或未删除。IMAP 还允许客户端保存自己的会话状态，比如当前选定的文件夹、搜索条件等，以便在断开连接后能够恢复会话。
<br>现代用户代理应用程序中显示的用户文件夹结构 (图片来自 Apple Mail)<br>
<img alt="h300" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231103114204.png"> <img alt="h300" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231103113920.png"> 
<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/" rel="noopener" class="external-link" href="https://www.cloudflare.com/zh-cn/learning/dns/what-is-dns/" target="_blank">Cloudflare - 什么是DNS</a>
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/w/index.php?title=Domain_Name_System&amp;oldid=1182387275" rel="noopener" class="external-link" href="https://en.wikipedia.org/w/index.php?title=Domain_Name_System&amp;oldid=1182387275" target="_blank">Wikipedia - Domain Name System</a>
<br><a data-tooltip-position="top" aria-label="" rel="noopener" class="external-link" href="." target="_blank">Cloudflare - 什么是DNS记录</a>
<br>
<br>标识主机的两种方式：主机名 (hostname), IP 地址
<br>域名系统 (Domain Name System, DNS)的主要任务：进行 主机名到 IP 地址转换 的目录服务
<br>DNS<img alt="Pasted image 20231103150341.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231103150341.png">

<br>一个由分层的 DNS 服务器 (DNS server) 实现的分布式数据库
<br>一个能够使得主机能够查询分布式数据库的应用层协议
<br>运行在 UDP 上，使用 53 号端口


<br>DNS 通常是由其他应用层协议所使用的，包括 HTTP、SMTP 和 FTP 将用户提供的主机名解析为 IP 地址
<br>DNS 还提供一些重要的服务

<br>主机别名 (host aliasing)
<br>邮件服务器别名 (mail server aliasing)
<br>负载分配 (load distribution) ⬇️
<br><img alt="Pasted image 20231103154100.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231103154100.png" style="width: 300px; max-width: 100%;">


<br>在&nbsp;<a data-tooltip-position="top" aria-label="https://www.cloudflare.com/learning/dns/dns-records/" rel="noopener" class="external-link" href="https://www.cloudflare.com/learning/dns/dns-records/" target="_blank">DNS 记录</a>的环境中，TTL (单位 second) 是一个数值，它确定 DNS 缓存服务器在连接到权威性 DNS 服务器并获取记录的新副本之前可以为 DNS 记录提供服务的时间
<br><br><img alt="Pasted image 20231106084448.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231106084448.png"><br>
<br>前 12 字节：首部区域

<br>标识符：用于标识查询，会被复制到对查询的回答报文中 (16 bit)
<br>标志字段：(16 bit)
<br>有关数量的字段：问题数，回答 RR 数，权威 RR 数，附加 RR 数（对应下方的问题区域和回答区域，各 16 bit）


<br>问题区域：

<br>名字字段：包含正在被查询的主机名字
<br>类型字段：指出有关该名字正在被询问的问题类型
<br>Class 字段：主要用来指定网络类别


<br>回答区域：包含了对最初请求的名字的资源记录
<br>
标志字段格式

<br>
问题 RR 格式

<br>
回答 RR 格式

<br><br>
<br>注册登记机构 (registrar) 是一个商业实体，它验证该域名的唯一性，将该域名输入 DNS 数据库（如下面所讨论的那样），对提供的服务收取少量费用。
<br>因特网名字和地址分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN) 向各种注册登记机构授权
<br>当注册一个域名时并提供 Web 和 Mail 服务时

<br>向域名登记注册机构提供基本和辅助权威服务器的名字和 IP 地址
<br>向权威 DNS 服务器中插入 Web 服务器 <a data-tooltip-position="top" aria-label="http://www.example.com" rel="noopener" class="external-link" href="http://www.example.com" target="_blank">www.example.com</a> 的类型 A 资源记录和用于邮件服务器 mail.example.com 的 MX 资源记录


<br><br>
<br>在本节中我们将研究一个非常自然的 P2P 应用，即从单一服务器向大量主机 (称为对等方) 分发一个大文件
<br>在 P2P 文件分发中，每个对等方能够向任何其他对等方重新分发它已经收到的该文件的任何部分，从而在分发过程中协助该服务器
<br><br>
<br>考虑一个用于两种体系结构类型的简单定量模型，将一个文件分发给一个固定对等方集合 <img alt="Pasted image 20231106155558.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231106155558.png" style="width: 500px; max-width: 100%;">
<br> 服务器的上载速率， 第 i 对等方接入链路的上载速率， 第 i 对等方接入链路的下载速率
<br> 被分发的文件长度， 要获得的该文件副本的对等方的数量
<br>分发时间 (distribution time)：所有 N 个对等方得到该文件副本所需要的时间
<br>假设互联网核心具有足够的带宽，服务器和客户端没有参加任何其他网络应用，所有上传和下载访问贷款能被全部用于分发该文件
<br><br>
<br>服务器必须向  个对等方的每个传输该文件的一个副本。因此该服务器必须传输  比特。因为该服务器的上载速率是 , , 分发该文件的时间必定是至少为 
<br>令  表示具有最小下载速率的对等方的下载速率，即 。具有最小下载速率的对等方不可能在少于  秒时间内获得该文件的所有 F 比特。因此最小分发时间至少为 
<br>观察得到 
<br>对于足够大的 N，客户-服务器分发时间由  确定，所以分发时间随着对等方  的数量线性增加
<br><br>
<br>该服务器必须经过其接入链路至少发送该文件的每个比特一次，最小分发时间至少是 
<br>具有最低下载速率的对等方不能以小于  秒的分发时间获得所有  比特
<br>系统整体的总上载能力等于服务器的上载速率加上每个单独的对等方的上载速率， ，系统必须向这  个对等方的每个交付  比特，总共交付  比特，且不能以快于  的速率完成，因此最小的分发时间至少是 
<br>同上得
<br>如果我们认为一旦每个对等方接收到一个比特就能够重分发一个比特的话，则存在一个重新分发方案能实际取得这种下界
<br>假设所有对等方具有相同的上载速率 ，设置  小时，， <img alt="Pasted image 20231106172311.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231106172311.png" style="width: 500px; max-width: 100%;">
<br>对于 P2P 体系结构最小分发时间不仅总是小于客户－服务器体系结构的分发时间，并且对于任意 0.5 的对等方数量 N, 总是小于 1 小时
<br><br>
<br>术语

<br>洪流 (torrent)：参与一个特定文件分发的所有对等方的集合
<br>洪流中的对等方彼此下载等长度的文件块 (chunk)
<br>追踪器 (tracker)：每个洪流具有的基础设施节点，当一个对等方加入某洪流时，它向追踪器注册自己，并周期性地通知追踪器它仍在该洪流中。以这种方式，追踪器跟踪参与在洪流中的对等方
<br>疏通 (unchoked)：使数据的发送和接收流畅进行的对等方


<br>领近对等方：新对等方加入洪流时，追踪器随机从参与对等方的集合中选择对等方的一个子集，并将这些对等方的 IP 地址发送给 Alice，Alice 持有对等方的这张列表，试图与该列表上的所有对等方创建并行的 TCP 连接，所有这样与 Alice 成功地创建一个 TCP 连接的对等方为＂邻近对等方”
<br>最稀缺优先 (rarest first) 技术：针对 Alice 没有的块在她的邻居中决定最稀缺的块（最稀缺的块就是那些在她的邻居中副本数量最少的块），并首先请求那些最稀缺的块
<br><br>
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Dynamic_Adaptive_Streaming_over_HTTP" target="_blank">Wikipedia - Dynamic Adaptive Streaming over HTTP</a>
<br>
<br>视频媒体：视频是一系列的图像，通常以一种恒定的速率  (如每秒 24 或 30 张图像) 来展现。一幅未压缩、数字编码的图像由像素阵列组成，其中每个像素是由一些比特编码来表示亮度和颜色。视频的一个重要特征是它能够被压缩，因而可用比特率来权衡视频质量
<br>对流式视频最为重要的性能度量是端到端吞吐量
<br>HTTP 的动态适应流 (Dynamic Adaptive Streaming over HTTP, DASH)：视频编码为几个不同的版本，每个版本具有不同的比特率，对应于不同的质量水平。客户动态地请求来自不同版本且长度为几秒的视频段数据块。当可用带宽量较高时，客户自然地选择来自高速率版本的块；当可用带宽量较低时，客户自然地选择来自低速率版本的块。客户用 HTTP GET 请求报文一次选择一个不同的块
<br>HTTP 服务器存在一个告示文件 (manifest file)，为每个版本提供了一个 URL 及其比特率
<br><br>
<br><a data-tooltip-position="top" aria-label="http://ieeexplore.ieee.org/document/6195531/" rel="noopener" class="external-link" href="http://ieeexplore.ieee.org/document/6195531/" target="_blank">Unreeling netflix: Understanding and improving multi-CDN movie delivery</a><br>
<img alt="Pasted image 20231108103623.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108103623.png">
<br>
<br>提供流式视频服务建立单一大规模数据中心的问题

<br>用户远离数据中心，端到端吞吐量受瓶颈链路的吞吐量限制，若吞吐量小于视频消耗速率，容易产生停滞时延
<br>流行的视频可能经相同的通信链路发送多次
<br>单点故障，如果数据中心或其通向因特网的链路崩溃，它将不能够分发任何视频流


<br>内容分发网 (Content Distribution Network, CDN)：CDN 管理分布在多个地理位置上的服务器，在它的服务器中存储视频（和其他类型的 Web 内容，包括文档、图片和音频）的副本，并且所有试图将每个用户请求定向到一个将提供最好的用户体验的 CDN 位置
<br>CDN 服务器安置原则

<br>深入：该原则是通过在遍及全球的接入 ISP 中部署服务器集群来深入到 ISP 的接入网中，但因为这种高度分布式设计，维护和管理集群的任务成为挑战
<br>邀请做客：通过在少量关键位置建造大集群来邀请到 ISP 做客，邀请做客设计通常产生较低的维护和管理开销，可能以对端用户的较高时延和较低吞吐量为代价


<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://blog.skk.moe/post/i-have-my-unique-dns-setup/#Zhong-Chang-Xiu-Xi-Di-Gui-DNS-Shi-Zen-Me-Zhi-Dao-Na-Ge-CDN-Jie-Dian-Ju-Chi-Wo-Zui-Jin-De" rel="noopener" class="external-link" href="https://blog.skk.moe/post/i-have-my-unique-dns-setup/#Zhong-Chang-Xiu-Xi-Di-Gui-DNS-Shi-Zen-Me-Zhi-Dao-Na-Ge-CDN-Jie-Dian-Ju-Chi-Wo-Zui-Jin-De" target="_blank">Sukka - 我有特别的 DNS 配置和使用技巧</a>
<br>
<br>集群选择策略 (cluster selection strategy)：动态地将客户定向到 CDN 中的某个服务器集群或数据中心

<br>地理上最为领近 (geographically closest)

<br>一种所有基于 DNS 的方法都内在具有的问题是，某些端用户配置使用位于远地的 LONS
<br>就网络路径的长度或跳数而言，地理最邻近的集群可能并不是最近的集群


<br>实时测量 (real-time measurement)

<br>CDN 能够让它的每个集群周期性地向位于全世界的所有 LDNS 发送探测分组
<br>但是许多 LDNS 被配置为不会响应这些探测




]]></description><link>campus/chinese-notes/计算机科学/计算机网络/应用层.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/应用层.md</guid><pubDate>Fri, 22 Dec 2023 11:04:20 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231023191228.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231023191228.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[网络层-控制平面]]></title><description><![CDATA[ 
 <br><br>
<br>控制平面不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理
<br>OSPF 是一种运行在单一 ISP 网络中的路由选择算法，BGP 是一种在因特网中用于互联所有网络的路由选择算法
<br><br>
<br>计算、维护和安装转发表与流表的方法：

<br>每路由器控制：每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值，OSPF 和 BGP 协议都基于这种方法 
<br>逻辑集中式控制：<a data-tooltip-position="top" aria-label="网络层-数据平面 > ^7fd436" data-href="网络层-数据平面#^7fd436" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^7fd436" class="internal-link" target="_self" rel="noopener">通用转发</a> 允许执行除了传统 IP 转发外的其他功能，这些功能原来通常是在单独的<a data-tooltip-position="top" aria-label="网络层-数据平面 > ^cebafe" data-href="网络层-数据平面#^cebafe" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^cebafe" class="internal-link" target="_self" rel="noopener">中间盒</a> 中实现的


<br>每路由器控制和逻辑集中式控制之间的关键差异：路由器中的控制组件能否相互交互并主动参与计算转发表 <img alt="Pasted image 20231122115215.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122115215.png">
<br>逻辑集中式控制路由选择控制服务出于容错和性能扩展性的原因，很可能由多个服务器实现
<br><br>
<br>路由选择算法 (routing algorithm) 的目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径 <img alt="Pasted image 20231122120530.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122120530.png">
<br>图 (graph)  是一个  个节点和  条边的集合，每条边是取自  的一对节点，用  表示连接节点  和  边的开销，如果  不属于 ，则  ，如果属于  则节点  为节点  的领居(neighbor)  <img alt="Pasted image 20231122161720.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122161720.png" style="width: 400px; max-width: 100%;">
<br>路由选择算法的目标找出从源到目的地间的最低开销路径 (least-cost path)，若图中的所有边具有相同的开销，则最低开销路径也是最短路径 (shortest path)
<br>路由选择算法分类：

<br>根据集中式还是分散式

<br>集中式路由选择算法(centralized routing algorithm)：用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径，具有全局状态信息的算法常被称作链路状态 (Link State, LS) 算法
<br>分散式路由选择算法(decetralized routing algorithm)：路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息，之后学习的距离向量 (Distance-Vector, DV) 算法就是分散式路由选择算法


<br>根据静态的还是动态的

<br>静态路由选择算法(static routing algorithm)：路由随时间变化慢，通常是人工调整
<br>动态路由选择算法(dynamic routing algorithm)：随着网络流量负载或拓扑发生变化而变化


<br>根据负载敏感还是负载迟钝

<br>负载敏感算法(load-sensitive algorithm)：链路开销动态变化以反映出底层链路的当前拥塞水平
<br>负载迟钝算法(load-insentitive algorithm)：链路开销不明确反映拥塞水平




<br><br>
<br>实践中是让每个节点向网络中的所有其他节点广播链路状态分组来实现 (链路状态广播 link state broadcast 算法)
<br>所有节点都拥有网络的完整视图
<br>Dijkstra 算法 [@TuWenXiangJieDijkstraZuiDuanLuJingSuanFa2021][@DijkstraAlgorithm2023]：计算从某节点到达网络中所有其他节点的最低开销路径 <img style="max-width:800px; " class="excalidraw-svg excalidraw-embedded-img excalidraw-canvas-immersive" src="blob://7a382303-c398-48b2-bbc1-447c9a24444f" filesource="Campus/Chinese-Notes/计算机科学/计算机网络/Excalidraw/Dijkstra.excalidraw.md" w="800" draggable="false" oncanvas="false">

<br>经过算法的  次迭代后，可知道  个目的节点的最低开销路径


<br>当 LS 算法中止时，对于每一个节点，都可以得到从源节点沿着最低开销路径的前一节点 (可回溯)，通过对每个目的节点存放从  到目的地的最低开销路径上的下一跳节点，从而可以构建转发表 <img alt="Pasted image 20231123163847.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231123163847.png" style="width: 600px; max-width: 100%;">
<br>拥塞敏感的路由选择的振荡 <img alt="Pasted image 20231123165211.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231123165211.png">

<br>考虑图中的情况，节点  和  向节点  发出造成链路开销为 1 的流量，节点  向节点  发出开销为 e 的流量了
<br>如果路由选择算法拥塞敏感，则在第二次接收到同样开销的流量运行 LS 算法时，节点  会根据第一次的链路开销选择 y -&gt; z -&gt; w 的路径，由于在第一次情况下 y -&gt; x -&gt; w 总开销为  而 y -&gt; z -&gt; w 的总开销只有  ，相类似的节点  和  都会选择顺时针方向发送流量
<br>同样当第三次执行 LS 算法时所有的流量均逆时针发出，第四次则全为顺时针，造成振荡
<br>防止这种情况出现的方法是让所有的路由器在同一周期的不同时刻运行 LS 算法，但是在运行一段时间后路由器会发生自同步现象，避免这种现象的方法是让每台路由器发送链路通告的时间随机化


<br><br>
<br>分布式：每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居
<br>迭代：此过程一直要持续到邻居之间无更多信息要交换为止
<br>异步：不要求所有节点相互之间步伐一致地操作
<br>Bellman-Ford 方程 

<br>遍历  的所有相邻节点 ，从  到  的最低开销时所有相邻节点  的  的最小值 (待补充)
<br>令  为取得方程最小值的相邻节点，若节点  要沿着最低开销路径向节点  发送一个分组，它应当先向  发送分组，所以节点  的转发表指定节点  作为下一跳路由器


<br>使用 DV 算法，每个节点维护一个下列路由选择信息

<br>到所有相邻节点的开销  
<br>节点  的距离向量  包含  到  中所有目的地  的开销估计值，注意  只是该距离向量的一个分量 (之后的叙述中可能会将这两个概念混淆，因为发送的是完整的距离向量，然而在下文的例子中通常只更新其中一个分量)
<br>每个邻居的距离向量 


<br>每个节点不时向每个邻居发送距离向量，当节点  从任何一个邻居  接收到新距离向量时，它保存该距离向量，然后使用 Bellman-Ford 方程更新自己的距离向量，如果  的距离向量发生了变化，则  向所有的邻居发送更新后的距离向量，从而让所有邻居更新自身的距离向量，只要所有的节点以异步方式交换自己的距离向量，则每个开销估计值  会收敛到  (节点  到节点  的最低开销路径的开销)
<br>为了一个给定路径  而更新转发表，节点  关注的是沿着最短路径到  的下一跳路由器邻居节点  
<br><br>
<br>如果运行 DV 算法的节点检测到从自己到邻居的链路开销发生变化时，它就更新自己的距离向量，如果到该邻居的距离向量分量发生了变化，则向所有邻居通知新的距离向量
<br>路由选择环路 (routing loop) <img alt="Pasted image 20231124103355.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231124103355.png" style="width: 500px; max-width: 100%;">

<br>假设链路开销变化时，，，， ，则  时刻当  检测到链路开销变化时 (从开销 4 变为 60)， 计算到  的新的距离向量的分量 y -&gt; x -&gt; x 和 y -&gt; z -&gt; x 相比较 
<br>这时遇到了路由选择环路，发出的分组为了到达  ， 认为应该向  转发，而  认为应该向  转发，分组于是在这两个节点之间不停地来回反复
<br>此时节点  计算出  所以在  时刻将更新后的距离向量告诉 
<br>在  时刻， 收到  的新距离向量，指示了  到  的最低开销是 6 ， 计算到  的最低开销  (这时  已经知道了 z -&gt; x 的链路开销发生了变化)，并在计算完后  时刻通知  其新开销
<br>当  在  时刻收到  的通知时，计算到  的最低开销  并向  发送距离向量，随后  计算得到  并向  发送距离向量
<br>如此反复直到  向  发送距离向量  ，此时  到  的最低开销链路切换为 z —&gt; x，再发送接收一个迭代后，进入静止状态，此时为了让分组到达  ， 会直接选择直接向  转发，路由选择环路状态结束


<br><br>
<br>如果  通过  路由选择到目的地  ，则  将通告    ，此时  相信  没有到  的路径，通过这个善意的谎言， 将不会试图经由  路由选择到  
<br> 更新其距离向量，分量  ，并将新的距离向量发送给  
<br>此时  更新距离向量并通知   
<br>收到  的更新后  用  更新距离表，但是为了毒化逆向路径， 向  通告 
<br>注意如果涉及 3 个或更多节点无法用毒性逆转技术检测
<br><br>
<br>LS 要求每个节点通过广播与所有节点通信，但只告诉所有节点与该节点之间相连的链路开销，以便确定全局信息
<br>DV 中每个节点仅与所有相邻节点通信，但为相邻节点提供了自己到网络中所有节点的最低开销估计
<br>LS 算法的的复杂性为 
<br>LS 由于各节点执行各自的计算，提供了一定程度的健壮性，而 DV 算法一个不正确的节点计算值会扩散到整个网络
<br><br>
<br>实践中上文介绍的模型有一些简单化，原因有

<br>规模：随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现
<br>管理自治：在理想情况下，一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来


<br>自治系统 (Autonomous System, AS)：每个 AS 由一组通常处在相同管理控制下的路由器组成，ISP 可将其网络划分为一个或多个 AS ，AS 号由 ICANN 所分配<img alt="Pasted image 20231128111008.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231128111008.png">
<br>在一个 AS 中运行的路由选择算法叫做自治系统内部路由选择协议 (intra-autonomous system routing protocol)
<br>开放最短路优先 (OSPF) 是一种链路状态协议[@moyOSPFVersion1998]，使用洪泛链路状态信息和 Dijkstra 最低开销路径算法，路由器构建了关于整个自治系统的完整拓扑图，通过 Dijkstra ，路由器可以确定一个以自身为根节点到所有子网的最短路径树
<br>各条链路的开销可以由网络管理员配置，但 OSPF 不强制使用设置链路权值的策略

<br>将每条链路开销设置为 1 可以实现最少跳路由选择
<br>将链路权值与链路容量设为反比，不鼓励流量使用低带宽链路


<br>使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息

<br>每当链路的状态发生变化，路由器广播链路状态信息
<br>链路的状态不发生变化，路由器也要周期广播链路状态，可以增加链路状态算法的健壮性


<br>OSPF 协议报文直接由 IP 承载，所以 OSPF 需要自己实现可靠报文传输，链路状态广播等功能
<br>OSPF 的优点

<br>安全：使用鉴别机制
<br>多条相同开销的路径
<br>对单播和多播路由选择的总和支持
<br>支持在单个 AS 中的层次结构：在每个区域内，一台或多台区域边界路由器向该区域内所有其他路由器广播其链路状态


<br><br>
<br>分组跨越多个 AS 进行路由时，需要自治系统间路由选择协议 (inter-autonomous system routing protocol)
<br>因特网中，所有的 AS 运行相同的 AS 间选择协议，称为边界网关协议 (Broader Gateway Protocol, BGP)
<br><br>
<br>对于相同 AS 中的目的地而言，在路由器转发表中的表项由 AS 内部路由选择协议决定
<br>BGP 中分组不是路由到一个特定的目的地址，而是路由到 <a data-tooltip-position="top" aria-label="网络层-数据平面 > ^821595" data-href="网络层-数据平面#^821595" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^821595" class="internal-link" target="_self" rel="noopener">CIDR</a> 化的前缀
<br>BGP 为每台路由器提供了一种完成以下任务的手段

<br>从邻居 AS 获得前缀的可达性信息
<br>确定该前缀的"最好的"路由


<br><br><img alt="Pasted image 20231127104059.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231127104059.png"><br>
<br>对于每个 AS ，每台路由器要么是一台网关路由器 (gateway router)，要么是一台内部路由器 (internal router)，网关路由器位于 AS 边缘，内部路由器仅连接自己 AS 中的主机和路由器[@ShiMeShiBGPBGP]
<br>从高层次 (AS) 上考虑，若要向所有路由器通告前缀  的可达性信息

<br>AS3 向 AS2 发送一个 BGP 报文 AS3 x，告诉  存在并位于 AS3 中
<br>AS2 向 AS1 发送一个报文 AS2 AS3 x，告诉  存在可通过 -&gt; AS2 -&gt; AS3 的途径到达 


<br>BGP 中，每对路由器通过使用 179 端口的半永久 (?) TCP 交换路由选择信息
<br>每条之间连接以及通过该连接发送的 BGP 报文称为 BGP 连接 (BGP Connection)，跨越两个 AS 的 BGP 连接称为外部 BGP (eBGP)连接，相同 AS 中的两台路由器之间的会话被称为内部 BGP (iBGP) 连接，每个路由器之间还有多条 iBGP 连接，应该指出的是，使用 iBGP 并非使用 eBGP 的前提条件。自治系统可从多种内部协议中选择，来连接内部网络上的路由器 <img alt="Pasted image 20231127110509.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231127110509.png">
<br>再次考虑上述过程

<br>路由器 3a 先向网关路由器 2c 发送一个 eBGP 报文 AS3 x
<br>网关 2c 向 AS 中所有其他路由器发送 iBGP 报文 AS3 x
<br>网关 2a 向 1c 发送一个 eBGP 报文 AS2 AS3 x
<br>网关 1c 向 AS1 中所有路由器发送 iBGP 报文 AS2 AS3 x


<br>实际网络中从某个给定的路由器到目的地可能有多条不同的路径
<br><br>
<br>路由器通过连接通告前缀时，在前缀中包括一些 BGP 属性 (BGP  attribute)
<br>按 BGP 术语来说，前缀及其属性称为路由 (route) 

<br>AS-PATH：包含了通告已经通过的 AS 的列表，如果路由器在路径列表中看见了包含自己的 AS 则会拒绝该通告，以防止环路
<br>NEXT-HOP：AS-PATH 从左到右起始的路由器接口的 IP 地址，即最后经过的 AS (AS2) 的网关路由器出端口的 IP 地址，虽然是不属于当前 AS (AS1) 的路由器的 IP 地址，但是包含该 IP 地址的子网直接连接到 AS1


<br>一段实际的 BGP 消息 <img alt="Pasted image 20231127172612.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231127172612.png">
<br>BGP Message
    Type: UPDATE Message
    Path Attributes:
        Path Attribute - Origin: IGP
        Path Attribute - AS_PATH: 64500 64496
        Path Attribute - NEXT_HOP: 198.51.100.1
        Path Attribute - COMMUNITIES: 64500:13335
        Path Attribute - Multi Exit Discriminator (MED): 100
    Network Layer Reachability Information (NLRI):
        192.0.2.0/24
Copy<br><br>
<br>运行热土豆路由选择算法的路由，当路由器收到到达前缀 x 的多条 BGP 路由时，通过 AS 内部路由选择信息选择到达每个网关的最低开销路径 (几个网关就有几条)，并选择这些路径中具有最低开销的那条，将通往这条路径的接口 I 的转发表项 (x, I) 加入转发表中 <img alt="Pasted image 20231128095437.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231128095437.png">
<br>热土豆路由选择是自私的算法，试图减小在自身 AS 中的开销，尽可能快地以最低开销将分组送出自身 AS 
<br><br>
<br>对于任何给定的目的地前缀，进入 BGP 的路由选择输入是到某前缀的所有<a data-tooltip-position="top" aria-label="网络层-控制平面 > ^a1cf89" data-href="网络层-控制平面#^a1cf89" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-控制平面.html#^a1cf89" class="internal-link" target="_self" rel="noopener">路由</a>的集合，如果到相同的前缀有一条这样的路由，BGP 选择该路由，如果有多条这样的路由，则顺序地调用下列消除规则直到只剩一条路由 <img alt="Pasted image 20231128100312.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231128100312.png">

<br>Local-preference：取决于网络管理员的设置，可能由路由器设置或从相同 AS 中的其它路由器学习到
<br>AS-PATH：从具有相同的 local-preference 的路由中，选择具有最短 AS-PATH 的路径，如果该规则是路由选择的唯一规则，BGP 使用<a data-tooltip-position="top" aria-label="网络层-控制平面 > DV 算法" data-href="网络层-控制平面#DV 算法" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-控制平面.html#DV_算法" class="internal-link" target="_self" rel="noopener">距离向量算法</a>决定路径，其中距离测度使用 AS 跳的跳数而不是路由器跳的跳数
<br>Hot Potato Routing (图中没有呈现)：选择最靠近 NEXT-HOP 路由器的路由
<br>其他 BGP 标识符


<br><br><img alt="Pasted image 20231128101839.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231128101839.png"><br>
<br>动机

<br>在许多分散的不同地理位置，替换不同服务器上的相同内容
<br>让每个用户从最靠近的服务器访问内容


<br>配置时，CDN 公司为多台服务器指派相同的 IP 地址，并使用标准 BGP 从这些服务器的每台来通告 IP 地址，当 BGP 路由器收到对该 IP 地址的多个路由通告，他将这些通告处理为对相同的物理位置提供不用的路径，配置路由选择表时，路由器将本地化使用 <a data-tooltip-position="top" aria-label="网络层-控制平面 > 路由器选择算法" data-href="网络层-控制平面#路由器选择算法" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-控制平面.html#路由器选择算法" class="internal-link" target="_self" rel="noopener">BGP 路由选择算法</a> 找到到 IP 地址最好的路由
<br>当某客户请求视频时，CDN 向客户返回由地理上分散的服务器使用的共同的 IP 地址 (注意和<a data-tooltip-position="top" aria-label="应用层 > 集群选择策略" data-href="应用层#集群选择策略" href="/campus/chinese-notes/计算机科学/计算机网络/应用层.html#集群选择策略" class="internal-link" target="_self" rel="noopener">集群选择策略</a>区分)，最近的服务器是 BGP 路由选择算法定义的
<br>由于 BGP 路由选择的变化会导致 TCP 连接的不同分组到达 Web 服务器的不同实例，所以实践中 CDN 通常选择不使用 Anycast，但 IP 任播被广泛用于将 DNS 请求指向最近的 DNS 根服务器，Anycast 可以将请求路由到负责该地址的最近的 DNS 服务器
<br>不妨在页面上查找一下距离最近的 DNS 服务器
<br><br><br><img alt="Pasted image 20231128111424.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231128111424.png"><br><br>
<br>在路由选择算法中，首先根据本地偏好属性选择路由，本地偏好值由本地 AS 的策略决定
<br>如图所示的自治系统，假设 W X Y 是接入 ISP ，A B C 是主干提供商网络，并且彼此发送流量并向客户网络提供全部的 BGP 信息，所有进入一个接入 ISP 网络的流量必定是以该网络为目的地，所有离开一个接入 ISP 网络的流量必定源于该网络<img alt="Pasted image 20231128142543.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231128142543.png">
<br>X 是一个<a data-tooltip-position="top" aria-label="因特网 > ^2dad47" data-href="因特网#^2dad47" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^2dad47" class="internal-link" target="_self" rel="noopener">多宿</a>接入 ISP，X 如果向 B 和 C 通告它没有通向除自身外任何其他目的地的路径，那么它将起到一个接入 ISP 的作用
<br>商业 ISP 遵从的经验法则：任何穿越某 ISP 主干网的流量必须是其源或者目的 (或两者) 位于该 ISP 的某个网络中
<br><br>
<br>SDN 体系结构的四个关键特征

<br>基于流的转发
<br>数据平面和控制平面分离：网络交换机在流表中执行"匹配加动作"规则，控制平面由服务器和决定管理交换机流表的软件组成
<br>网络控制功能：控制平面自身由 SDN 控制器和网络控制应用程序组成
<br>可编程的网络


<br>SDN 中数据平面交换机、SDN 控制器和网络控制应用程序是分离的实体，可以由不同的厂商和组织机构提供
<br><br>
<br>控制器的功能层次

<br>通信层：SDN 控制器和受控设备间的通信，设备需要想控制器传递本地观察到的事件，通过"南向"接口与受控设备通信
<br>网络范围状态管理层
<br>对于网络控制应用程序层的接口 ：通过"北向"接口与网络控制应用程序交互，允许网络控制应用程序在状态管理层之间读 / 写网络状态和流表


<br>出于故障容忍、高可用性或性能等方面的考虑，在实践中这些服务和用于保持状态信息的数据库一般通过分布式服务器集合实现
<br><br>
<br>OpenFlow 协议运行在 SDN 控制器和 SDN 控制的交换机或其他实现 OpenFlow API 的设备之间
<br>OpenFlow 协议运行在 TCP 之上，使用 6653 默认端口号
<br>在控制器 -&gt; 受控交换机流动的重要报文

<br>配置：设置交换机的配置参数
<br>修改状态：增加 / 删除或修改交换机流表中的表项，并设置交换机的端口特性
<br>读状态：从交换机的流表和端口手机统计数据和计数器值
<br>发送分组：令受控交换机在特定的端口发送一个特定的报文


<br>从受控交换机 -&gt; 控制器流动的报文 

<br>流删除：通知控制器已删除一个流表项
<br>端口状态：向控制器通知端口状态变化 
<br>分组入：<a data-href="网络层-数据平面#动作" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#动作" class="internal-link" target="_self" rel="noopener">网络层-数据平面 &gt; 动作</a> 到达交换机端口的分组不能与任何流表项匹配，分组会被发送给控制器进行额外处理


<br><br><img alt="Pasted image 20231129100416.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231129100416.png" style="width: 500px; max-width: 100%;"><br>
<br>与 <a data-tooltip-position="top" aria-label="网络层-控制平面 > ^2d047c" data-href="网络层-控制平面#^2d047c" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-控制平面.html#^2d047c" class="internal-link" target="_self" rel="noopener">每路由器控制</a> 不同的是，在上图的 SDN 场景中

<br>Dijkstra 算法作为一个单独的程序执行，位于分组交换机外部
<br>分组交换机相 SDN 控制器发送链路更新且不相互发送


<br>假设路由器 S1 和 S2 之间的链路状态发生变化

<br>S1 经历了链路故障，通过<a data-tooltip-position="top" aria-label="网络层-控制平面 > ^47cfcb" data-href="网络层-控制平面#^47cfcb" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-控制平面.html#^47cfcb" class="internal-link" target="_self" rel="noopener">端口状态</a>报文通知 SDN 控制器链路状态的更新
<br>SDN 控制器接收到了报文，通告链路状态管理器更新链路状态库
<br>Dijkstra 链路状态路由选择应用程序进行了注册，当链路状态更新时，应用程序接收到关于链路状态更新的通告
<br>应用程序与链路状态管理器相互作用，得到更新的链路状态，参考状态管理层中的其他组件，计算新的最低开销路径
<br>链路状态路由选择应用于流表管理器交互，流表管理器决定更新的流表
<br>流表管理器使用 OpenFlow 协议报文更新 s1、s2 和 s4 的流表


<br><br>
<br>ICMP 的典型用途是差错报告
<br>ICMP 报文作为 IP 有效载荷承载
<br>ICMP 大部分类型报文格式 (详见 RFC )
<br>	0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |     Code      |          Checksum             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                             unused                            |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |      Internet Header + 64 bits of Original Data Datagram      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Copy<br>
<br>Traceroute 用 ICMP 报文实现，在应用 nexttrace 中向目的地主机发送一系列 ttl 递增的 ICMP 报文，当第 n 和数据报到达第 n 台路由器时，数据报 TTL 过期，路由器丢弃数据报并回送一个 ICMP 告警报文 (Type 11 Code 0) ，当数据报到达目的地目的主机会送一个 ICMP 回显报文 (Type 0 Code 0)，程序不再发送探测分组 <img alt="Pasted image 20231129115455.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231129115455.png"> <img alt="Pasted image 20231129115749.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231129115749.png"> <img alt="Pasted image 20231129115525.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231129115525.png">
<br>RFC 4443 [@guptaInternetControlMessage2006] ，新增了 IPv6 所需的新类型和编码，包括"分组太大"类型和"未被承认的 IPv6 选项"差错编码
<br><br>
<br>网络管理的定义：网络管理包括了硬件、软件和人类元素的设置、综合和协调，以监视、测试、轮询、配置、分析、评价和控制网络及网元资源，用合理的成本满足实时性、运营性能和服务质量的要求
<br><br><img alt="Pasted image 20231129154719.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231129154719.png" style="width: 500px; max-width: 100%;"><br>
<br>管理服务器 (managing server)：运行在网络运营中心 (NOC) 的集中式网络管理工作站上，执行网络管理活动
<br>被管设备 (managed device)：一个被管设备包含几个被管对象 (managed object)，被管对象可以是被管设备中硬件的实际部分或用于这些硬件及软件组件的配置参数
<br>管理信息库 (Management Information baseBase, MIB)：收集被管设备中每个被管对象的关联信息，MIB 对象由称为 SMI (Structure of Management Information) 的数据描述语言所定义
<br>网络管理代理 (network management agent)：与管理服务器通信，在管理服务器的命令和控制下在被管设备中采取本地动作
<br>网络管理协议 (network management protocol)
<br><br>
<br>简单网络管理协议 (Simple Network Management Protocol)：应用层协议，用于在管理服务器和代理之间传递网络管理控制和信息报文
<br>最常使用的是请求响应模式，SNMP 管理服务器向 SNMP 代理发送一个请求，代理收到请求后，执行动作并回送报文
<br>代理向服务器发送陷阱报文 (trap message)，用于通知管理服务器异常的发生导致了 MIB 对象值的改变
<br>SNMP 报文类型如下 <img alt="Pasted image 20231129160250.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231129160250.png">

<br>报文一般被称为协议数据单元 (PDU)
<br>GetRequest、GetNextRequest 和 GetBulkRequest PDU 都是由管理服务器向代理发送，用于请求一个或多个 MIB 对象值
<br>管理服务器使用 SetRequest PDU，来设置被管设备的一个或多个 MIB 对象值，代理用带有"noError"的 Response PDU 进行应答
<br>InformRequest PDU 用于通知另一个 MIB 信息管理服务器
<br>陷阱报文异步产生，为了响应管理服务器要求的事件


]]></description><link>campus/chinese-notes/计算机科学/计算机网络/网络层-控制平面.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/网络层-控制平面.md</guid><pubDate>Fri, 22 Dec 2023 11:04:20 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122115215.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122115215.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[网络层概述]]></title><description><![CDATA[ 
 <br><br>
<br>网络层的分解

<br>数据平面
<br>控制平面


<br>数据平面功能:网络中每台路由器的功能，决定到达路由器输入链路之一的数据报如何转发到该路由器的输出链路之一

<br>传统 IP 转发 (转发基于数据报的目的地址)
<br>通用转发 (使用数据报首部中几个不同域执行转发和其他功能)


<br>控制平面功能:网络范围的逻辑，控制数据报沿着从源主机沿着到目的主机的端到端路径中路由器的路由方式

<br>路由选择算法


<br>软件定义网络(Software-Defined Networking, SDN):将控制平面功能作为一种单独服务，明确地分离数据平面和控制平面
<br><br>
<br>转发(forwarding):将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作

<br>数据平面中实现的唯一功能
<br>分组有可能被现有的路由器阻挡也有可能冗余的经过多条链路发送


<br>路由选择(routing):确定分组从源到目的地所采取的端到端路径的网络范围处理过程，通常用软件来实现

<br>路由选择算法(routing algorithm):计算分组从发送方流向接收方时采用的路由或路径
<br>在控制平面中实现


<br>转发表(forwarding table):路由器检查到达分组首部的一个或多个字段值，进而使用这些首部值在其转发表中索引
<br>转发表的配置

<br>控制平面:传统方法

<br>路由选择算法决定了插入路由器转发表的内容，在一台路由器中的路由选择算法与其他路由器重的算法通信，计算出转发表的值


<br>控制平面:SDN方法<img alt="Pasted image 20231116172535.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231116172535.png">

<br>路由选择设备仅执行转发，而远程控制器计算并分发转发表




<br>软件定义网络 (Software-Defined Networking, SDN) 的本质：计算转发表并与路由器交互的控制器是用软件实现的 (控制器可能实现在具有高可靠性和冗余的远程数据中心中)
<br><br>
<br>网络服务模型(network service model)定义了分组在发送和接收端系统之间的端到端运输特性
<br>考虑几种网络层能提供的可能的服务：参考<a data-href="应用层#可供应用程序使用的运输服务" href="/campus/chinese-notes/计算机科学/计算机网络/应用层.html#可供应用程序使用的运输服务" class="internal-link" target="_self" rel="noopener">应用层 &gt; 可供应用程序使用的运输服务</a>

<br>确保交付
<br>具有时延上界的确保交付
<br>有序分组交付
<br>确保最小带宽
<br>安全性
<br>很遗憾的是，以上提到的服务，因特网的网络层一个也不提供，因特网的网络层提供了单一的服务，称为尽力而为服务 (best-effort service) 没有服务就是最好的服务


<br>尽力而为服务(best-effort service):因特网网络层提供的单一服务，传送的分组既不能保证以发送的顺序被接收，也不能保证最终交付，既不能保证端到端时延，也不能保证有最小的带宽
<br>⚠️转发和交换这两个术语经常被互换使用
<br>分组交换机:通用分组交换设备，根据分组首部字段中的值，从输入链路接口到输出链路接口转移分组

<br>链路层交换机(link-layer switch):基于链路层帧中的字段值做出转发决定
<br>路由器(router):基于网络数据报中的首部字段值做出转发决定


<br><br>
<br>路由器组件<img alt="Pasted image 20231117111524.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117111524.png">

<br>输入端口(input port)

<br>终结入物理链路的物理层功能
<br>与位于远端的数据链路层交互来执行数据链路层功能
<br>查询转发表决定路由器的输出端口
<br>控制分组从输入端口(指物理IO接口，与软件端口不同)转发到路由选择处理器


<br>交换结构:将路由器的输入端口连接到输出端口，这种交换结构时网络路由器中的网络
<br>输出端口:存储从交换结构接收的分组，通过执行必要的链路层和物理层功能在输出链路上传输这些分组(双向链路输出端口总是和输入端口成对出现在同一线路卡上)
<br>路由选择处理器:执行控制平面功能，

<br>传统路由器:执行路由选择协议，维护路由选择表与关联链路状态信息
<br>SDN 路由器:负责与远端控制器通信，接收由远程控制器计算的转发表项




<br>路由器的输入端口、输出端口和交换结构几乎总是用硬件实现
<br><br><img alt="Pasted image 20231117152150.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117152150.png" style="width: 500px; max-width: 100%;"><br>
<br>输入端口的线路端接功能与链路层处理实现了用于各个输入链路的物理层和链路层
<br>转发表从路由选择处理器经过独立总线 (eg. PCI) 复制到线路卡
<br>使用每个输入端口的影子副本，转发决策可在每个输入端口本地做出，避免了集中式处理瓶颈
<br>路由器通过前缀(prefix)匹配来转发分组，当有多个匹配时使用最长前缀匹配规则(longest prefix matching rule) 
<br>在吉比特速率下，查找转发表必须在纳秒级执行，需要对大型转发表使用超出简单线性搜索的技术，实践中常用三态内容可寻址存储器(Tenary Content Address Memory, TCAM) 来查找，使用 TCAM 一个 32 位 IP 地址可在常数时间内返回对应的转发表项 
<br>在某些设计中，如果来自其他输入输出端口的分组当前正在使用该交换结构，一个分组可能在进入交换结构时被阻塞，这个被阻塞的分组需要在输入端口处排队
<br>输入端口除了查找仍需要处理的事情

<br>物理层和链路层处理
<br>检查分组的版本号、检验和以及寿命字段，并重写最后两个字段
<br>更新用于网络管理的计数器


<br><br>
<br>路由器通过交换结构使分组实际地从一个输入端口交换到另一个输出端口中
<br>交换可以用许多方式完成：

<br>经内存交换 <img alt="Pasted image 20231117163834.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117163834.png" style="width: 400px; max-width: 100%;">

<br>最简单、最早的路由器使传统的计算机，输入端口和输出段口之间的交换是在 CPU (路由选择处理器) 的控制下完成的
<br>处理首部时分组需要被复制到内存中，所以转发吞吐量受到内存带宽限制
<br>共享系统总线一次只能执行一个内存读 / 写，所以不能同时转发两个分组
<br>现代路由器由输入线路卡查找目的地址和将分组存储进适当的内存存储位置


<br>经总线交换 <img alt="Pasted image 20231117163932.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117163932.png" style="width: 400px; max-width: 100%;">

<br>输入端口经一根共享总线将分组直接传送到输出端口
<br>输入端口为分组预先计划一个交换机内部标签，指示本地输出端口，分组被所有输出端口收到，但只有与该标签匹配的端口才能保存该分组
<br>一次只有一个分组能跨越总线，交换带宽受总线速率的限制


<br>经互联网络交换 <img alt="Pasted image 20231117163957.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117163957.png" style="width: 400px; max-width: 100%;">

<br>使用更复杂的互联网络能克服单一、共享式总线的带宽限制
<br>图中的纵横式交换机是由 2N 条总线组成的互联网络，交叉点通过交换结构控制器在任何时候能够开启和闭合
<br>纵横式交换机是非阻塞的 (non-blocking)，只要没有其他分组当前被转发到该输出端口，转发到输出端口的分组将不会被到达输出端口的分组阻塞，如果来自两个不同输入端口的两个分组其目的地为相同的输出端口，则一个分组必须在输入端等待




<br><br><img alt="Pasted image 20231117171654.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117171654.png" style="width: 500px; max-width: 100%;"><br>
<br>输出端口取出已经存放在输出端口内存中的分组并将其发送到输出链路上
<br><br>
<br>路由器在输入端口和输出端口处都能形成排队
<br>排队的位置和程度取决于流量负载、交换结构的相对速率和线路速率
<br>当无内存可用于存储到达的分组时会出现丢包 (packet loss)
<br><br>
<br>如果瓶颈在交换结构的吞吐量，那么在输入端口将出现分组排队
<br>考虑纵横式结构，假定：

<br>所有链路速度相同
<br>一个分组能以一条输入链路接收一个分组所用的时间量，从任意一个输入端口传送到给定的输出端口
<br>分组按 FCFS (First Come, First Served) 方式，若有两个分组被发往同一输出队列，其中的一个分组被阻塞


<br>线路前部阻塞 (Head-Of-the-Line, HOL) 阻塞：线路前部的另一个分组阻塞，则同一输出队列中排队的分组必须等待前部分组发送后才能发送 <img alt="Pasted image 20231117174816.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117174816.png" style="width: 500px; max-width: 100%;">
<br><br>
<br>在缓存已满时，需要做出决定

<br>丢弃到达的分组，采用弃尾 (drop-tail) 的策略
<br>删除一个或者多个已排队的分组


<br>主动队列管理 (Active Queue Management, AQM) 算法

<br>在缓存填满前丢弃一个分组，可以向发送方提供一个拥塞信号
<br>随机早期检测 (Random Early Detection, RED) 是得到最广泛研究和实现的 AQM 算法之一 <img alt="Pasted image 20231117191339.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231117191339.png" style="width: 300px; max-width: 100%;">


<br>当分组到达输出端口并排队时，输出端口的分组调度 (packet scheduler) 在排队分组中选择一个分组来传输
<br>路由器缓存长度的经验方法：缓存数量 (B) 应当等于平均往返时延 (RTT) 乘以链路的容量 (C)，最近的理论和试验表明，当有大量的 TCP 流 (N 条) 流过一条链路时，缓存所需要的量 
<br><br>
<br>先进先出 (First-In-First-Out, FIFO) <img alt="Pasted image 20231120094352.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120094352.png" style="width: 500px; max-width: 100%;">

<br>如果链路正忙于传输另一个分组，则到达链路输出队列的分组要排队等待传输
<br>如果没有足够的缓存来容纳到达的分组，队列的分组丢弃策略确定该分组是否将被丢弃，或者从队列中去除其他分组以便为到达的分组腾出空间
<br>FIFO (FCFS) 调度规则按照分组到达输出链路队列的相同次序来选择分组在链路上的传输<img alt="Pasted image 20231120113103.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120113103.png">


<br>优先权队列 (priority queuing) <img alt="Pasted image 20231120095614.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120095614.png" style="width: 500px; max-width: 100%;">

<br>到达输出链路的分组被分类放入输出队列中的优先权类
<br>优先权排队规则将从队列为非空的最高优先权类中传输一个分组
<br>在同一优先权类的分组之间的选择通常以 FIFO 方式完成
<br>下图使用的规则是非抢占式优先权排队 (non-preemptive priority queuing)，即一旦分组开始传输就不能打断，所以高优先权的分组 4 到达后需要先等待低优先权的分组 2 传输完成 <img src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120115846.png">


<br>循环加权公平排队

<br>在循环排队规则 (round robin queuing discipline) 下，类之间不存在严格的服务优先权，循环调度器在这些类之间轮流提供服务，下图当传输一个分组传输完成时，调度器查找循环序列中的下一个类<img alt="Pasted image 20231120120805.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120120805.png">
<br>保持工作排队 (work-conserving queuing) 规则：有任何类的分组等待传输时，不允许链路保持空闲，当寻找给定类的分组没有找到时，保持工作的循环规则将立即检查循环检查序列中的下一个类
<br>加权公平排队 (Weight Fair Queuing, WFQ) 规则 <img alt="Pasted image 20231120124017.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120124017.png" style="width: 500px; max-width: 100%;">

<br>到达的分组被分类并在适合的每个类的等待区域排队
<br>WFQ 调度器以循环方式为各个类提供服务
<br>WFQ 是一种保持工作排队规则，在发现一个空队列时，调度器立刻移向下一个类
<br>WFQ 和循环排队的区别是，每个类在任何时间间隔内可能收到不同数量的服务，第 i 类将确保收到的服务部分等于 ，对一条传输速率为 R 的链路，第 i 类能至少获得  的吞吐量




<br><br><br><img alt="Pasted image 20231120141624.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120141624.png" style="width: 500px; max-width: 100%;"> <img alt="Pasted image 20231120142719.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120142719.png"><br>
<br>IPv4 的数据报格式如图

<br>版本：4 比特，规定 IP 协议版本，IPv4 的版本号为 0100，IPv6 的版本号为 0110，通过查看版本号，路由器能确定如何解释 IP 数据报的剩余部分
<br>首部长度：4 比特，指定 IP 数据报首部长度，由于确定载荷的起始点，一般的 IPv4 数据报具有 20 字节的首部
<br>区分服务 (Differentiated Services, DS)：区分不同类型的 IP 数据报, 从而便于现代网络提供 Qos (quality of service)，IPv4 中前 6 位为区分服务代码点 (Differentiated Services Code Point，DSCP) [@DifferentiatedServices2023]，后 2 位被用于<a data-tooltip-position="top" aria-label="运输层 > 网络辅助拥塞控制" data-href="运输层#网络辅助拥塞控制" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#网络辅助拥塞控制" class="internal-link" target="_self" rel="noopener">显示拥塞通知 (Explicit Congestion Notification, ECN)</a>  

<br>DSCP
<br>ECN

<br>ECN-Capable Transport (ECT): 如果位 6 被设置，表明此数据报的传输已经做好拥塞遭遇的准备，也就是说，它可以承受网络中的拥塞而不需要丢弃数据报
<br>Congestion Experienced (CE) : 如果位 7 被设置，表明在网络路径中已经遇到拥塞，需要减少发送速率




<br>数据报长度：IP 数据报的总长度 (首部加上数据)，数据报长度字段的设计考虑到了以太网帧的最大传输单元  (MTU)，该长度确保一个 IP 数据报可以作为数据字段（也就是载荷）被完整地封装在一个以太网帧内部进行传输
<br>标识(Identification)、标志(Flags)、片偏移(Fragment Offset)：与 <a data-tooltip-position="top" aria-label="网络层-数据平面 > IPv4 数据报分片" data-href="网络层-数据平面#IPv4 数据报分片" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#IPv4_数据报分片" class="internal-link" target="_self" rel="noopener">IP 分片</a> 相关
<br>寿命(Time-To-Live, TTL)：确保数据报不会永远在网络中循环，每当一台路由器处理数据报时 TTL 减一，若 TTL 为 0，则该数据报必须丢弃
<br>协议：指示了 IP 数据报的数据部分应该交给哪个特定的运输层协议，可能值详见 <a data-tooltip-position="top" aria-label="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" rel="noopener" class="external-link" href="https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xhtml" target="_blank">IANA Protocol Numbers</a> ，协议号将网络层与运输层绑定到一起 
<br>首部检验和：计算方法同 <a data-href="运输层#检验和计算过程" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#检验和计算过程" class="internal-link" target="_self" rel="noopener">运输层 &gt; 检验和计算过程</a> ，因为每经过一台路由器 TTL 字段会改变，所以每台路由器上必须重新计算检验和并放回原处

<br>为什么运输层和网络层都执行差错检测？

<br>首先 IP 层只对 IP 首部计算检验和，而 TCP / UDP 是对整个报文段计算
<br>TCP / UDP 与 IP 不一定必须运行在同一个协议栈上




<br>源和目的IP地址：通常源主机通过 DNS 查找来决定目的地址
<br>选项：选项字段允许 IP 首部被扩展，IPv6 首部已经删除选项字段
<br>数据(有效载荷)：包含要交付给目的地的 <a data-tooltip-position="top" aria-label="运输层 > ^e40540" data-href="运输层#^e40540" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^e40540" class="internal-link" target="_self" rel="noopener">运输层报文段</a>，也可承载如 ICMP 报文等数据


<br><br>
<br>一个链路层帧能承载的最大数据量叫作最大传送单元 (Maximum Transmission Unit, MTU)，故 MTU 严格限制 IP 数据报的长度
<br>发送方与目的地路径上的每段链路可能使用不同的链路层协议，每段协议可能具有不同的 MTU
<br>当出链路的 MTU 比入链路小时，需要将 IP 数据报中的数据分片成两个或多个较小的 IP 数据报，用单独的链路层帧封装这些数据报(这些数据报被称为片, fragment)，再通过输出链路发送这些帧
<br>坚持网络核心保持简单的原则，IPv4 设计者决定将数据报重新组装的工作放到端系统中
<br>目的主机收到一系列数据报时，需要确定数据报中的某些是否是一些原来较大的数据报的片，如果是的话需要将这些片重新组装成数据报
<br>IP 是不可靠服务，源主机发送的不同数据报具有不同的 标识号，分片后通过 偏移字段 指定该片放在初始 IP 数据报的哪个位置，并将最后一个片的 标志 比特设置为 0 ，其他片的 标志 比特设置为 1
<br>图中 4000 字节的数据报到达路由器需要被转发到一条 MTU = 1500B 的链路上，初始数据报中 3980 字节数据必须被分配为 3 个独立的片 <img alt="Pasted image 20231120162427.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120162427.png" style="width: 500px; max-width: 100%;">
<br><br>
<br>接口 (interface)：主机与物理链路之间的边界
<br>路由器的任务是从链路上接收数据报并从某些其他链路转发出去，路由器必须拥有两条或更多条链路与它连接
<br>一个 IP 地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联
<br>IPv4 地址通常用点分十进制记法 (dotted-decimal notation) 书写
<br>除了在 NAT 后的接口外，全球因特网中的每台主机和路由器的每个接口，都必须有一个全球唯一的 IP 地址
<br>图中的 223.1.1 开头的接口通过一台以太网交换机或一个无限接入点互联，形成一个字网 (subnet)，223.1.1.0/24 的左侧 24 比特定义了子网地址，/24 为子网掩码，任何连接到该子网的主机都需要具有 223.1.1.xxx 形式  <img alt="Pasted image 20231120163855.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120163855.png" style="width: 700px; max-width: 100%;">
<br>定义子网的方法：为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点，这些隔离的网络中的每一个都叫作一个子网 (subnet)
<br>下图有 6 个子网，分别是 223.1.1.0/24 223.1.2.0/24 223.1.3.0/24 223.1.9.0/24 223.1.8.0/24 223.1.7.0/24 <img alt="Pasted image 20231120165446.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120165446.png" style="width: 700px; max-width: 100%;">
<br>无类别域间路由选择 (Classless Interdomain Routing, CIDR)：形式为 a.b.c.d/x 的地址的最高比特构成了 IP 地址的网络部分，并且经常被称为该地址的前缀 ( prefix ) (或网络前缀)，一个地址的剩余 32 - x 比特可用于区分该组织内部设备，该组织的内部结构可以采用同样的方式划分子网 
<br>地址聚合 (address aggregation) / 路由聚合 (route aggregation) / 路由摘要 (route summarization)：使用单个网络前缀通告多个网络的能力 <img alt="Pasted image 20231120172624.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120172624.png" style="width: 700px; max-width: 100%;">
<br><a data-tooltip-position="top" aria-label="网络层-数据平面 > ^189d26" data-href="网络层-数据平面#^189d26" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^189d26" class="internal-link" target="_self" rel="noopener">最长前缀匹配</a>：当组织 1 200.23.18.0/23 换用 ISPs-R-Us 的服务时，Fly-By-Night-ISP 继续通告原来的地址块，ISPs-R-Us 增加通告 200.23.18.0/23，当其他路由器看见 200.23.16.0/20 和 200.23.18.0/23 时，根据最长前缀匹配向 ISPs-R-Us 路由 <img alt="Pasted image 20231120172644.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231120172644.png" style="width: 700px; max-width: 100%;">
<br>分类编址 (classful addressing)：具有 8、16 或 24 比特子网地址的子网被分别被称为 A、B 和 C 类网络，分别可容纳 16777214、65534、254 (两个预留地址)台设备
<br>IP 广播地址：主机发送目的地址为 255.255.255.255 的数据报时，报文会交付给同一个网络中的所有主机，路由器也会有选择地向邻近的子网转发该报文
<br><br>
<br>IP 地址由因特网名字和编号分配机构 (Internet Corporation for Assigned Names and Numbers, ICANN)管理，ICANN 向区域性因特网注册机构分配地址
<br>ICANN 还管理 DNS 根服务器，同时负责分配域名和解决域名纠纷
<br><br>
<br>动态主机配置协议 (Dynamic Host Configuration, DHCP) 允许主机自动获取一个 IP 地址，网络管理员能配置 DHCP 以使主机每次与网络连接时能得到一个相同的 IP 地址，或者分配一个临时的 IP 地址 (temporary IP address)，DHCP 还允许主机得知其他信息，例如子网掩码、默认网关和本地 DNS 地址 <img alt="Pasted image 20231121102137.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121102137.png">
<br>DHCP 又被称为即插即用协议 (plug-and-play protocol) 或零配置协议 (zeroconf)
<br>DHCP 协议的步骤如图 <img alt="Pasted image 20231121105930.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121105930.png">

<br>DHCP服务器发现：新主机使用 DHCP 发现报文 (DHCP discover message)，通过向 subnet 广播封装了 UDP 分组 (67 端口) 的 IP 数据报 (源 IP 0.0.0.0 本主机，目的 IP 255.255.255.255 广播地址)，让 DHCP 服务器接收到报文
<br>DHCP服务器提供：服务器用 DHCP 提供报文做出响应该报文仍然使用 IP 广播地址 255.255.255.255，提供报文中包含推荐的 IP 地址、网络掩码以及 IP 地址租用期 (address lease time) <img alt="Pasted image 20231121111831.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121111831.png">
<br>DHCP请求：客户从一个或多个服务器选择一个，并向选中的服务器提供 DHCP 请求报文 (DHCP request message)，回显配置的参数
<br>DHCP ACK：服务器用 DHCP ACK 报文 (DHCP ACK message) 对 DHCP 请求报文进行响应


<br>DHCP 客户端状态转移图 <img alt="Pasted image 20231121112842.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121112842.png">
<br>DHCP 客户端的缺陷是移动节点在子网之间移动时，不能维持与远程应用之间的 TCP 连接
<br><br>
<br>网络地址转换 (Network Address Translation, NAT) 通常用于 SOHO (Small Office, Home Office) 中设备过多的 IP 地址不够分配的情况
<br>RFC 1918 [@moskowitzAddressAllocationPrivate1996] 定义了以下 IP 地址块，用于专用网络 (private network) 和具有专用地址的地域的地址空间：

<br>10.0.0.0/8
<br>172.16.0.0/12
<br>192.168.0.0/16


<br>具有专用地址的地域 (realm with private address)：其地址仅对该网络中的设备有意义的网络
<br>家庭网络计算机从 DHCP 服务器得到 IP 地址
<br>NAT 路由器维护一张 NAT 转换表 (NAT translation table)，当生成一个新的源端口号时，NAT 路由器选择任意一个当前未在 NAT 转换表中的源端口号，并在 NAT 转换表中增加一个表项 <img alt="Pasted image 20231121145854.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121145854.png">
<br>NAT 的使用对于运行在家庭网络的服务器会引起问题 (P2P 对等方)，解决方案包括 NAT 穿越 (NAT traversal) 和通用即插即用 (Universal Plug and Play, UPnP[@UniversalPlugPlay2023])
<br><br><img alt="Pasted image 20231121155011.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121155011.png" style="width: 500px; max-width: 100%;"><img alt="Pasted image 20231121161020.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121161020.png"><br>
<br>IPv6 数据报格式如图 <img alt="dee20d12ebabfb65621128b578bb6a6f.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/dee20d12ebabfb65621128b578bb6a6f.png">

<br>版本：用于标识 IP 版本号
<br>流量类型：与 <a data-tooltip-position="top" aria-label="网络层-数据平面 > ^11e8fd" data-href="网络层-数据平面#^11e8fd" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^11e8fd" class="internal-link" target="_self" rel="noopener">区分服务</a> 类似
<br>流标签：用于标识一条数据报的流，能够对一条流中的某些数据报给出优先权
<br>有效载荷长度：数据字段的字节数量
<br>下一个首部：与 <a data-tooltip-position="top" aria-label="网络层-数据平面 > ^af7241" data-href="网络层-数据平面#^af7241" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^af7241" class="internal-link" target="_self" rel="noopener">IPv4 协议字段</a>相似
<br>跳限制：转发数据报的每台路由器将该字段的内容减 1，若值为 0 则该数据报被丢弃
<br>源地址和目的地址：IPv6 地址的格式见 RFC 4291 [@deeringIPVersionAddressing2006]
<br>数据：IPv6 数据报的有效载荷部分


<br>相较于 IPv 4 已经不存在的字段

<br>分组/重新组装：IPv6 不允许在中间路由器上分片和组装，过大的数据报会被丢弃并回送一个 ICMP 报文
<br>首部检验和：快速处理 IP 分组是关注的重点，由于运输层和数据链路层执行了检验操作，所以设计者将 IP 中的冗余字段去除
<br>选项：现在选项字段出现在下一个首部指出的位置上


<br><br>
<br>建隧道 (Tunneling) ：隧道发送端的 IPv6 节点将整个 IPv6 数据报放到一个 IPv4 数据报的数据 (有效载荷) 字段中，隧道接收端 IPv6 节点查看协议字段指示 IPv6，从 IPv4 数据报中取出 IPv6 数据报并提供路由<img alt="Pasted image 20231121172718.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231121172718.png">
<br>隧道 (tunnel)：两台 IPv6 路由器之间的中间 IPv4 路由器的集合
<br><br>
<br>A middlebox is&nbsp;a computer networking device that transforms, inspects, filters, and manipulates traffic for purposes other than packet forwarding 
<br>网络层基于目的地转发的特征：查找目的 IP 地址 (匹配)，将分组发送到有特定输出端口的交换结构 (动作)
<br>考虑一种通用"匹配加动作"范式 (不局限于 Layer 3)，对协议栈的多个首部字段匹配，并采取相应的动作，包括将分组转发到一个或多个输出端口 (就像在基于目的地转发中一样)，跨越多个通向服务的离开接口进行负载均衡分组 (就像在负载均衡中一样)，重写首部值 (就像在 NAT 中一样)，有意识地阻挡／丢弃某个分组 (就像在防火墙中一样)，为进一步处理和动作而向某个特定的服务器发送一个分组 (就像在 DPI 一样)，等等 
<br>由于通用转发中匹配加动作表将基于目的地的转发表一般化，所以既包括网络层又包括链路层的转发决定，所以用 <a data-tooltip-position="top" aria-label="因特网 > 分组交换机(packet switch)" data-href="因特网#分组交换机(packet switch)" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#分组交换机(packet_switch)" class="internal-link" target="_self" rel="noopener">分组交换机</a> 统称 SDN 转发设备<img alt="Pasted image 20231122105823.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122105823.png">
<br>本节将基于 OpenFlow 标准对通用转发进行讨论

<br>OpenFlow 1.0 引入了关键的 SDN 抽象和功能
<br>匹配加动作转发表在 OpenFlow 中称为流表 (flow table)，表项包括

<br>首部字段值的集合：基于硬件匹配在 <a data-tooltip-position="top" aria-label="网络层-数据平面 > ^c49453" data-href="网络层-数据平面#^c49453" href="/campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html#^c49453" class="internal-link" target="_self" rel="noopener">TCAM</a> 内存中执行最迅速
<br>计数器集合
<br>所采取的动作集合




<br><br><img alt="Pasted image 20231122105353.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231122105353.png"><br>
<br>入端口：分组交换机上接收分组的输入端口
<br>OpenFlow 不允许基于 TTL 字段或数据报长度字段的匹配
<br>抽象的艺术：在一个时刻做一件事，将它做好。一个接口应当俘获一个抽象的最低限度的要件。不要进行一般化，一般化通常是错误的
<br><br>
<br>每个流表项都有零个或多个动作列表
<br>作为重要的动作可能是：

<br>转发：一个分组可能被单播广播或多播到输出端口，也可能被封装并发送到远程控制器，控制器可能对该分组采取某些动作，包括安装新的流表项，以及可能在该分组返回给该设备以在更新的流表规则集合下进行转发
<br>丢弃：没有动作的流表项表明匹配的分组应当被丢弃
<br>修改字段：分组被转发到输出端口前，分组首部除了 IP 协议的 Layer 2.3.4 字段可重写


]]></description><link>campus/chinese-notes/计算机科学/计算机网络/网络层-数据平面.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/网络层-数据平面.md</guid><pubDate>Fri, 22 Dec 2023 11:04:20 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231116172535.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231116172535.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[概述和运输层服务]]></title><description><![CDATA[ 
 <br><br>
<br>逻辑通信 (logic communication)： 

<br>运输层协议为运行在不同主机的运用进程之间提供了逻辑通信功能
<br>通过逻辑通信，运行不同进程的主机好像直接相连一样


<br>运输层协议在端系统中实现，发送端运输层将从发送应用程序进程接收到的报文转换成运输层报文段 (segment)，网路层将其封装成网络层分组（即数据报）并向目的地发送，接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层 <img alt="Pasted image 20231107111221.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231107111221.png">
<br>网络层提供了主机之间的逻辑通信，运输层为运行在不同主机上的进程之间提供了逻辑通信
<br><br>
<br>因特网为应用层提供了 <a data-tooltip-position="top" aria-label="应用层 > UDP 服务" data-href="应用层#UDP 服务" href="/campus/chinese-notes/计算机科学/计算机网络/应用层.html#UDP_服务" class="internal-link" target="_self" rel="noopener">UDP</a> (用户数据报协议) 和 <a data-tooltip-position="top" aria-label="应用层 > TCP 服务" data-href="应用层#TCP 服务" href="/campus/chinese-notes/计算机科学/计算机网络/应用层.html#TCP_服务" class="internal-link" target="_self" rel="noopener">TCP</a> (传输控制协议)

<br>UDP 为调用它的应用程序提供了一种不可靠、无连接的服务
<br>TCP 为调用它的应用程序提供了一种可靠的、面向连接的服务


<br>网际协议 (Internet Protocol)：网络层协议，为主机之间提供了逻辑通信

<br>服务模型：尽力而为交付服务 (best-effort delivery service)，不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性
<br>不可靠服务 (unreliable service)
<br>每台主机至少有一个网络层地址


<br>TCP 和 UDP 提供的服务模型：进程到进程的数据交付和差错检查 <img alt="IMG_6734.jpeg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/img_6734.jpeg" style="width: 600px; max-width: 100%;">

<br>将主机间交付拓展到进程间交付，运输层的多路复用 (transport-layer multiplexing) 和多路分解 (demultiplexing)
<br>通过在其报文段首部中包括差错检查字段而提供完整性检查


<br>TCP 提供的附加服务

<br>可靠数据传输 (reliable data transfer)：通过流量控制、序号、确认和定时器，确保正确地、按序地将数据从发送进程交付给接收进程
<br>拥塞控制 (congestion control)：力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽


<br><br>
<br>运输层没有直接将数据交付给进程，而是将数据交给了中间的套接字，每个套接字都有唯一的标识符 (端口号)
<br>多路分解 (demultiplexing)：将运输层报文段中的数据交付到正确的套接字
<br>多路复用 (multiplexing)：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层
<br>运输层报文段组成  <img alt="Pasted image 20231107151326.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231107151326.png" style="width: 300px; max-width: 100%;">

<br>周知端口号 (well-known port number)：0～1023，保留给周知应用层协议使用 RFC 3232 [@editorAssignedNumbersRFC2002a]
<br>如果编写的代码实现的是一个周知协议的服务器端，就需要分配一个相应的周知端口号，通常应用程序的客户端让运输层自动地 (并且是透明地) 分配端口号，而服务器端则分配一个特定的端口号


<br><br>
<br>UDP 套接字是由一个二元组全面标识的(一个目的 IP 地址和一个目的端口号)
<br>如果两个 UDP 报文段有不同的源 IP 地址和 / 或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程
<br>原端口号用作"返回地址"的一部分，在回发报文段时提取原端口号作为目的端口号
<br><br>
<br>TCP 套接字是由一个四元组(源 IP 地址，源端口号，目的 IP 地址，目的端口号)来标识的
<br>两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字，除非 TCP 报文段携带了初始创建连接的请求 <img alt="Pasted image 20231107164127.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231107164127.png">
<br>对于服务器，在任意给定的时间内都可能有（具有不同标识的）许多连接套接字连接到相同的进程，服务器可以采用多种并发模型来处理多个连接，例如：<br>
◦	多进程模型（Forking）：对每个新连接，服务器可以 fork 一个新的进程来处理该连接。<br>
◦	多线程模型（Threading）：服务器可以为每个新连接创建一个新的线程。<br>
◦	事件驱动模型（Event-driven）：服务器使用非阻塞 IO 和事件循环，通过一个单独的进程或线程来管理所有连接。<br>
◦	异步 IO 模型：服务器利用操作系统提供的异步 IO 接口进行非阻塞 IO 操作，而不需要每个连接一个线程。
<br><br>
<br>应用程序更适合 UDP 的原因：

<br>关于发送什么数据以及何时发送的应用层控制更为精细
<br>无需连接建立：QUlC 协议（快速 UDP 因特网连接) 将 UDP 作为其支撑运输协议并在 UDP 之上的应用层协议中实现可靠性
<br>无连接状态
<br>分组首部开销小


<br>网络管理应用程序通常必须在该网络处于重压状态时运行，所以在这种场合下 UDP 要优于 TCP
<br>UDP 中缺乏拥塞控制能够导致 UDP 发送方和接收方之间的高丢包率，并挤垮了 TCP 会话
<br>使用 UDP 的应用是可能实现可靠数据传输的 (eg. QUIC)
<br><br>                 0       7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |     Source      |   Destination   |
                 |      Port       |      Port       |
                 +--------+--------+--------+--------+
                 |                 |                 |
                 |     Length      |    Checksum     |
                 +--------+--------+--------+--------+
                 |
                 |          data octets ...
                 +---------------- ...

                      User Datagram Header Format
Copy<br>
<br>由 RFC 768 [@UserDatagramProtocol1980] 定义 <img alt="Pasted image 20231107151302.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231107151302.png">
<br>长度字段指示了在 UDP 报文段中的字节数 (首部加数据)
<br>接收方使用检验和来检查在该报文段中是否出现了差错
<br><br>
<br><a data-tooltip-position="top" aria-label="https://datatracker.ietf.org/doc/html/rfc768" rel="noopener" class="external-link" href="https://datatracker.ietf.org/doc/html/rfc768" target="_blank">RFC 768</a>
<br><a data-tooltip-position="top" aria-label="https://datatracker.ietf.org/doc/html/rfc1071" rel="noopener" class="external-link" href="https://datatracker.ietf.org/doc/html/rfc1071" target="_blank">RFC 1071</a>
<br><br>				  0      7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |          source address           |
                 +--------+--------+--------+--------+
                 |        destination address        |
                 +--------+--------+--------+--------+
                 |  zero  |protocol|   UDP length    |
                 +--------+--------+--------+--------+

						Pseudo  Header  Format
Copy<br>
<br>准备数据：将 UDP 头部（除了校验和字段，该字段在计算时设为0）和数据载荷分为16位的字（2字节）。如果数据的字节总数不是偶数（即不能完全分成16位的字），则在最后添加一个额外的字节的填充（通常是0）以使之成对
<br>添加伪头部 ：根据 UDP 协议，校验和的计算应包含一个"伪头部"，它包括发送者和接收者的 IP 地址（各占4字节），一个8位的全0字段（用于占位，确保伪头部的格式与传输层数据段的其余部分保持一致），1字节的协议号（UDP 是17, 0x11），以及 UDP 数据报的长度
<br>反码求和：使用 16 位反码运算，将所有的 16 位字加到一起。在这种加法中，如果任何一次加法结果超过 16 位，即最左边产生了进位，那么进位会被加回到计算结果的最低位。这就是所谓的“环绕”或“端到端进位”
<br>求和的反码：将最终的求和结果进位的一部分和基本部分相加之后取反码，即将所有位从 0 变为 1 或从 1 变为 0，这就是要存储在校验和字段的值
<br>特殊情况：如果计算出的检验和为 0，为防止将合法的检验和值 0 解释为没有使用检验和，发送端将检验和字段为 0 的情况下置为全 1
<br><br>
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/End-to-end_principle#:~:text=The%20end%2Dto%2Dend%20principle,end%20nodes%20of%20the%20network." rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/End-to-end_principle#:~:text=The%20end%2Dto%2Dend%20principle,end%20nodes%20of%20the%20network." target="_blank">端到端原则</a> [@EndtoendPrinciple2023](end-eend principle)：因为某种功能（在此时为差错检测）必须基于端到端实现："与在较高级别提供这些功能的代价相比、在较低级别上设置的功能可能是冗余的或几乎没有价值的。"

<br>虽然许多链路层协议提供了差错检测，但是不能保证源和目的之间所以链路都提供
<br>报文段存储在路由器的内存中，也可能引入比特差错


<br>虽然 UDP 提供差错检测，但是 UDP 对差错恢复无能为力
<br><br><img alt="Pasted image 20231108104230.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108104230.png"><br>
<br>可靠数据传输为上层实体提供的服务抽象：数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特就不会受到损坏 (由 0 变为 1 或者相反) 或丢失，而且所有数据都是按照其发送顺序进行交付
<br>可靠数据传输协议 (reliable data transfer protocol)：将下层协议提供的不可靠信道封装成可靠信道
<br>考虑因素：底层信道

<br>损坏比特
<br>丢失分组
<br>不会对分组重排序


<br>在本节中仅考虑<a data-tooltip-position="top" aria-label="因特网 > ^fa9487" data-href="因特网#^fa9487" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^fa9487" class="internal-link" target="_self" rel="noopener">单向数据传输</a> (unidirectional data transfer) 的情况，不考虑可靠的 <a data-tooltip-position="top" aria-label="因特网 > ^86d918" data-href="因特网#^86d918" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^86d918" class="internal-link" target="_self" rel="noopener">双向数据传输</a> (bidirectional data transfer)，但是需要注意本节实现协议需要在发送端和接收端两个方向上传输控制分组
<br><br>
<br><a data-tooltip-position="top" aria-label="https://hackmd.io/@bob840806/r1Q5GaMUX" rel="noopener" class="external-link" href="https://hackmd.io/@bob840806/r1Q5GaMUX" target="_blank">Principle of Reliable Data Transfer</a> [@PrincipleReliableData]
<br>
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Finite-state_machine" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Finite-state_machine" target="_blank">有限状态机</a> [@FinitestateMachineWikipedia] (Finite-State Machine, FSM)：一种计算的数学模型。作为一种抽象机器，FSM 可以在任何给定时间内处于有限数量的状态之一。FSM 可以根据一些输入从一个状态转换到另一个状态；从一个状态转换到另一个状态的变化称为转换。FSM 由其状态列表、初始状态和触发每个转换的输入定义 (PS：在宏观上看通用计算机也可以看作一个有限状态机哦，只是计算机的状态要比这里描述的状态机多得多得多，寄存器、cache、内存、外存的状态等随着指令的执行不断转换，其中存储数据的位模式不断改变)
<br><br>
<br>考虑底层信道是完全可靠的，既不出现比特损坏(位元错误)，也不丢失分组，分组还是按序到达的<br>
<img alt="Pasted image 20231108112409.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108112409.png" style="width: 350px; max-width: 100%;"> <img alt="Pasted image 20231108112423.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108112423.png" style="width: 350px; max-width: 100%;">
<br>
<br>水平线上方为造成转移的事件，下方为事件发生时所采取的动作，若不采取任何动作则为空白
<br>发送端和接收端均只有一种状态即等待上/下层的调用
<br>函数作用

<br>rdt_send(data)：从上层接收数据 (如果可靠数据传输实现在 Layer4，那么这些数据就是 Layer5 注入 socket 的报文 (message)(可以是 HTTP 报文，SMTP 报文...))
<br>make_pkt(packet, data)：将上层数据(根据需要拆分)加上头部建立<a data-tooltip-position="top" aria-label="因特网 > ^23aa67" data-href="因特网#^23aa67" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^23aa67" class="internal-link" target="_self" rel="noopener">分组</a> (注意⚠️：这里的分组指的是封包，在不同网络层级中的名称不同)
<br>udt_send(packet)：将此分组送入下层信道
<br>rdt_rcv(packet)：从下层信道接收分组
<br>extract(packet,data)：从分组中取出数据
<br>deliver_data(data)：将数据交给上层


<br><img alt="Pasted image 20231108125514.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108125514.png"><br>                              ┌────────────┐               ┌────────────┐
                              │            │               │            │
                              │   sender   │               │  receiver  │
                              │            │               │            │
                              └────────────┘               └────────────┘
   layer 5           layer 4                    layer 3              layer 4             layer 5
                                     │                           │
┌────────────┐      waiting for      │                           │
│datadatadata│      layer 5          │                           │
│datadata    │      invocation       │                           │
└────────────┘                       │                           │
 layer 5 call   rdt_send(data)       │                           │  waiting for
                ───────────────────► │                           │  layer 3
                packet=make_pkt(data)│                           │  invocation
                udt_send(packet)     │                           │
                      ┌────────────┐ │                           │
                      │headdatadata│ │ layer 3 channel delivery  │
                      │datadatadata│ │         reliable          │
                      └────────────┘ │ ────────────────────────► │ ┌────────────┐
                                     │                           │ │headdatadata│
                                     │                           │ │datadatadata│
                                     │                           │ └────────────┘
                                     │              layer 3 call │ rdt_rcv(packet)
                    waiting for      │                           │ ────────────────────►
                    layer 5          │                           │ extract(packet,data)
                    invocation       │                           │ deliver_data(data)  ┌────────────┐
                                     │                           │                     │datadatadata│
                                     │                           │                     │datadata    │
                                     │                           │                     └────────────┘
                                     │                           │
                                     │                           │
                                     │                           │  waiting for
                                     │                           │  layer 3
   From:                             │                           │  invocation
   Chris White                       │                           │
                                     ▼                           ▼
Copy<br><br>
<br>考虑经过底层信道后分组的比特可能受损(1 变 0，0 变 1)
<br>
<br>通过肯定确认 (positive acknowledgement) 和否定确认 (negative acknowledgement)，接收方让发送方知道那些内容能被正确接收，哪些内容需要重传，于是有自动重传请求 (Automatic Repeat reQuest, ARQ) 协议
<br>ARQ 协议基于三种机制

<br>差错检测：让接收端能够发现比特差错，UDP 使用<a data-tooltip-position="top" aria-label="运输层 > 检验和计算过程" data-href="运输层#检验和计算过程" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#检验和计算过程" class="internal-link" target="_self" rel="noopener">反码求和</a>的方式来检验
<br>接收端反馈：接收端反馈信息给发送端，ACK 代表成功，NAK 代表失败
<br>重传：分组有差错，就重传分组


<br>函数作用<br>
1. make_pkt(data,checksum)：计算 data 的 checksum 并且将数据封包<br>
2. isNAK(rcvpkt)：received packet为 NAK<br>
3. isACK(rcvpkt)：received packet 为 ACK<br>
4. corrupt(rcvpkt)：rcvpkt 有比特错误<br>
5. notcorrupt(rcvpkt)：rcvpkt 没有比特错误<br>
<img src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108153309.png"> <img alt="Pasted image 20231108153346.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108153346.png">
<br>
<br>注意在 make packet 的过程中同时还有计算 checksum 的过程
<br>
<br>发送端具有两种状态

<br>等待来自上层的调用，当接收上层的数据后进入状态 2，
<br>等待接收端传送 ACK 或 NAK ，收到 ACK 转移到状态 1 并等待上层的下一个调用，收到 NAK 重传一次分组并重复状态 2


<br>接收端只有一种状态

<br>根据收到的分组回传 ACK 或 NAK


<br>停等 (stop-and-wait)：发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组
<br>缺陷：未考虑 ACK 或 NAK 受损的可能性
<br><br>
<br>当发送端收到损坏的 ACK 或 NAK 分组时，就重传当前的数据分组，但是引入了一个问题，当接收方发送的 ACK 分组损坏时会收到冗余分组(duplicate packet)，而接收端分不清接收到的是新分组还是重传的分组 (发送 ACK 时接收端期望得到新分组但是 ACK 损坏后接收端会收到冗余分组，rdt 2.0接收端：🤔️😅🤪，发送 NAK 时接收端期望得到重传的分组则不会出现歧义)
<br>解决方法是在分组头部加入序号 (sequence number) 字段
<br>函数作用：

<br>has_seq0(rcvpkt)：接收分组的序号字段为 0
<br>has_seq1(rcvpkt)：接收分组的序号字段为 1<br>
<img alt="Pasted image 20231108203138.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108203138.png"><br>
<img alt="Pasted image 20231108203246.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231108203246.png"><img alt="杂项-9.jpg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/杂项-9.jpg"><img alt="杂项-8.jpg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/杂项-8.jpg">


<br>发送方最开始处于 等待来自上层的调用0 状态，当发送方发送一个 seq=0 的分组后，进入 等待 ACK 或 NAK 0 状态。
<br>此时在 等待来自下层的0 的接收方出现两种情况，情况 1 接收方收到了无差错的分组返回一个 ACK 分组，并转换为 等待来自下层的1 状态，情况 2 接收方收到了有差错的分组返回一个 NAK 分组，并且保持当前状态
<br>当 等待 ACK 或 NAK 0 状态的发送方收到确认分组时，出现三种情况，情况 1 收到 ACK 分组，情况 2 收到 NAK 分组，情况 3 分组出现了差错，情况 1 时分组转换为 等待来自上层的调用1 状态，进入下半个周期，情况 2 与情况 3 时发送端重传 seq=0 的分组并保持当前状态等待确认分组
<br>当接收方再次收到重传的 seq=0 分组时，接收方可能存在两种状态，第一种 2 中的报文出现了差错，仍然停留在 等待来自下层的0 状态，第二种 2 中的报文已经被接收送往上层，转换为 等待来自下层的1 状态，第一种状态下跳转至 2，第二种状态存在两种情况，情况 1 重传的 seq=0 分组完好，此时接收方发送 ACK 分组，情况 2  重传的 seq=0 分组出现差错，此时接收方发送 NAK 分组，跳转至 3，直至发送端接收到 ACK 分组转换为 等待来自上层的调用1 状态
<br><br><img alt="Pasted image 20231109085428.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109085428.png"><br>
<img alt="Pasted image 20231109085444.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109085444.png"><br><br>
<br>除了比特受损以外，底层信道还会出现丢包的情况
<br>这里将检测和回复丢包的工作都交给发送端处理
<br>发送方发送的数据分组或接收方对该分组的 ACK 发生了丢失，发送方都接收不到来自接收方的响应，如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可
<br>理想的协议应尽可能快地从丢包中回复过来，所以对等待时间的选择非常重要，如果在这段时间内没收到 ACK 则重传该分组，如果分组经历了一个特别大的时延，发送端也会重传该分组，即使数据分组和 ACK 都没丢失，于是在信道中引入了冗余数据分组 (duplicate data packet)
<br>倒数定时器 (countdown timer)：在一个给定时间量后，可中断发送方

<br>发送方每次发送一个分组，便启动一个定时器
<br>响应定时器中断
<br>中止定时器


<br>因为分组序号在 0 和 1 之间交替，rdt 3.0 被称为比特交替协议 (alternating-bit protocol)<br>
<img alt="Pasted image 20231109091635.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109091635.png"> <img alt="Pasted image 20231109091802.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109091802.png">
<br>
<br>数据传输协议的要点

<br>检验和
<br>序号
<br>定时器
<br>肯定的否定确认


<br><br>
<br>考虑一种情况，两个端系统之间的 <a data-tooltip-position="top" aria-label="应用层 > ^c4f1a1" data-href="应用层#^c4f1a1" href="/campus/chinese-notes/计算机科学/计算机网络/应用层.html#^c4f1a1" class="internal-link" target="_self" rel="noopener">RTT</a>  为  ，通过一条发送速率  为  的信道相连，包括首部字段和数据的分组  为  ，将分组送入信道的 <a data-tooltip-position="top" aria-label="因特网 > ^2ad19c" data-href="因特网#^2ad19c" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^2ad19c" class="internal-link" target="_self" rel="noopener">传输时延</a> 为 
<br>信道的利用率 (utilization)：发送方将分组送进信道的传输时延，与发送时间之比 () (ACK 分组太小，接收端返回 ACK 的传输时延忽略不计)，还忽略了发送方和接收方的底层协议处理时间，和可能出现的路由器处理和排队实验 
<br>使用流水线技术 (pipelining)：<img alt="Pasted image 20231109101141.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109101141.png">

<br>增加序号范围
<br>发送方和接收方缓存多个分组，发送方最低限度应该缓存发送但未被确认的分组
<br>差错恢复的两种基本方法：回退 N 步 (Go-Back-N, GBN)和选择重传 (Selective Repeat, SR)


<br><br><img alt="Pasted image 20231109103751.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109103751.png"><br>
<br>基序号 (base)：最早未确认的分组
<br>下一个序号 (nextseqnum)：下一个待发分组的序号
<br>N 常被称为窗口长度 (window size)，GBN 协议也常被称为滑动窗口协议 (sliding-window protocol)
<br>分组的序号承载在分组首部的定长字段中，如果分组序号字段的比特数是 k，则该序号的范围是  ，TCP 有一个 32bit 的序号字段，TCP 序号是按字节流中的字节进行计数的，而不是按分组计数
<br>GBN 发送方需要相应三种类型的事件：<img alt="Pasted image 20231109143937.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109143937.png">

<br>上层调用：当收到来自上层的调用时需要检查窗口是否已满，如果未满则发送一个分组，如果已满则将数据返回给上层让上层一会再试，实际情况中发送方可能缓存这个数据，或者使用同步机制允许上层在窗口不满时才调用
<br>收到一个 ACK ：更新 base，如果有已发送但未被确认的分组，则定时器被重新启动，如果没有已发送但未被确认的分组，则停止定时器
<br>超时事件：如果出现超时，发送方重传所有已发送但未被确认过的分组


<br>接收方动作：<img alt="Pasted image 20231109143951.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109143951.png">

<br>如果序号为 n 的分组按序到达，则为分组 n 发送一个 ACK n，如果到达的分组不是 n (失序)，则丢弃该分组等待发送端重传


<br>基于事件的编程 (event-based programming) 方式：在协议栈中对拓展 FSM 的实现以各种过程形式出现，每个过程实现了在响应可能出现的事件时要采取的动作，可能出现的事件

<br>上层实体调用
<br>定时器中断
<br>下层实体调用


<br><br>
<br>GBN 本身存在着一些性能问题，当窗口长度和带宽时延积都很大时，流水线中有很多分组，单个分组的差错就能引起 GBN 重传大量分组
<br>选择重传 (SR) 协议通过让发送方仅重传怀疑在接收方出错的分组避免了不必要的重传
<br>SR 发送方的事件与动作：<img alt="Pasted image 20231109150700.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109150700.png">

<br>从上层收到数据：若 ，则将数据打包并发送，否则将数据缓存或返回给上层
<br>超时：每个分组必须拥有自己的逻辑定时器，超时发生后只能发送一个分组 
<br>收到ACK：若分组序号在窗口内，则 SR 发送方将被确认的分组标记为已接收，若分组的序号等于 send_base 则将窗口基序号向前移动到最小的未确认分组处，如果窗口已到了有序号落在窗口内的未发送分组，则发送这些分组


<br>SR 接收方的事件与动作：<img alt="Pasted image 20231109151435.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109151435.png">

<br>序号在[rcv_base, rcv_base + N - 1] 内的分组被正确接收：回传选择 ACK (与当前收到分组 seq 对应) ，在接收端如果该分组以前没收到过，且序号大于接收窗口的基序号 (图中 rcv_base + 123的黑框框) 时，这些分组是失序分组，由接收端缓存，如果序号等于接收窗口的基序号 (rcv_base) 时，则将该分组及以前缓存的序号连续失序分组 (图中的 rcv_base + 1, rcv_base + 2, rcv_base + 3 的黑框框)交付给上层，接收窗口向前移动到下一个未交付的分组处 (图中 rcv_base + 4)
<br>序号在[rcv_base - N, rcv_base - 1] 内的分组被正确接收：必须产生一个 ACK (与分组 seq 对应)，此分组出现的原因是接收端已经收到分组移动窗口，但返回的 ACK 损坏，发送端重传该分组，为了让发送端接收到 ACK 确认并让发送端窗口向前移动，所以要产生 ACK 
<br>其他情况：若出现分组损坏等情况则忽略该分组等待发送端重传


<br>发送方和接收方件的窗口长度必须小于或等于序号空间大小的一半否则会引起歧义，接收方不知道接收到的下个分组是重传的还是发送方窗口滑动后发送的新分组
<br>先前假定分组在发送方和接收方的信道中不能被重新排序，但是实际上重新排序有可能发生，以前被发向信道但被认为丢失了的分组可能会突然出现，为了确保序号不被重新使用，发送方在发送序号为 x 的分组时需要确信任何先前发送过的序号为 x 的分组都不在网络中，通过假定分组在网络中的存活时间不会超过某个固定最大时间量来做到这一点
<br><br>
<br>TCP 是面向连接的 (connection-oriented)，在一个应用进程想另一个进程发送数据前，两个进程必须相互握手
<br>TCP 连接是点对点的 (point-to-point)
<br>三次握手 (three-way handshake) <img alt="Pasted image 20231109164640.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231109164640.png">
<br>发送缓存 (send buffer)：在三次握手期间设置的缓存，用来存储通过套接字的数据，TCP 从缓存中取出数据发送到网络层
<br>单个 TCP 报文段的数据数量受限于最大报文段长度 (Maximum Segment Size, MSS)，MSS 根据本地主机发送的最大链路层帧长度(最大传输单元(Maximum Transmission Unit, MTU)，不同的链路层协议会规定不同的 MTU)，如果运输层报文段超过了 MTU - IP 头部长度，就会被 IP 协议分片<img alt="杂项-10.jpg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/杂项-10.jpg"> 
<br>MSS 的典型值为 1460 字节，Ethernet 和 PPP Protocol 都有 1500 的标准 MTU，MSS 是指 Segment 中应用层 data 的最大长度，而不是包括首部的 TCP segment 的最大长度，很容易混淆⚠️ (如果又感到困惑了，看看<a data-tooltip-position="top" aria-label="因特网 > ^23aa67" data-href="因特网#^23aa67" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^23aa67" class="internal-link" target="_self" rel="noopener">这里</a>)
<br>TCP 为每块客户数据配上首部，形成多个 TCP 报文段 (TCP segment)
<br>TCP 连接的组成：

<br>客户端主机上的缓存、变量和与进程连接的套接字
<br>服务端主机上的缓存、变量和与进程连接的套接字


<br><br><img alt="Pasted image 20231110084755.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231110084755.png" style="width: 500px; max-width: 100%;"> <img alt="Pasted image 20231110085334.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231110085334.png"><br>
<br>源端口号和目的端口号 (各 16 bits)：用于多路复用 / 分解来自上层应用的数据
<br>序号字段 (sequence number field) 和 确认号字段 (acknowledgement number field)(各 32 bits)：被 TCP 发送方和接收方用来实现可靠数据传输服务
<br>首部长度字段 (header length field)(4 bits)：指示了以 32 bits 的字为单位的 TCP 首部长度 (最右边的括号里的 8)
<br>标志字段 (flag field) (最初定义 6 bits，现在存在 3 bits 的保留位与 9 bits 的控制位)：

<br>Accurate ECN：指示经过的路由器正在经历拥塞，被路由器置位 
<br>CWR (Congestion Window Reduced)：发送方接收到了设置了 ECE 标志的 TCP 包，并已降低拥塞窗口的大小 
<br>ECE (ECN-Echo)：这个标志在两种情况下会被设置。一种是作为对于收到设置了 CE（拥塞经历）标志的 IP 包的响应。另一种是在 TCP 三次握手中，用来指示 ECN（Explicit Congestion Notification，显式拥塞通告）的可用性 
<br>URG (Urgent)：表示紧急指针字段有效
<br>ACK (Acknowledgement)：表示确认字段有效
<br>PSH (Push)：告诉接收方应该立即将接收到的数据传递给上层应用，而不是等待缓冲
<br>RST (Reset)：用于重置一个错误的连接，或者拒绝非法的段或启动关闭连接
<br>SYN (Synchronize)：在建立连接时使用，用于初始化序列号字段
<br>FIN (Finish)：发送方完成发送任务，希望关闭连接


<br>紧急数据指针字段 (urgent data pointer field)：紧急指针字段的值表示从当前序列号开始，紧急数据的序号数
<br><br>
<br>TCP 序号建立在传送的字节流之上，而不是建立在传送的报文段序列之上
<br>一个报文段的序号 (sequence number for a segment) 是该报文段首字节的字节流编号，TCP 根据 MSS 将文件数据划分为 TCP 报文段，并将每个报文段对应的首字节的编号被填入相应报文段首部的序号字段中 <img alt="Pasted image 20231110095907.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231110095907.png">
<br>TCP 是全双工的，如果主机 A 在向主机 B 发送数据的同时，主机 B 也在向主机 A 发送数据，那么主机 A 填充进报文段的确认号是主机 A 期望从主机 B 收到的下一字节的序号
<br>如果主机 A 已经收到主机 B 包含字节 0～535 的报文段和包含字节 900～1000 的报文段，但主机 A 还没有收到字节 536 ～ 899 的报文段，那么 A 到 B 的下个报文段将在确认号中包含 536，而不会发送确认号位 1001 的报文段，TCP 只确认该流中至第一个丢失字节为止的报文段，收到的失序报文段不发送对应的确认报文段，而对失序报文段的处理方式由编程人员决定，所以 TCP 提供 <a data-tooltip-position="top" aria-label="https://cs.newpaltz.edu/~easwarac/CCN/Week6/tcpACK.pdf" rel="noopener" class="external-link" href="https://cs.newpaltz.edu/~easwarac/CCN/Week6/tcpACK.pdf" target="_blank">累积确认 </a>  (cumulative acknowledgement)(注意与 <a data-tooltip-position="top" aria-label="运输层 > 回退 N 步" data-href="运输层#回退 N 步" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#回退_N_步" class="internal-link" target="_self" rel="noopener">回退N步</a> 和 <a data-tooltip-position="top" aria-label="运输层 > 选择重传" data-href="运输层#选择重传" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#选择重传" class="internal-link" target="_self" rel="noopener">选择重传</a> 确认机制区分，回退 N 步中接收端直接将收到的分组(先前对于 rdt 的讨论不是基于特定 Layer 而言的，所以用 packet 来指代)丢弃，所以不存在累积确认的说法，而选择重传中是接收端收到分组，无论是不是失序分组，均回传与收到分组对应的 ACK，所以发送端能够知道失序的分组已经被接收了，在累积确认机制中，TCP 发送端(主机 B)是不知道字节 900～1000 的报文段(失序)已经被接收了，只能通过下个 A 到 B 的报文段中的确认号 536 知道到丢失字节(536)之前的所有报文段被正确接收了)<img alt="Pasted image 20231113151809.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231113151809.png">   
<br>TCP 编程人员对失序报文段有两种处理方式：

<br>接收方立即丢弃失序报文段(简化接收当设计)
<br>接收方保留失序的报文段，并等待缺失的报文段填补间隔(有可能在传送的过程中丢失或损坏由发送端重传)


<br>图中初始序号为 0，实际上序号 TCP 连接的双方可以随机选择序号，可以减少将仍在网络中存在的来自两台主机之间先前已中止的连接的报文段，误认为新连接的有效报文段的可能性 (需要恰巧新连接和旧连接都在发送方和接收方的同一对端口上)
<br><br><img alt="Pasted image 20231110112648.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231110112648.png" style="width: 500px; max-width: 100%;"><br>
<br>客户端的用户键入的每个字符都会被发送到远程主机，远程主机会送每个字符的副本给客户，并将这些字符显示在 telnet 用户的屏幕上
<br>回显 (echo back) 用于确保由 Telnet 用户发送的字符已被远程主机收到并在远程站点上得到处理
<br>不妨试着用 Python 运行一个简单的 Telnet 服务端 (Generated by ChatGPT) 
<br>import socket
import threading


def client_thread(conn, addr):
    print(f"Connected to {addr}")
    conn.send(b"Welcome to the Telnet server!\n")

    while True:
        try:
            data = conn.recv(1024)
            if not data:
                break
            conn.sendall(b"Echo: " + data)
        except ConnectionResetError:
            break

    print(f"Connection with {addr} closed")
    conn.close()


def start_telnet_server(host, port):
    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    server_socket.bind((host, port))
    server_socket.listen(5)
    print(f"Telnet server started on {host}:{port}")

    try:
        while True:
            conn, addr = server_socket.accept()
            threading.Thread(target=client_thread, args=(conn, addr)).start()
    except KeyboardInterrupt:
        print("Shutting down the server...")
    finally:
        server_socket.close()


if __name__ == "__main__":
    HOST = "127.0.0.1"  # 绑定到所有网络接口
    PORT = 23  # 标准Telnet端口号是23，但如果没有管理员权限，您可能需要选择1024以上的端口号
    start_telnet_server(HOST, PORT)

Copy<br>
<br>当程序运行时，服务端套接字监听 <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Localhost" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Localhost" target="_blank">localhost</a> 上 23 端口，当 socket 没有连接被建立时，accept() 方法是阻塞的，直到有新连接建立时 accept() 方法返回一个 (conn, addr) 对，conn&nbsp;是一个新的套接字对象，用于在此连接上收发数据，address&nbsp;是连接另一端的套接字所绑定的地址 (IP 和端口号)，随后程序创建并启动新的线程调用 client_thread() 方法来处理这个连接，连接开始时服务端打印了客户端的地址，并调用 socket 对象发送欢迎文本，接着该子线程进入循环，recv 的参数 bufsize 指定 buffer 的大小 ( bufsize ﻿参数指定了单次调用 recv﻿方法时最多可以读取的字节数，这个大小是由程序员根据具体的网络应用程序而定的，它可以是任意非零的整数，告诉 recv 方法一次性从内部缓冲区中读取多少字节的数据)，当 TCP 缓冲中没有数据可用时，recv() 会阻塞，如果 buffer 中有可用数据，但小于 bufsize，recv() 会返回实际可用的数据量，如果到达的数据量大于 bufsize，数据会存放在操作系统的缓冲区中，recv() 一次读取 bufsize 大小的数据，将这些数据加上 Echo:  字节串头部后使用 socket 对象发送回客户端
<br>可以通过 lsof 命令查看 TCP 连接是否被建立，图中在回环地址的 56971 端口到 23 端口建立了一条 TCP 连接 <img alt="Pasted image 20231110172736.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231110172736.png">
<br>在 telnet 中执行一系列操作(telnet 开启了 character 模式)，通过 wireshark 可以看到执行这些输入时对应的网络活动 ( loopback 接口的好处是不容易 capture 到操作系统其他网络活动的奇怪分组) <img alt="Pasted image 20231111102051.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231111102051.png" style="width: 400px; max-width: 100%;">  <img alt="Pasted image 20231111104737.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231111104737.png"> <img alt="Pasted image 20231111125547.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231111125547.png"> <img alt="Campus/Chinese-Notes/计算机科学/计算机网络/Attachments/杂项-11.jpg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/杂项-11.jpg"> <img alt="杂项-12.jpg" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/杂项-12.jpg">
<br>捎带 (piggybacked) ：需要注意的是，在上图的情况中对于携带数据的报文段的确认 (ACK) 均是是一个单独的不携带数据的 ACK 报文段，在实际情况下，对携带数据报文的确认有可能被装载在返回的承载数据的报文段中，这种确认称为是被捎带在数据报文段中
<br><br>
<br>TCP 中实现超时 / 重传机制，最明显的问题时超时间隔长度的设置
<br><br>
<br>样本 RTT (SampleRTT)：某报文段被发出 (交给 IP) 到对该报文段的确认被收到之间的时间量，通常 TCP 遵循以下规则来选择测量 SampleRTT 的报文段

<br>单个报文确认原则：为了避免对 RTT 估计引入额外的变化，通常不对重传的报文段进行 SampleRTT 的测量。换句话说，TCP 只测量对于那些被首次传输的报文段的确认，而不是对重传的报文段的确认
<br>Karn/Partridge 算法：如果一个报文必须重传，那么它的 SampleRTT 就不会被采用，因为这个 RTT 可能包含了重传的延迟，这不利于准确计算网络的真实 RTT
<br>避免并行测量：TCP 通常避免在同一时间测量多个报文段的 SampleRTT，通常是在任何给定的时间只对一个在传输路径上的数据段测量 SampleRTT。这样做是为了防止报文段的确认回应由于网络路径上的排队延迟而彼此影响，进而影响 RTT 的准确性
<br>样本选择：在某些实现中，TCP 可能会选择性地估算 RTT，例如只在特定间隔或者对特定的报文段测量 SampleRTT


<br>为了估计一个典型的 RTT，需要采取对间隔测量到的 SampleRTT 取平均的方法，TCP 维护一个 SampleRTT 均值 (EstimatedRTT)，当获得一个新的 SampleRTT 时，TCP 会根据指数加权移动平均 (Exponential Weight Moving Average) 来更新 EstimatedRTT， 的推荐值通常是 0.125  
<br>EstimatedRTT 的新值是由以前的 EstimatedRTT 值与 SampleRTT 新值加权组合而成，这个加权平均对最近的样本赋予的权值要大于对旧样本赋予的权值，因为越近的样本越能更好地反映网络的当前拥塞状况，一个给定的 SampleRTT 的权值在更新的过程中呈指数型快速衰减
<br>RFC 6298 定义了 RTT 偏差，用于估算 SampleRTT 会偏离 EstimatedRTT 的程度， 的推荐值通常为 0.25  
<br><br>
<br>超时间隔应大于等于 EstimatedRTT ，否则将造成不必要的重传，超时间隔不应该比 EstimatedRTT 大太多，否则当报文段丢失时，TCP 不能很快重传该报文段，因此要求将超时间隔设为 EstimatedRTT 加上一定余量。当 SampleRTT 值波动较大时，这个余量应该大些；当波动较小时，这个余量应该小些 
<br>推荐的初始 Timeoutlnterval 值为 1 秒 RFC 6298 [@sargentComputingTCPRetransmission2011]。同时，当出现超时后，Timeoutlnt­erval 值将加倍，以免即将被确认的后继报文段过早出现超时。然而，只要收到报文段并更新 EstimatedRTT , 就使用上述公式再次计算 Timeoutlnterval
<br>TCP 通过使用肯定确认和定时器来实现可靠数据传输，当 TCP 认为报文段或其确认丢失或受损时，TCP 会重传这些报文段，有一些 TCP 还有一个隐式 NAK 机制 (快速重传（Fast Retransmit）: 当接收方收到一个失序的数据包时，它会立即发送一个重复的 ACK（也就是隐式 NAK），这是当前已正确接收的最高序列号的数据包。如果发送方收到三个或者更多连续的重复 ACK，它将推测在传输中出现了数据包丢失，并且会在定时器到期之前立即重传那些丢失的数据包)
<br>TCP 无法分辨报文段或其 ACK 是丢失了、受损了还是时延过长了，但 TCP 对这些情况的处理方式是相同的，重传出现问题的报文段
<br>TCP 也使用流水线，当报文长度和往返时延只比很小时，流水线能显著增加一个会话的吞吐量，一个发送方能够具有的未被确认报文段的具体数量是由 TCP 的流量控制和拥塞控制机制决定的
<br><br>
<br>IP 的尽力而为服务：不保证数据报的交付 (丢包)，不保证数据报的按序交付服务 (乱序)，不保证数据报中数据的完整性 (损坏)
<br>TCP 在 IP 不可靠的尽力而为服务至上创建了一种可靠数据传输服务 (reliable data transfer service)，确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余和按序的数据流
<br>在研究选择重传机制时，曾假定每一个已发送但未被确认的报文都与一个定时器相关联 <a data-tooltip-position="top" aria-label="运输层 > ^83af2c" data-href="运输层#^83af2c" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^83af2c" class="internal-link" target="_self" rel="noopener">逻辑定时器</a>，但是定时器的管理需要相当大的开销，RFC 6298 [@sargentComputingTCPRetransmission2011]  推荐的定时器管理过程仅使用单一的重传定时器，即使有多个已发送但还未被确认的报文段
<br>TCP 可靠数据传输简化描述：假设发送方不受 TCP 流量和拥塞控制的限制的，来自上层数据的长度小于 MSS，且数据传送只在一个方向进行
<br>NextSeqNum = InitialSeqNumber
SendBase = InitialSeqNumber


while (1) {
	switch (event) {
		case 1: //从上层接收到数据e
			sndpkt[NextSeqNum] = make_pkt(NextSeqNum, data, checksum);
			if (isTimerInactive) //定时器当前没有运行
				timer_start();
			udt_send(sndpkt[NextSeqNum]);
			NextSeqNum = NectSeqNum + length(data);
			break;
			
		case 2: //定时器超时
			udt_snd(sndpkt[SendBase]); //重传具有最小序号但仍未应答的报文段
			timer_start();
			break;
			
		case 3: //收到ACK，Ack = y
			if (y &gt; SendBase) {
				SendBase = y; //累积确认
				if (NextSeqNum &gt; SendBase) //当前有未被确认的报文段
					timer_start();
			}
			break;
	}
	/*没有事件到来时循环阻塞*/
}
Copy<br>
<br>TCP 采用<a data-tooltip-position="top" aria-label="运输层 > ^d4dffe" data-href="运输层#^d4dffe" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^d4dffe" class="internal-link" target="_self" rel="noopener">累积确认</a>，所以代码中的 y 确认了字节编号在 y 之前的所有字节都已经收到
<br><br>
<br>当 TCP 的一个分组丢失或遭受延迟时，如果超时事件发生，TCP 发送端会重传该分组，但是如果是两个连续的分组，超时事件发生时，发送端会采取什么样的行动🤔️
<br>如图 2，当主机 A 连续发送了两个报文段，假设两个报文段在超时前都没有到达主机，当超时事件发生时，主机 A 重传序号 92 的第一个报文段，并重启定时器，只要第二个报文段 ACK 在新的超时发生以前到达，则第二个报文段将不会被重传<img alt="Pasted image 20231113154643.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231113154643.png">
<br>还有一种情况，主机 A 像 2 中一样发送两个报文段但第一个报文段的 ACK 报文总在网络中丢失或者遭受延迟，而第二个报文在超时事件发生前正确到达了，根据累积确认机制，主机 A 知道主机 B 已经收到了序号为 119 及之前的所有字节，所以主机 A 不会重传这两个报文段中的任何一个 <img alt="Pasted image 20231113155258.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231113155258.png" style="width: 400px; max-width: 100%;">
<br><br>
<br>考虑在大多数 TCP 实现中所做的一些改变，首先关注定时器 timeout 时超时间隔的长度，在这种修改中，当超时事件发生时，TCP 重传具有最小序号的未确认的报文段，但是每次 TCP 重传都会将下一次的超时间隔设为先前值的两倍，而不是用从 <a data-tooltip-position="top" aria-label="运输层 > ^f6828c" data-href="运输层#^f6828c" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^f6828c" class="internal-link" target="_self" rel="noopener">EstimatedRTT</a>  和 <a data-tooltip-position="top" aria-label="运输层 > ^26aa11" data-href="运输层#^26aa11" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^26aa11" class="internal-link" target="_self" rel="noopener">DevRTT</a> 推算出的值
<br>这种方法提供了一种形式受限的拥塞控制，在拥塞时，如果源持续重传分组会使拥塞更严重，所以 TCP 采用更优雅的方式
<br><br>
<br>发送方通常可在超时事件发生之前通过冗余 ACK 来较好地检测到丢包的情况
<br>冗余 ACK 是再次确认某个报文段的 ACK ，而发送方先前已经收到对该报文段的确认
<br>当接收方期望收到一个序列号为 N 的报文段，但是却收到了一个序列号大于 N 的报文段时，它会意识到一些数据丢失了（可能是因为网络中的某些报文段丢失或到达顺序错乱）。此时，为了通知发送方哪些报文段已成功接收，并请求重传丢失的报文段，接收方会发送一个确认最后成功接收报文段的冗余 ACK<img alt="Pasted image 20231113162423.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231113162423.png">
<br>发送方经常一个接一个地发送大量的报文段，如果一个报文段丢失，就很可能引起许多一个接一个的冗余 ACK 。如果 TCP 发送方接收到对相同数据的 3 个冗余 ACK,，它把这当作一种指示，说明跟在这个已被确认过 3 次的报文段之后的报文段已经丢失，一旦收到 3 个冗余 ACK ，TCP 就执行 快速重传(fast retransmit)，即在该报文段的定时器过期前重传丢失的报文段
<br>if (y &gt; SendBase) { 
	SendBase = y;
	DupAck = 0;
	if (NextSeqNum &gt; SendBase)
		timer_start();
} else { /*当收到对已经确认报文段的一个冗余ACK，此时 y = SendBase*/
	DupAck++;
	if (DupAck == 3) { //TCP快速重传
		udt_snd(sndpkt[y]) //重新发送具有序号 y 的报文段
	}
}
break;
Copy<br><br>
<br>TCP 协议更像 GBN 协议和 SR 协议的混合体
<br>GBN 协议特征

<br>累积式的，正确接收但失序的报文不会被接收方逐个确认
<br>TCP 发送方维护 已发送但未被确认的字节的最小序号(SendBase) 和 下一个要发送的字节的序号(NextSeqNum)


<br>SR 协议特征

<br>当发送方发送一组报文段，其中的一个报文段丢失时，TCP 至多重传一个类型的报文段 (这个报文段，若重传还丢失，那么仍旧重传该报文段)，GBN 则会重传所有的该报文段后的报文段
<br>选择确认 (selective acknowledgement) <a data-tooltip-position="top" aria-label="https://datatracker.ietf.org/doc/html/rfc2018" rel="noopener" class="external-link" href="https://datatracker.ietf.org/doc/html/rfc2018" target="_blank">RFC 2018</a> [@floydTCPSelectiveAcknowledgment1996] ，允许 TCP 接收方有选择地确认失序报文段，选择确认机制还能和选择重传机制结合起来使用，跳过重传那些被接收方选择性确认过的报文段


<br><br>
<br>当数据进入接收方主机的缓存时，接收方应用可能正忙于其他任务，并不能立刻读取数据，此时如果发送方发送的数据太多、太快，到达接收方的数据很容易让接收缓存溢出
<br>流量控制服务 (flow-control service) 可以消除发送方使接收方缓存溢出的可能性
<br>TCP 防止接收方缓存溢出采用的策略为流量控制，因为 IP 网络的拥塞而被遏制的机制为 拥塞控制 (congestion control)，请注意区分
<br>TCP 通过让发送方维护一个称为 接收窗口 (receive window) 的变量来提供流量控制 (在上方的 <a data-tooltip-position="top" aria-label="运输层 > ^f3f973" data-href="运输层#^f3f973" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^f3f973" class="internal-link" target="_self" rel="noopener">Telnet 服务端案例</a>中有出现)
<br>假设主机 A 通过一条 TCP 连接向主机 B 发送一个大文件，主机 B 为连接分配了一个大小为 RcvBuffer的接收缓存，主机 B 上的应用进程不时从该缓存中读取数据，定义 LastByteRead 为主机 B 的应用进程从缓存读出的数据流的最后一个字节的编号，LastByteRcvd 为从网络中到达的并且已放入主机 B 接收缓存中的数据流的最后一个字节的编号
<br>TCP 不允许已分配的缓存溢出 
<br>接收窗口用 rwnd 表示 
<br>主机 B 通过把 rwnd 值放入报文段接收窗口字段中，通知主机 A 在该连接的缓存中还有多少可用空间
<br>主机 A 需要将未确认的数据量控制在 rwnd 内，即 
<br>⚠️当主机 B 的接收窗口为 0 时，主机 A 继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认，最终缓存开始清空，并在确认报文里将包含一个非 0 的 rwnd 值
<br>UDP 不提供流量控制，报文段由于缓存溢出可能在接收方丢失
<br><br>
<br>TCP 连接的建立会显著地增加人们感受到的时延
<br>三次握手 (three-way handshake) 过程：

<br>客户端向服务器端发送 TCP SYN 报文段，并随机选择该 SYN 报文段的初始序号，并封装为 IP 数据报发送给服务器
<br>服务器从 IP 数据报中提取 TCP SYN 报文段，为该 TCP 分配 TCP 缓存和变量，并向该客户 TCP 发送 SYN ACK 报文段，并随机选择该报文段的初始序号
<br>收到 SYN ACK 报文段后，客户端给连接分配缓存和变量，然后发送一个 ACK 报文段，确认号设置为收到的序号加1，同时可以在该报文段中携带客户到服务器的数据


<br>四次挥手 (four-way handshake) 过程：<img alt="Pasted image 20231114154644.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231114154644.png">

<br>客户端向服务器端发送 FIN 报文段
<br>服务器收到该报文后，向发送方回送一个 ACK 报文段
<br>服务器发送自己的 FIN 报文段
<br>最后，客户对服务器的中止报文段进行确认


<br>在一个 TCP 连接的生命周期中，运行在每台主机中的 TCP 协议在各种 TCP 状态 (TCP state) 之间变迁 <img alt="Pasted image 20231114154947.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231114154947.png" style="width: 600px; max-width: 100%;"> <img alt="Pasted image 20231114160800.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231114160800.png" style="width: 600px; max-width: 100%;">
<br>除了客户应用程序可以发送 FIN 报文段关闭该连接外，服务器也可以选择关闭该连接
<br>TCP RST 标志代表一个异常的终止，通常有以下几种情况：

<br>主动拒绝连接建立：如果接收方收到 SYN 报文段，但在对应端口上没有运行服务，不希望建立连接，则可以发送 RST 报文段来拒绝连接，告诉该源"我没有那个报文段的套接字，请不要再发送该报文段了"，如果接收的 UDP 分组目的端口与 UDP 套接字不匹配，主机会发送一个特殊的 ICMP 报文
<br>致命的协议错误：如果一个端点检测到对方违反了协议的规定时，发送 RST 报文段来关闭连接
<br>未经期望的数据到达：如果一个 TCP 端点接收到不存在的连接到达的数据，可以发送 RST 报文段回复


<br><br>
<br>经典的 Dos 攻击，攻击者发送大量 TCP SYN 报文段，但不完成第三次握手过程，服务器不断为半开连接分配资源，直至连接资源被消耗殆尽
<br>可以使用 SYN cookie 来记忆对应的发送端 IP 地址和端口号
<br><br>
<br>分组重传时网络拥塞的征兆，为了处理网络拥塞的原因，需要一些机制以在面临网络拥塞时遏制发送方
<br><br>
<br>供给载荷 (offered load)：运输层向网络中发送含有初始数据或重传数据的报文段的速率
<br>考虑以下具有四个发送方和有限缓存的多台路由器及多条路径的情况 <img alt="Pasted image 20231115090203.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231115090203.png">

<br>假设每台主机都使用超时 / 重传机制来实现可靠数据传输，不执行流量控制或拥塞控制，忽略由于添加运输层和较低层首部信息产生的额外开销，所有的主机都具有相同的  值，所有路由器的链路容量都是  字节 / 秒，到达主机应用层的接收速率为 
<br>考虑 A - C 连接，A - C 与 B - D 连接共享路由器 R2，对于较小的  值，路由器几乎不出现缓存溢出的情况，所以  的增大会导致  的增大
<br>当  很大时，经过 R1 到达 R2 的 A - C 流量速率至多是 R ，当来自 B - D 连接的供给载荷越来越大时，经过 R1 转发的 A - C 流量相比之下就更小，由于两条连接的流量需要为 R2 上的有限缓存空间竞争，所以当供给载荷趋近于∞时，R2 的缓存空间中几乎被 B - D 连接的流量占满，因此 A - C 连接的流量在  R2 上的吞吐量趋近于 0 <img alt="Pasted image 20231115112824.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231115112824.png" style="width: 500px; max-width: 100%;">
<br>由于拥塞而丢弃分组的另一种代价：当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了，所以当选择一个分组时，路由器最好优先考虑那些已经经历过一定数量的上游路由器的分组


<br><br>
<br>根据网络层是否为运输层拥塞控制提供显示帮助区分：

<br>端到端拥塞控制：网络层没有为运输层拥塞控制提供显式支持，网络层对端系统来说是一个黑箱，需要通过对 IO 的观察 (分组丢失与时延) 来推断，TCP 采取端到端的拥塞控制方法
<br>网络辅助的拥塞控制 ：在 ATM 可用比特率 (Available Bite Rate, ABR) 拥塞控制中，路由器显式地通知发送方能在输出链路上支持的最大主机发送速率

<br>直接网络反馈, 采用路由器发送阻塞分组 (choke packet) 的形式
<br>经由接收方的网络反馈，路由器标记或更新从发送方流向接收方的分组中的某个字段来指示拥塞的产生，至少需要 1 RTT




<br><br>
<br>TCP 发送方限制向其连接发送流量的方式

<br>跟踪拥塞窗口 (congestion window, cwnd)，需要满足 
<br>上述约束限制了送方中未被确认的数据量，因此间接地限制了发送方的发送速率，发送方的发送速率大概是  字节 / 秒


<br>TCP 发送方感知路径上出现拥塞的方式

<br>发送方定时器超时
<br>发送方接收到 3 个冗余 ACK 
<br>TCP 将确认的到达作为正常的指示，并根据确认到达的速率来调整增大拥塞窗口长度的迅速程度 (二阶导)，所以 TCP 是自计时 (self-clocking) 的


<br>TCP 确定发送速率的方式：发送太快，会导致拥塞崩溃。发送太慢，就不能充分利用网络的带宽

<br>丢包意味着拥塞，当遇到丢失报文段时应当降低 TCP 发送方的速率
<br>确认报文段指示正在交付，当确认报文段到达时应当增加发送方的速率
<br>带宽探测


<br>TCP 拥塞控制算法 (TCP congestion control algorithm)：加性增、乘性减 (Additive-Increase, Multiplicative-Decrease, AIMD) 拥塞控制方式 <img alt="Pasted image 20231115162141.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231115162141.png">

<br>慢启动 (slow-start)

<br>TCP 连接开始时，cwnd 常置为一个 MSS 的较小值，每当传输的报文段被确认 cwnd 就增加一倍 
<br>如果发送方检测到拥塞 (超时) 时，将第二个状态变量的值 ssthresh 设置为 cwnd / 2，将 cwnd 设置为 1
<br>如果存在 ssthresh，当 cwnd 的值等于 ssthresh 时，结束慢启动并且将 TCP 转为拥塞避免模式
<br>如果检测到三个冗余 ACK，TCP 执行快速重传并进入快速恢复状态


<br>拥塞避免

<br>每个 RTT 指将 cwnd 的值增加一个 MSS ，等同于 ACK 每次将 cwnd 的值增加 (MSS / cwnd) x MSS 字节
<br>当超时丢包事件出现时，ssthresh 的值被更新为 cwnd 值的一半
<br>当收到三个冗余 ACK 时，TCP 将 ssthresh 的值记录为 cwnd 值的一半，然后进入快速恢复状态


<br>快速恢复

<br>对于进入快速恢复状态的缺失报文段，对每个收到的冗余 ACK ，cwnd 值增加一个 MSS
<br>最终当对丢失报文段的 ACK 到达时， TCP 在降低 cwnd 后进入拥塞避免状态
<br>出现超时，将 ssthresh 的值被更新为 cwnd 值的一半， cwnd 设置为 1，进入慢启动状态




<br>TCP 连接的平均吞吐量 <img alt="Pasted image 20231115170222.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231115170222.png"> 
<br>经高带宽路径的 TCP 
<br><br>
<br>假设仅有 TCP 穿过瓶颈链路，所有的连接具有相同的 RTT 值，对于一个主机 - 目的地而言只有一条 TCP 连接与之相关联，TCP 趋于在多条连接之间平等地共享带宽
<br>影响 TCP 拥塞控制公平性的因素：

<br>RTT：多条连接共享一个共同的瓶颈链路时具有较小 RTT 的连接能够在链路空闲时更快地抢占可用带宽，将比具有较大 RTT 的连接享用更高的吞吐量
<br>UDP：UDP 没有内置的拥塞控制，有可能压制 TCP 流量
<br>并行 TCP 连接：Web 浏览器通常使用多个并行 TCP 连接来传送一个 Web 页中的多个对象，多条并行连接在拥塞链路中通常会抢占更多的带宽


<br><br>
<br>明确拥塞通告 (Explicit Congestion Notification, ECN)：网络明确向发送方和接收方发出拥塞信号
<br>用于网络辅助拥塞控制的标志位：<a data-tooltip-position="top" aria-label="运输层 > ^867fc3" data-href="运输层#^867fc3" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^867fc3" class="internal-link" target="_self" rel="noopener">Accurate ECN</a> <a data-tooltip-position="top" aria-label="运输层 > ^7eba8b" data-href="运输层#^7eba8b" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^7eba8b" class="internal-link" target="_self" rel="noopener">ECE</a>
<br>RFC 3168 [@floydAdditionExplicitCongestion2001] 推荐仅当拥塞持续不断存在时才设置 ECN 比特
<br>对于具有 ECE 拥塞指示的 ACK ，TCP 发送方将拥塞窗口减半作为回应，并在下个发送方到接收方的报文段中对 <a data-tooltip-position="top" aria-label="运输层 > ^2d9580" data-href="运输层#^2d9580" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^2d9580" class="internal-link" target="_self" rel="noopener">CWR</a> (拥塞窗口缩减) 置位
<br>其他能利用网络层发送 ECN 信号的协议有数据报拥塞控制协议 (Datagram Congestion Control Protocol, DCCP)，DCTCP (数据中心 TCP) 
]]></description><link>campus/chinese-notes/计算机科学/计算机网络/运输层.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/运输层.md</guid><pubDate>Fri, 22 Dec 2023 11:04:20 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231107111221.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231107111221.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[链路层概述]]></title><description><![CDATA[ 
 <br>
<br>广播信道：用于连接有线局域网、卫星网和<a data-tooltip-position="top" aria-label="因特网 > ^57ab0b" data-href="因特网#^57ab0b" href="/campus/chinese-notes/计算机科学/计算机网络/因特网.html#^57ab0b" class="internal-link" target="_self" rel="noopener">混合光纤同轴电缆</a> (Hybird Fiber Coaxial cable, HFC) 接入网中的多轴，需要媒体访问协议来协调帧传输
<br>点对点通信链路
<br><br>
<br>本章为方便讨论，将运行链路层协议的任何设备都称为节点 (node)，把沿着通信路径连接相邻节点的通信信道称为链路 (link)
<br>通过特定链路时，传输节点将数据报封装在链路层帧中，并将该帧传输到链路中
<br><br>
<br>成帧 (framing)：在每个网络层数据报经链路传送前，链路层协议将网络层数据报用链路层帧封装起来，帧的结构由链路层协议规定
<br>链路接入：媒体访问控制协议 (Medium Access Control, MAC) 规定了帧在链路上传输的规则，对于点对点链路，无论何时链路空闲都能发送帧，多个节点共享广播链路时，MAC 协议用于协调多个节点的帧传输
<br>可靠交付：保证无差错地经链路层移动每个网络层数据报，链路层的可靠交付服务通常是通过确认和重传取得的，目的是在本地纠正一个差错 (链路两端)，而不是用过运输层或应用层协议进行端到端数据重传
<br>差错检测和纠正：许多链路层协议提供一种让发送节点在帧中包括差错检测比特，让接收节点进行差错检查的机制，以此来完成差错检测
<br><br>
<br>链路层的主体部分在网络适配器中实现 (network adapter)，网络适配器又称作网络接口卡 (Network Interface Card, NIC)，位于网络适配器核心的是链路层控制器
<br>发送端协议栈取得了协议栈较高层生成并存储在主机内存中的数据报，在链路层帧中封装数据报，然后遵循链路接入协议将该帧传进通信链路中 <img alt="Pasted image 20231130170308.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231130170308.png">
<br><br>
<br>比特级差错检测和纠正 (bit-level error detection and correction)：通常是两种服务 (检测 / 纠正)，从一个节点发送到另一个物理上连接的邻近节点的链路层帧中的比特损伤进行检测和纠正
<br>发送节点使用差错检测和纠正比特 (Error-Detection and-Correction, EDC) 增强数据 D ，要保护的数据包括网络层数据报和链路帧首部 <img alt="Pasted image 20231130173734.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231130173734.png">
<br>即使采用差错检测比特，也可能存在未检出比特差错 (undetected bit error)
<br>检测差错的三种技术包括奇偶校验、检验和方法和循环冗余检测
<br><br>
<br>偶 / 奇校验方案，发送方包含一个附加的比特，使  比特中  的总数是偶数 / 奇数
<br>二维奇偶校验方案 (two-dimension parity)：可检测和纠正单个比特差错，可检测但不能纠正两个比特差错，行奇偶比特和列奇偶比特加上一个附加比特构成了链路层帧的差错检测比特 <img alt="Pasted image 20231130180250.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231130180250.png" style="width: 500px; max-width: 100%;">
<br>向前纠错 (Forward Error Correction, FEC)：接收方检测和纠正差错的能力，允许在接收方立刻纠正差错，避免了不得不等待的往返时延
<br><br>
<br>d 比特数据被作为 k 比特整数的序列处理
<br><a data-tooltip-position="top" aria-label="运输层 > ^403ed7" data-href="运输层#^403ed7" href="/campus/chinese-notes/计算机科学/计算机网络/运输层.html#^403ed7" class="internal-link" target="_self" rel="noopener">因特网检验和</a> (Internet checksum) 将数据字节作为 16 比特的整数对待并求和，和的反码形成了携带在报文段首部的因特网检验和
<br>TCP 和 UDP 中对所有字段都计算因特网检验和，XTP 对首部计算一个检验和对整个分组计算另一个检验和
<br>TCP 和 UDP 的检验和只用了 16 比特，与链路层 CRC 相比提供相对弱的差错保护，因为运输层检验和通常由操作系统中的软件实现，链路层的差错检验通常在适配器中用专用的硬件实现，能够执行更复杂的 CRC 操作
<br><br>
<br>循环冗余检测 (Cyclic Redundancy Check, CRC) 编码：也称多项式编码 (polynomial code) ，将要发送的比特串看作系数是 0 和 1 的一个多项式，对比特串的操作被解释为多项式算术
<br>生成多项式 (generator)  ：发送方和接收方协商的  比特模式
<br>对于一个给定的数据段  ，发送方要选择  个附加比特  将它附加到  上，使得得到的  比特模式用模 2 算数 [@ModularArithmetic2023] 恰好能被  整除 <img alt="Pasted image 20231201150249.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231201150249.png">
<br> 的计算

<br>需要满足  
<br>对等式两边异或  得到  
<br>该等式说明 


<br>国际标准定义的 CRC-32 标准被多种链路级 IEEE 协议采用，使用的一个生成多项式是


<br><br>
<br>点对点链路 (point-to-point link)：由链路一端的单个发送方和链路的另一端的单个接收方组成，许多链路层协议都是为点对点链路设计的，如点对点协议 (point-to-point protocol, PPP) 和高级数据链路控制 (high-level data link control, HDLC)
<br>广播链路 (broadcast link)：能够让多个发送和接受节点都连接到相同的、单一的、共享的广播信道上，当任何节点传输一个帧时，信道广播该帧，每个其他节点都收到一个副本
<br>多路访问问题 (multiple access problem)：协调多个发送和接受节点对一个共享广播信道的访问
<br>碰撞 (collide)：多个节点可能会同时传输帧，此时所有节点同时接收帧，传输的帧在接收方处碰撞，涉及碰撞的所有帧都丢失了
<br>多路访问协议的类型

<br>信道划分协议 (channel partitioning protocol)
<br>随机接入协议 (random access protocol)
<br>轮流协议 (taking-turns protocol)


<br>理想特性

<br>当只有一个节点活跃时，该活跃节点有  bps 的吞吐量
<br>当有 M 个节点活跃时，每个活跃节点的吞吐量接近  bps


<br><br>
<br>时分多路复用 (TDM)
<br>频分多路复用 (FDM)
<br>码分多址 (Code Division Multiple Access, CDMA)
<br><br><br><br>
<br>所有帧由  比特组成
<br>时间被分为长度为  秒的时隙
<br>节点只在时隙起点开始传输帧
<br>节点是同步的，每个节点知道时隙何时开始
<br>如果在一个时隙中有两个或者多个帧碰撞，则所有节点在该时隙结之前检测到该碰撞事件
<br><br>
<br>当节点有一个新帧要发送时，它等到下一个时隙开始并在该时隙传输整个帧
<br>如果没有碰撞，该节点成功地传输它的帧，从而不需要考虑重传该帧
<br>如果有碰撞，该节点在时隙结束之前检测到这次碰撞，该节点以概率  在后续每个时隙中重传它的帧，直到该帧被无碰撞地传输出去
<br><br>
<br>时隙多路访问协议的效率(efficiency)：当有大量的活跃节点且每个节点总有大量的帧要发送时，长期运行中成功时隙的概率
<br>假设每个节点试图在每个时隙以概率 p 传输一帧
<br>一个给定时隙是成功时隙的概率是节点之一传输而余下的 <br>
个节点不传输的概率，因此给定节点成功传输的概率为 ，因为有  个节点，成功传输的概率为
<br>最大效率为  (待补充)
<br><br>
<br>纯 ALOHA 中当一帧首次到达时，节点立刻将该帧完整传输进广播信道，如果传输的一个帧和多个传输经历了碰撞，这个节点将立刻以概率  传输该帧，否则，该节点等待一个帧传输时间
<br><br><img alt="Pasted image 20240404134242.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20240404134242.png"><br>
<br>待补充
<br><br><br>
<br>载波侦听 (carrier sensing)：一个节点在传输前先听信道，如果来自另一个节点的帧正向信道上发送，节点则等待直到检测到一小段时间没有传输，然后开始传输
<br>碰撞检测 (collision detection)：当一个传输节点在传输时一直在侦听此信道，如果它检测到另一个节点正在传输干扰帧，它就停止传输，在重复"侦听 - 当空闲时传输"循环之间等待一段随机时间
<br>这两个规则包含在载波侦听多路访问 (Carrier Sense Multiple Access, CSMA) 和具有碰撞检测的 CSMA (CSMA with Collision Detection, CSMA/CD) 协议族中
<br><br><img alt="Pasted image 20240404151417.png" src="/campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20240404151417.png"><br>
<br>比特沿着广播媒体传播实际需要时间，在经过一个短暂的时间后，B 发送的比特到达 D ，开始干扰 D 的传输
<br><br>
<br>两个节点在检测到碰撞后短时间内都放弃了比特的传输
<br>图图图图图图图
<br>适配器在经历碰撞后需要等待一个随机时间量，二进制指数后退算法 (binary exponential backoff) 解决了确定时间量的问题
<br><br>
<br>一个帧经历了  次碰撞，节点随机从  中选择一个  值，以太网节点等待的实际时间量是  (发送  比特进入以太网所需时间量的  倍)， 能够取的最大值在 10 以内
<br>从中选择  的集合长度随着碰撞次数呈指数增长，所以该算法被叫做指数后退
<br><br>
<br>CSMA/CD 效率 (efficiency of CSMA/CD)：当有大量的活跃节点，且每个节点有大量的帧要发送时，帧在信道中无碰撞地传输的那部分时间在长期运行时间中所占的份额
<br><br><br>
<br>节点之一被指定为主节点，主节点以循环的方式轮询 (poll) 每个节点
<br>轮询协议引入了轮询时延，即通知一个节点可以传输的时间
<br>主节点有故障，整个信道都变得不可操作
<br>每次活跃节点发送了了最多数量的帧时，主节点必须依次轮询每一个非活跃节点
<br><br>
<br>不存在主节点，一个成为令牌 (token) 的特殊帧在节点之间以某种固定的次序进行交换
<br>一个节点收到令牌时，仅当它有一些帧要发送时，它才持有该令牌，否则立刻向下一个节点转发令牌
<br>当节点有帧要传输，节点发送最大数目的帧数，然后把令牌转发给下一个节点
<br>节点故障可能会使整个信道崩溃
]]></description><link>campus/chinese-notes/计算机科学/计算机网络/链路层和局域网.html</link><guid isPermaLink="false">Campus/Chinese-Notes/计算机科学/计算机网络/链路层和局域网.md</guid><pubDate>Fri, 05 Apr 2024 03:35:19 GMT</pubDate><enclosure url="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231130170308.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="campus/chinese-notes/计算机科学/计算机网络/attachments/pasted-image-20231130170308.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🌟 Course-Notes]]></title><description><![CDATA[ 
 <br><br>Course-Note is a repository that contains White’s study materials and notes, used to document the process of acquiring knowledge.<br><img style="border-radius: 15px;" src="https://image.wh1te.dev/IMG_6931.png" referrerpolicy="no-referrer">]]></description><link>readme.html</link><guid isPermaLink="false">README.md</guid><pubDate>Fri, 22 Dec 2023 11:04:20 GMT</pubDate><enclosure url="https://image.wh1te.dev/IMG_6931.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://image.wh1te.dev/IMG_6931.png"&gt;&lt;/figure&gt;</content:encoded></item></channel></rss>