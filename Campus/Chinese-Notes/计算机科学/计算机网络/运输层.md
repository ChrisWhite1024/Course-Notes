# 概述和运输层服务
1. 逻辑通信 (logic communication)：
	1. 运输层协议为运行在不同主机的运用进程之间提供了逻辑通信功能
	2. 通过逻辑通信，运行不同进程的主机好像直接相连一样
2. 运输层协议在端系统中实现，发送端运输层将从发送应用程序进程接收到的报文转换成运输层报文段 (segment)，网路层将其封装成网络层分组（即数据报）并向目的地发送，接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层 ![[Pasted image 20231107111221.png]]
3. 网络层提供了主机之间的逻辑通信，运输层为运行在不同主机上的进程之间提供了逻辑通信
## 因特网运输层概述
1. 因特网为应用层提供了 [[应用层#UDP 服务|UDP]] (用户数据报协议) 和 [[应用层#TCP 服务|TCP]] (传输控制协议)
	1. UDP 为调用它的应用程序提供了一种不可靠、无连接的服务
	2. TCP 为调用它的应用程序提供了一种可靠的、面向连接的服务
2. 网际协议 (Internet Protocol)：网络层协议，为主机之间提供了逻辑通信
	1. 服务模型：尽力而为交付服务 (best-effort delivery service)，不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性
	2. 不可靠服务 (unreliable service)
	3. 每台主机至少有一个网络层地址
3. TCP 和 UDP 提供的服务模型：进程到进程的数据交付和差错检查 ![[IMG_6734.jpeg|600]]
	1. 将主机间交付拓展到进程间交付，运输层的多路复用 (transport-layer multiplexing) 和多路分解 (demultiplexing)
	2. 通过在其报文段首部中包括差错检查字段而提供完整性检查
4. TCP 提供的附加服务
	1. 可靠数据传输 (reliable data transfer)：通过流量控制、序号、确认和定时器，确保正确地、按序地将数据从发送进程交付给接收进程
	2. 拥塞控制 (congestion control)：力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽
# 多路复用与多路分解
1. 运输层没有直接将数据交付给进程，而是将数据交给了中间的套接字，每个套接字都有唯一的标识符 (端口号)
2. 多路分解 (demultiplexing)：将运输层报文段中的数据交付到正确的套接字
3. 多路复用 (multiplexing)：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层
4. 运输层报文段组成  ![[Pasted image 20231107151326.png|300]]
	1. 周知端口号 (well-known port number)：0～1023，保留给周知应用层协议使用 [RFC 3232]()
	2. 如果编写的代码实现的是一个周知协议的服务器端，就需要分配一个相应的周知端口号，通常应用程序的客户端让运输层自动地 (并且是透明地) 分配端口号，而服务器端则分配一个特定的端口号
### 无连接的多路复用与多路分解
1. UDP 套接字是由一个二元组全面标识的(一个目的 IP 地址和一个目的端口号)
2. 如果两个 UDP 报文段有不同的源 IP 地址和 / 或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程
3. 原端口号用作"返回地址"的一部分，在回发报文段时提取原端口号作为目的端口号
### 面向连接的多路复用和多路分解
1. TCP 套接字是由一个四元组(源 IP 地址，源端口号，目的 IP 地址，目的端口号)来标识的
2. 两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字，除非 TCP 报文段携带了初始创建连接的请求 ![[Pasted image 20231107164127.png]]
3. 对于服务器，在任意给定的时间内都可能有（具有不同标识的）许多连接套接字连接到相同的进程，服务器可以采用多种并发模型来处理多个连接，例如：
	◦	多进程模型（Forking）：对每个新连接，服务器可以 fork 一个新的进程来处理该连接。
	◦	多线程模型（Threading）：服务器可以为每个新连接创建一个新的线程。
	◦	事件驱动模型（Event-driven）：服务器使用非阻塞 IO 和事件循环，通过一个单独的进程或线程来管理所有连接。
	◦	异步 IO 模型：服务器利用操作系统提供的异步 IO 接口进行非阻塞 IO 操作，而不需要每个连接一个线程。
# 无连接运输：UDP
1. 应用程序更适合 UDP 的原因：
	1. 关于发送什么数据以及何时发送的应用层控制更为精细
	2. 无需连接建立：QUlC 协议（快速 UDP 因特网连接) 将 UDP 作为其支撑运输协议并在 UDP 之上的应用层协议中实现可靠性
	3. 无连接状态
	4. 分组首部开销小
2. 网络管理应用程序通常必须在该网络处于重压状态时运行，所以在这种场合下 UDP 要优于 TCP
3. UDP 中缺乏拥塞控制能够导致 UDP 发送方和接收方之间的高丢包率，并挤垮了 TCP 会话
4. 使用 UDP 的应用是可能实现可靠数据传输的 (eg. QUIC)
## UDP 报文段结构
```
                 0       7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |     Source      |   Destination   |
                 |      Port       |      Port       |
                 +--------+--------+--------+--------+
                 |                 |                 |
                 |     Length      |    Checksum     |
                 +--------+--------+--------+--------+
                 |
                 |          data octets ...
                 +---------------- ...

                      User Datagram Header Format
```
1. 由 RFC 768 定义 ![[Pasted image 20231107151302.png]]
2. 长度字段指示了在 UDP 报文段中的字节数 (首部加数据)
3. 接收方使用检验和来检查在该报文段中是否出现了差错
## UDP 检验和
- [RFC 768](https://datatracker.ietf.org/doc/html/rfc768)
- [RFC 1071](https://datatracker.ietf.org/doc/html/rfc1071)
### 检验和计算过程
```
				  0      7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |          source address           |
                 +--------+--------+--------+--------+
                 |        destination address        |
                 +--------+--------+--------+--------+
                 |  zero  |protocol|   UDP length    |
                 +--------+--------+--------+--------+

						Pseudo  Header  Format
```
1. `准备数据`：将 UDP 头部（除了校验和字段，该字段在计算时设为0）和数据载荷分为16位的字（2字节）。如果数据的字节总数不是偶数（即不能完全分成16位的字），则在最后添加一个额外的字节的填充（通常是0）以使之成对
2. `添加伪头部 `：根据 UDP 协议，校验和的计算应包含一个"伪头部"，它包括发送者和接收者的 IP 地址（各占4字节），一个8位的全0字段（用于占位，确保伪头部的格式与传输层数据段的其余部分保持一致），1字节的协议号（UDP 是17, 0x11），以及 UDP 数据报的长度
3. `反码求和`：使用 16 位反码运算，将所有的 16 位字加到一起。在这种加法中，如果任何一次加法结果超过 16 位，即最左边产生了进位，那么进位会被加回到计算结果的最低位。这就是所谓的“环绕”或“端到端进位”
4. `求和的反码`：将最终的求和结果进位的一部分和基本部分相加之后取反码，即将所有位从 0 变为 1 或从 1 变为 0，这就是要存储在校验和字段的值
5. `特殊情况`：如果计算出的检验和为 0，为防止将合法的检验和值 0 解释为没有使用检验和，发送端将检验和字段为 0 的情况下置为全 1
### 为什么 UDP 提供检验和
1. [端到端原则](https://en.wikipedia.org/wiki/End-to-end_principle#:~:text=The%20end%2Dto%2Dend%20principle,end%20nodes%20of%20the%20network.) (end-end principle)：因为某种功能（在此时为差错检测）必须基于端到端实现："与在较高级别提供这些功能的代价相比、在较低级别上设置的功能可能是冗余的或几乎没有价值的。"
	1. 虽然许多链路层协议提供了差错检测，但是不能保证源和目的之间所以链路都提供
	2. 报文段存储在路由器的内存中，也可能引入比特差错
2. 虽然 UDP 提供差错检测，但是 UDP 对差错恢复无能为力
# 可靠数据传输原理
![[Pasted image 20231108104230.png]]
1. 可靠数据传输为上层实体提供的服务抽象：数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特就不会受到损坏 (由 0 变为 1 或者相反) 或丢失，而且所有数据都是按照其发送顺序进行交付
2. 可靠数据传输协议 (reliable data transfer protocol)：将下层协议提供的不可靠信道封装成可靠信道
3. 考虑因素：底层信道
	1. 损坏比特
	2. 丢失分组
	3. 不会对分组重排序
4. 在本节中仅考虑[[因特网#^fa9487|单向数据传输]] (unidirectional data transfer) 的情况，不考虑可靠的 [[因特网#^86d918|双向数据传输]] (bidirectional data transfer)，但是需要注意本节实现协议需要在发送端和接收端两个方向上传输控制分组
## 构造可靠传输协议
-  [Principle of Reliable Data Transfer](https://hackmd.io/@bob840806/r1Q5GaMUX)
1. [有限状态机](https://en.wikipedia.org/wiki/Finite-state_machine) (Finite-State Machine, FSM)：一种计算的数学模型。作为一种抽象机器，FSM 可以在任何给定时间内处于有限数量的状态之一。FSM 可以根据一些输入从一个状态转换到另一个状态；从一个状态转换到另一个状态的变化称为转换。FSM 由其状态列表、初始状态和触发每个转换的输入定义 (PS：在宏观上看通用计算机也可以看作一个有限状态机哦，只是计算机的状态要比这里描述的状态机多得多得多，寄存器、cache、内存、外存的状态等随着指令的执行不断转换，其中存储数据的位模式不断改变)
### 经完全可靠信道的可靠数据传输：rdt 1.0
- 考虑底层信道是完全可靠的，既不出现比特损坏(位元错误)，也不丢失分组，分组还是按序到达的
![[Pasted image 20231108112409.png|350]] ![[Pasted image 20231108112423.png|350]]
1. 水平线上方为造成转移的事件，下方为事件发生时所采取的动作，若不采取任何动作则为空白
2. 发送端和接收端均只有一种状态即等待上/下层的调用
3. 函数作用
	1. `rdt_send(data)`：从上层接收数据 (如果可靠数据传输实现在 Layer4，那么这些数据就是 Layer5 注入 socket 的报文 (message)(可以是 HTTP 报文，SMTP 报文...))
	2. `make_pkt(packet, data)`：将上层数据(根据需要拆分)加上头部建立[[因特网#^23aa67|分组]] (注意⚠️：这里的分组指的是封包，在不同网络层级中的名称不同)
	3. `udt_send(packet)`：将此分组送入下层信道
	4. `rdt_rcv(packet)`：从下层信道接收分组
	5. `extract(packet,data)`：从分组中取出数据
	6. `deliver_data(data)`：将数据交给上层
 
![[Pasted image 20231108125514.png]]
```
                              ┌────────────┐               ┌────────────┐
                              │            │               │            │
                              │   sender   │               │  receiver  │
                              │            │               │            │
                              └────────────┘               └────────────┘
   layer 5           layer 4                    layer 3              layer 4             layer 5
                                     │                           │
┌────────────┐      waiting for      │                           │
│datadatadata│      layer 5          │                           │
│datadata    │      invocation       │                           │
└────────────┘                       │                           │
 layer 5 call   rdt_send(data)       │                           │  waiting for
                ───────────────────► │                           │  layer 3
                packet=make_pkt(data)│                           │  invocation
                udt_send(packet)     │                           │
                      ┌────────────┐ │                           │
                      │headdatadata│ │ layer 3 channel delivery  │
                      │datadatadata│ │         reliable          │
                      └────────────┘ │ ────────────────────────► │ ┌────────────┐
                                     │                           │ │headdatadata│
                                     │                           │ │datadatadata│
                                     │                           │ └────────────┘
                                     │              layer 3 call │ rdt_rcv(packet)
                    waiting for      │                           │ ────────────────────►
                    layer 5          │                           │ extract(packet,data)
                    invocation       │                           │ deliver_data(data)  ┌────────────┐
                                     │                           │                     │datadatadata│
                                     │                           │                     │datadata    │
                                     │                           │                     └────────────┘
                                     │                           │
                                     │                           │
                                     │                           │  waiting for
                                     │                           │  layer 3
   From:                             │                           │  invocation
   Chris White                       │                           │
                                     ▼                           ▼
```
### 经具有比特差错信道的可靠数据传输：rdt 2.0
- 考虑经过底层信道后分组的比特可能受损(1 变 0，0 变 1)
1. 通过肯定确认 (positive acknowledgement) 和否定确认 (negative acknowledgement)，接收方让发送方知道那些内容能被正确接收，哪些内容需要重传，于是有**自动重传请求 (Automatic Repeat reQuest, ARQ) 协议**
2. ARQ 协议基于三种机制
	1. `差错检测`：让接收端能够发现比特差错，UDP 使用[[运输层#检验和计算过程|反码求和]]的方式来检验
	2. `接收端反馈`：接收端反馈信息给发送端，ACK 代表成功，NAK 代表失败
	3. `重传`：分组有差错，就重传分组
3. 函数作用
	1. `make_pkt(data,checksum)`：计算 data 的 checksum 并且将数据封包
	2. `isNAK(rcvpkt)`：received packet为 NAK
	3. `isACK(rcvpkt)`：received packet 为 ACK
	4. `corrupt(rcvpkt)`：rcvpkt 有比特错误
	5. `notcorrupt(rcvpkt)`：rcvpkt 没有比特错误
![[Pasted image 20231108153309.png|]] ![[Pasted image 20231108153346.png]]
- 注意在 make packet 的过程中同时还有计算 checksum 的过程
1. 发送端具有两种状态
	1. 等待来自上层的调用，当接收上层的数据后进入状态 2，
	2. 等待接收端传送 ACK 或 NAK ，收到 ACK 转移到状态 1 并等待上层的下一个调用，收到 NAK 重传一次分组并重复状态 2
2. 接收端只有一种状态
	1. 根据收到的分组回传 ACK 或 NAK
3. 停等 (stop-and-wait)：发送方将不会发送一块新数据，除非发送方确信接收方已正确接收当前分组
4. 缺陷：未考虑 ACK 或 NAK 受损的可能性
#### rdt 2.1
1. 当发送端收到损坏的 ACK 或 NAK 分组时，就重传当前的数据分组，但是引入了一个问题，当接收方发送的 ACK 分组损坏时会收到冗余分组(duplicate packet)，而接收端分不清接收到的是新分组还是重传的分组 (发送 ACK 时接收端期望得到新分组但是 ACK 损坏后接收端会收到冗余分组，rdt 2.0接收端：🤔️😅🤪，发送 NAK 时接收端期望得到重传的分组则不会出现歧义)
2. 解决方法是在分组头部加入序号 (sequence number) 字段
3. 函数作用：
	1. `has_seq0(rcvpkt)`：接收分组的序号字段为 0
	2. `has_seq1(rcvpkt)`：接收分组的序号字段为 1
 ![[Pasted image 20231108203138.png]]
 ![[Pasted image 20231108203246.png]]![[杂项-9.jpg]]![[杂项-8.jpg]]
 1. 发送方最开始处于 `等待来自上层的调用0` 状态，当发送方发送一个 seq=0 的分组后，进入 `等待 ACK 或 NAK 0` 状态。
 2. 此时在 `等待来自下层的0` 的接收方出现两种情况，情况 1 接收方收到了无差错的分组返回一个 ACK 分组，并转换为 `等待来自下层的1` 状态，情况 2 接收方收到了有差错的分组返回一个 NAK 分组，并且保持当前状态
 3. 当 `等待 ACK 或 NAK 0` 状态的发送方收到确认分组时，出现三种情况，情况 1 收到 ACK 分组，情况 2 收到 NAK 分组，情况 3 分组出现了差错，情况 1 时分组转换为 `等待来自上层的调用1` 状态，进入下半个周期，情况 2 与情况 3 时发送端重传 seq=0 的分组并保持当前状态等待确认分组
 4. 当接收方再次收到重传的 seq=0 分组时，接收方可能存在两种状态，第一种 2 中的报文出现了差错，仍然停留在 `等待来自下层的0` 状态，第二种 2 中的报文已经被接收送往上层，转换为 `等待来自下层的1` 状态，第一种状态下跳转至 2，第二种状态存在两种情况，情况 1 重传的 seq=0 分组完好，此时接收方发送 ACK 分组，情况 2  重传的 seq=0 分组出现差错，此时接收方发送 NAK 分组，跳转至 3，直至发送端接收到 ACK 分组转换为 `等待来自上层的调用1` 状态
#### rdt 2.2
![[Pasted image 20231109085428.png]]
![[Pasted image 20231109085444.png]]
### 经具有比特差错的丢包信道的可靠数据传输：rdt 3.0
1. 除了比特受损以外，底层信道还会出现丢包的情况
2. 这里将检测和回复丢包的工作都交给发送端处理
3. 发送方发送的数据分组或接收方对该分组的 ACK 发生了丢失，发送方都接收不到来自接收方的响应，如果发送方愿意等待足够长的时间以便确定分组已丢失，则它只需重传该数据分组即可
4. 理想的协议应尽可能快地从丢包中回复过来，所以对等待时间的选择非常重要，如果在这段时间内没收到 ACK 则重传该分组，如果分组经历了一个特别大的时延，发送端也会重传该分组，即使数据分组和 ACK 都没丢失，于是在信道中引入了冗余数据分组 (duplicate data packet)
5. 倒数定时器 (countdown timer)：在一个给定时间量后，可中断发送方
	1. 发送方每次发送一个分组，便启动一个定时器
	2. 响应定时器中断
	3. 中止定时器
6. 因为分组序号在 0 和 1 之间交替，rdt 3.0 被称为比特交替协议 (alternating-bit protocol)
![[Pasted image 20231109091635.png]] ![[Pasted image 20231109091802.png]]
- 数据传输协议的要点
	- 检验和
	- 序号
	- 定时器
	- 肯定的否定确认
## 流水线可靠数据传输协议
1. 考虑一种情况，两个端系统之间的 [[应用层#^c4f1a1|RTT]]  为 $30ms$ ，通过一条发送速率 $R$ 为 $1Gbps$ 的信道相连，包括首部字段和数据的分组 $L$ 为 $1000Bytes$ ，将分组送入信道的 [[因特网#^2ad19c|传输时延]] 为 $$d_{trans}=\frac{L}{R}=\frac{8000bit/pkt}{10^9bit/s}=8\,\mu\mathrm{s}/pkt$$
2. 信道的利用率 (utilization)：发送方将分组送进信道的传输时延，与发送时间之比 ($RTT + d_{trans}$) (ACK 分组太小，接收端返回 ACK 的传输时延忽略不计)，还忽略了发送方和接收方的底层协议处理时间，和可能出现的路由器处理和排队实验 $$U_{sender}=\frac{L/R}{RTT+L/R}=\frac{0.008}{30.008}=0.00027$$
3. 使用流水线技术 (pipelining)：![[Pasted image 20231109101141.png]]
	1. 增加序号范围
	2. 发送方和接收方缓存多个分组，发送方最低限度应该缓存发送但未被确认的分组
	3. 差错恢复的两种基本方法：回退 N 步 (Go-Back-N, GBN)和选择重传 (Selective Repeat, SR)
### 回退 N 步
![[Pasted image 20231109103751.png]]
1. 基序号 (base)：最早未确认的分组
2. 下一个序号 (nextseqnum)：下一个待发分组的序号
3. N 常被称为窗口长度 (window size)，GBN 协议也常被称为滑动窗口协议 (sliding-window protocol)
4. 分组的序号承载在分组首部的定长字段中，如果分组序号字段的比特数是 `k`，则该序号的范围是 $[0, 2^k-1]$ ，TCP 有一个 32bit 的序号字段，TCP 序号是按字节流中的字节进行计数的，而不是按分组计数
5. GBN 发送方需要相应三种类型的事件：![[Pasted image 20231109143937.png]]
	1. 上层调用：当收到来自上层的调用时需要检查窗口是否已满，如果未满则发送一个分组，如果已满则将数据返回给上层让上层一会再试，实际情况中发送方可能缓存这个数据，或者使用同步机制允许上层在窗口不满时才调用
	2. 收到一个 ACK ：更新 base，如果有已发送但未被确认的分组，则定时器被重新启动，如果没有已发送但未被确认的分组，则停止定时器
	3. 超时事件：如果出现超时，发送方重传所有已发送但未被确认过的分组
6. 接收方动作：![[Pasted image 20231109143951.png]]
	1. 如果序号为 n 的分组按序到达，则为分组 n 发送一个 ACK n，如果到达的分组不是 n (失序)，则丢弃该分组等待发送端重传
7. 基于事件的编程 (event-based programming) 方式：在协议栈中对拓展 FSM 的实现以各种过程形式出现，每个过程实现了在响应可能出现的事件时要采取的动作，可能出现的事件
	1. 上层实体调用
	2. 定时器中断
	3. 下层实体调用
### 选择重传
1. GBN 本身存在着一些性能问题，当窗口长度和带宽时延积都很大时，流水线中有很多分组，单个分组的差错就能引起 GBN 重传大量分组
2. 选择重传 (SR) 协议通过让发送方仅重传怀疑在接收方出错的分组避免了不必要的重传
3. SR 发送方的事件与动作：![[Pasted image 20231109150700.png]]
	1. `从上层收到数据`：若 $nextseqnum<base + N$，则将数据打包并发送，否则将数据缓存或返回给上层
	2. `超时`：每个分组必须拥有自己的逻辑定时器，超时发生后只能发送一个分组
	3. `收到ACK`：若分组序号在窗口内，则 SR 发送方将被确认的分组标记为已接收，若分组的序号等于 send_base 则将窗口基序号向前移动到最小的未确认分组处，如果窗口已到了有序号落在窗口内的未发送分组，则发送这些分组
4. SR 接收方的事件与动作：![[Pasted image 20231109151435.png]]
	1. `序号在[rcv_base, rcv_base + N - 1]` 内的分组被正确接收：回传选择 ACK (与当前收到分组 seq 对应) ，在接收端如果该分组以前没收到过，且序号大于接收窗口的基序号 (图中 rcv_base + 123的黑框框) 时，这些分组是失序分组，由接收端缓存，如果序号等于接收窗口的基序号 (rcv_base) 时，则将该分组及以前缓存的序号连续失序分组 (图中的 rcv_base + 1, rcv_base + 2, rcv_base + 3 的黑框框)交付给上层，接收窗口向前移动到下一个未交付的分组处 (图中 rcv_base + 4)
	2. `序号在[rcv_base - N, rcv_base - 1]` 内的分组被正确接收：必须产生一个 ACK (与分组 seq 对应)，此分组出现的原因是接收端已经收到分组移动窗口，但返回的 ACK 损坏，发送端重传该分组，为了让发送端接收到 ACK 确认并让发送端窗口向前移动，所以要产生 ACK 
	3. `其他情况`：若出现分组损坏等情况则忽略该分组等待发送端重传
5. 发送方和接收方件的窗口长度必须小于或等于序号空间大小的一半否则会引起歧义，接收方不知道接收到的下个分组是重传的还是发送方窗口滑动后发送的新分组
6. 先前假定分组在发送方和接收方的信道中不能被重新排序，但是实际上重新排序有可能发生，以前被发向信道但被认为丢失了的分组可能会突然出现，为了确保序号不被重新使用，发送方在发送序号为 x 的分组时需要确信任何先前发送过的序号为 x 的分组都不在网络中，通过假定分组在网络中的存活时间不会超过某个固定最大时间量来做到这一点
# 面向连接的运输：TCP