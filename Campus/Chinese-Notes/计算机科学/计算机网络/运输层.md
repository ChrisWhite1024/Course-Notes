# 概述和运输层服务
1. 逻辑通信 (logic communication)：
	1. 运输层协议为运行在不同主机的运用进程之间提供了逻辑通信功能
	2. 通过逻辑通信，运行不同进程的主机好像直接相连一样
2. 运输层协议在端系统中实现，发送端运输层将从发送应用程序进程接收到的报文转换成运输层报文段 (segment)，网路层将其封装成网络层分组（即数据报）并向目的地发送，接收端，网络层从数据报中提取运输层报文段，并将该报文段向上交给运输层 ![[Pasted image 20231107111221.png]]
3. 网络层提供了主机之间的逻辑通信，运输层为运行在不同主机上的进程之间提供了逻辑通信
## 因特网运输层概述
1. 因特网为应用层提供了 [[应用层#UDP 服务|UDP]] (用户数据报协议) 和 [[应用层#TCP 服务|TCP]] (传输控制协议)
	1. UDP 为调用它的应用程序提供了一种不可靠、无连接的服务
	2. TCP 为调用它的应用程序提供了一种可靠的、面向连接的服务
2. 网际协议 (Internet Protocol)：网络层协议，为主机之间提供了逻辑通信
	1. 服务模型：尽力而为交付服务 (best-effort delivery service)，不确保报文段的交付，不保证报文段的按序交付，不保证报文段中数据的完整性
	2. 不可靠服务 (unreliable service)
	3. 每台主机至少有一个网络层地址
3. TCP 和 UDP 提供的服务模型：进程到进程的数据交付和差错检查 ![[IMG_6734.jpeg|600]]
	1. 将主机间交付拓展到进程间交付，运输层的多路复用 (transport-layer multiplexing) 和多路分解 (demultiplexing)
	2. 通过在其报文段首部中包括差错检查字段而提供完整性检查
4. TCP 提供的附加服务
	1. 可靠数据传输 (reliable data transfer)：通过流量控制、序号、确认和定时器，确保正确地、按序地将数据从发送进程交付给接收进程
	2. 拥塞控制 (congestion control)：力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽
# 多路复用与多路分解
1. 运输层没有直接将数据交付给进程，而是将数据交给了中间的套接字，每个套接字都有唯一的标识符 (端口号)
2. 多路分解 (demultiplexing)：将运输层报文段中的数据交付到正确的套接字
3. 多路复用 (multiplexing)：在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层
4. 运输层报文段组成  ![[Pasted image 20231107151326.png|300]]
	1. 周知端口号 (well-known port number)：0～1023，保留给周知应用层协议使用 [RFC 3232]()
	2. 如果编写的代码实现的是一个周知协议的服务器端，就需要分配一个相应的周知端口号，通常应用程序的客户端让运输层自动地 (并且是透明地) 分配端口号，而服务器端则分配一个特定的端口号
### 无连接的多路复用与多路分解
1. UDP 套接字是由一个二元组全面标识的(一个目的 IP 地址和一个目的端口号)
2. 如果两个 UDP 报文段有不同的源 IP 地址和 / 或源端口号，但具有相同的目的 IP 地址和目的端口号，那么这两个报文段将通过相同的目的套接字被定向到相同的目的进程
3. 原端口号用作"返回地址"的一部分，在回发报文段时提取原端口号作为目的端口号
### 面向连接的多路复用和多路分解
1. TCP 套接字是由一个四元组(源 IP 地址，源端口号，目的 IP 地址，目的端口号)来标识的
2. 两个具有不同源 IP 地址或源端口号的到达 TCP 报文段将被定向到两个不同的套接字，除非 TCP 报文段携带了初始创建连接的请求 ![[Pasted image 20231107164127.png]]
3. 对于服务器，在任意给定的时间内都可能有（具有不同标识的）许多连接套接字连接到相同的进程，服务器可以采用多种并发模型来处理多个连接，例如：
	◦	多进程模型（Forking）：对每个新连接，服务器可以 fork 一个新的进程来处理该连接。
	◦	多线程模型（Threading）：服务器可以为每个新连接创建一个新的线程。
	◦	事件驱动模型（Event-driven）：服务器使用非阻塞 IO 和事件循环，通过一个单独的进程或线程来管理所有连接。
	◦	异步 IO 模型：服务器利用操作系统提供的异步 IO 接口进行非阻塞 IO 操作，而不需要每个连接一个线程。
# 无连接运输：UDP
1. 应用程序更适合 UDP 的原因：
	1. 关于发送什么数据以及何时发送的应用层控制更为精细
	2. 无需连接建立：QUlC 协议（快速 UDP 因特网连接) 将 UDP 作为其支撑运输协议并在 UDP 之上的应用层协议中实现可靠性
	3. 无连接状态
	4. 分组首部开销小
2. 网络管理应用程序通常必须在该网络处于重压状态时运行，所以在这种场合下 UDP 要优于 TCP
3. UDP 中缺乏拥塞控制能够导致 UDP 发送方和接收方之间的高丢包率，并挤垮了 TCP 会话
4. 使用 UDP 的应用是可能实现可靠数据传输的 (eg. QUIC)
## UDP 报文段结构
```
                 0       7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |     Source      |   Destination   |
                 |      Port       |      Port       |
                 +--------+--------+--------+--------+
                 |                 |                 |
                 |     Length      |    Checksum     |
                 +--------+--------+--------+--------+
                 |
                 |          data octets ...
                 +---------------- ...

                      User Datagram Header Format
```
1. 由 RFC 768 定义 ![[Pasted image 20231107151302.png]]
2. 长度字段指示了在 UDP 报文段中的字节数 (首部加数据)
3. 接收方使用检验和来检查在该报文段中是否出现了差错
## UDP 检验和
- [RFC 768](https://datatracker.ietf.org/doc/html/rfc768)
- [RFC 1071](https://datatracker.ietf.org/doc/html/rfc1071)
### 检验和计算过程
```
				  0      7 8     15 16    23 24    31
                 +--------+--------+--------+--------+
                 |          source address           |
                 +--------+--------+--------+--------+
                 |        destination address        |
                 +--------+--------+--------+--------+
                 |  zero  |protocol|   UDP length    |
                 +--------+--------+--------+--------+

						Pseudo  Header  Format
```
1. `准备数据`：将 UDP 头部（除了校验和字段，该字段在计算时设为0）和数据载荷分为16位的字（2字节）。如果数据的字节总数不是偶数（即不能完全分成16位的字），则在最后添加一个额外的字节的填充（通常是0）以使之成对
2. `添加伪头部 `：根据 UDP 协议，校验和的计算应包含一个"伪头部"，它包括发送者和接收者的 IP 地址（各占4字节），一个8位的全0字段（用于占位，确保伪头部的格式与传输层数据段的其余部分保持一致），1字节的协议号（UDP 是17, 0x11），以及 UDP 数据报的长度
3. `反码求和`：使用 16 位反码运算，将所有的 16 位字加到一起。在这种加法中，如果任何一次加法结果超过 16 位，即最左边产生了进位，那么进位会被加回到计算结果的最低位。这就是所谓的“环绕”或“端到端进位”
4. `求和的反码`：将最终的求和结果进位的一部分和基本部分相加之后取反码，即将所有位从 0 变为 1 或从 1 变为 0，这就是要存储在校验和字段的值
5. `特殊情况`：如果计算出的检验和为 0，为防止将合法的检验和值 0 解释为没有使用检验和，发送端将检验和字段为 0 的情况下置为全 1
### 为什么 UDP 提供检验和
1. [端到端原则](https://en.wikipedia.org/wiki/End-to-end_principle#:~:text=The%20end%2Dto%2Dend%20principle,end%20nodes%20of%20the%20network.) (end-end principle)：因为某种功能（在此时为差错检测）必须基于端到端实现："与在较高级别提供这些功能的代价相比、在较低级别上设置的功能可能是冗余的或几乎没有价值的。"
	1. 虽然许多链路层协议提供了差错检测，但是不能保证源和目的之间所以链路都提供
	2. 报文段存储在路由器的内存中，也可能引入比特差错
2. 虽然 UDP 提供差错检测，但是 UDP 对差错恢复无能为力
# 可靠数据传输原理
![[Pasted image 20231108104230.png]]
1. 可靠数据传输为上层实体提供的服务抽象：数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特就不会受到损坏 (由 0 变为 1 或者相反) 或丢失，而且所有数据都是按照其发送顺序进行交付
2. 可靠数据传输协议 (reliable data transfer protocol)：将下层协议提供的不可靠信道封装成可靠信道
3. 考虑因素：底层信道
	1. 损坏比特
	2. 丢失分组
	3. 不会对分组重排序
4. 在本节中仅考虑[[因特网#^fa9487|单向数据传输]] (unidirectional data transfer) 的情况，不考虑可靠的 [[因特网#^86d918|双向数据传输]] (bidirectional data transfer)，但是需要注意本节实现协议需要在发送端和接收端两个方向上传输控制分组
## 构造可靠传输协议
-  [Principle of Reliable Data Transfer](https://hackmd.io/@bob840806/r1Q5GaMUX)
1. [有限状态机](https://en.wikipedia.org/wiki/Finite-state_machine) (Finite-State Machine, FSM)：一种计算的数学模型。作为一种抽象机器，FSM 可以在任何给定时间内处于有限数量的状态之一。FSM 可以根据一些输入从一个状态转换到另一个状态；从一个状态转换到另一个状态的变化称为转换。FSM 由其状态列表、初始状态和触发每个转换的输入定义 (PS：在宏观上看通用计算机也可以看作一个有限状态机哦，只是计算机的状态要比这里描述的状态机多得多得多，寄存器、cache、内存、外存的状态等随着指令的执行不断转换，其中存储数据的位模式不断改变)
### 经完全可靠信道的可靠数据传输：rdt 1.0
- 考虑底层信道是完全可靠的，既不出现比特损坏(位元错误)，也不丢失分组，分组还是按序到达的
![[Pasted image 20231108112409.png|350]] ![[Pasted image 20231108112423.png|350]]
1. 水平线上方为造成转移的事件，下方为事件发生时所采取的动作，若不采取任何动作则为空白
2. 发送端和接收端均只有一种状态即等待上/下层的调用
3. 函数作用
	1. `rdt_send(data)`：从上层接收数据 (如果可靠数据传输实现在 Layer4，那么这些数据就是 Layer5 注入 socket 的报文 (message)(可以是 HTTP 报文，SMTP 报文...))
	2. `make_pkt(packet, data)`：将上层数据(根据需要拆分)加上头部建立[[因特网#^23aa67|分组]] (注意⚠️：这里的分组指的是封包，在不同网络层级中的名称不同)
	3. `udt_send(packet)`：将此分组送入下层信道
	4. `rdt_rcv(packet)`：从下层信道接收分组
	5. `extract(packet,data)`：从分组中取出数据
	6. `deliver_data(data)`：将数据交给上层
 
![[Pasted image 20231108125514.png]]
```
                              ┌────────────┐               ┌────────────┐
                              │            │               │            │
                              │   sender   │               │  receiver  │
                              │            │               │            │
                              └────────────┘               └────────────┘
   layer 5           layer 4                    layer 3              layer 4             layer 5
                                     │                           │
┌────────────┐      waiting for      │                           │
│datadatadata│      layer 5          │                           │
│datadata    │      invocation       │                           │
└────────────┘                       │                           │
 layer 5 call   rdt_send(data)       │                           │  waiting for
                ───────────────────► │                           │  layer 3
                packet=make_pkt(data)│                           │  invocation
                udt_send(packet)     │                           │
                      ┌────────────┐ │                           │
                      │headdatadata│ │ layer 3 channel delivery  │
                      │datadatadata│ │         reliable          │
                      └────────────┘ │ ────────────────────────► │ ┌────────────┐
                                     │                           │ │headdatadata│
                                     │                           │ │datadatadata│
                                     │                           │ └────────────┘
                                     │              layer 3 call │ rdt_rcv(packet)
                    waiting for      │                           │ ────────────────────►
                    layer 5          │                           │ extract(packet,data)
                    invocation       │                           │ deliver_data(data)  ┌────────────┐
                                     │                           │                     │datadatadata│
                                     │                           │                     │datadata    │
                                     │                           │                     └────────────┘
                                     │                           │
                                     │                           │
                                     │                           │  waiting for
                                     │                           │  layer 3
   From:                             │                           │  invocation
   Chris White                       │                           │
                                     ▼                           ▼
```
### 经具有比特差错信道的可靠数据传输：rdt 2.0
- 考虑经过底层信道后分组的比特可能受损(1 变 0，0 变 1)
1. 通过
