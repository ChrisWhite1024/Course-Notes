# 网络层-控制平面
1. 控制平面不仅控制沿着从源主机到目的主机的端到端路径间的路由器如何转发数据报，而且控制网络层组件和服务如何配置和管理
2. OSPF 是一种运行在单一 ISP 网络中的路由选择算法，BGP 是一种在因特网中用于互联所有网络的路由选择算法
# 概述
1. 计算、维护和安装转发表与流表的方法：
	1. `每路由器控制`：每台路由器有一个路由选择组件，用于与其他路由器中的路由选择组件通信，以计算其转发表的值，OSPF 和 BGP 协议都基于这种方法
	2. `逻辑集中式控制`：[[网络层-数据平面#^7fd436|通用转发]] 允许执行除了传统 IP 转发外的其他功能，这些功能原来通常是在单独的[[网络层-数据平面#^cebafe|中间盒]] 中实现的
2. 每路由器控制和逻辑集中式控制之间的**关键差异**：路由器中的控制组件能否相互交互并主动参与计算转发表 ![[Pasted image 20231122115215.png]]
3. 逻辑集中式控制路由选择控制服务出于容错和性能扩展性的原因，很可能由多个服务器实现
# 路由选择算法
1. 路由选择算法 (routing algorithm) 的目的：从发送方到接收方的过程中确定一条通过路由器网络的好的路径 ![[Pasted image 20231122120530.png]]
2. 图 (graph) $G=(N,E)$ 是一个 $N$ 个节点和 $E$ 条边的集合，每条边是取自 $N$ 的一对节点，用 $c(x,y)$ 表示连接节点 $x$ 和 $y$ 边的开销，如果 $(x,y)$ 不属于 $E$，则 $c(x,y)=\infty$ ，如果属于 $E$ 则节点 $y$ 为节点 $x$ 的领居(neighbor)  ![[Pasted image 20231122161720.png|400]]
3. 路由选择算法的目标找出从源到目的地间的最低开销路径 (least-cost path)，若图中的所有边具有相同的开销，则最低开销路径也是最短路径 (shortest path)
4. 路由选择算法分类：
	1. 根据集中式还是分散式
		1. `集中式路由选择算法(centralized routing algorithm)`：用完整的、全局性的网络知识计算出从源到目的地之间的最低开销路径，具有全局状态信息的算法常被称作**链路状态 (Link State, LS) 算法**
		2. `分散式路由选择算法(decetralized routing algorithm)`：路由器以迭代、分布式的方式计算出最低开销路径。没有节点拥有关于所有网络链路开销的完整信息，之后学习的**距离向量 (Distance-Vector, DV) 算法**就是分散式路由选择算法
	2. 根据静态的还是动态的
		1. `静态路由选择算法(static routing algorithm)`：路由随时间变化慢，通常是人工调整
		2. `动态路由选择算法(dynamic routing algorithm)`：随着网络流量负载或拓扑发生变化而变化
	3. 根据负载敏感还是负载迟钝
		1. `负载敏感算法(load-sensitive algorithm)`：链路开销动态变化以反映出底层链路的当前拥塞水平
		2. `负载迟钝算法(load-insentitive algorithm)`：链路开销不明确反映拥塞水平
## LS 算法
1. 实践中是让每个节点向网络中的所有其他节点广播链路状态分组来实现 (链路状态广播 link state broadcast 算法)
2. 所有节点都拥有网络的完整视图
3. Dijkstra 算法 [@TuWenXiangJieDijkstraZuiDuanLuJingSuanFa2021][@DijkstraAlgorithm2023]：计算从某节点到达网络中所有其他节点的最低开销路径 ![[Dijkstra.excalidraw|800]]
	1. 经过算法的 $k$ 次迭代后，可知道 $k$ 个目的节点的最低开销路径
4. 当 LS 算法中止时，对于每一个节点，都可以得到从源节点沿着最低开销路径的前一节点 (可回溯)，通过对每个目的节点存放从 $u$ 到目的地的最低开销路径上的下一跳节点，从而可以构建转发表 ![[Pasted image 20231123163847.png|600]]
5. 拥塞敏感的路由选择的振荡 ![[Pasted image 20231123165211.png]]
	1. 考虑图中的情况，节点 $x$ 和 $z$ 向节点 $w$ 发出造成链路开销为 1 的流量，节点 $y$ 向节点 $w$ 发出开销为 e 的流量了
	2. 如果路由选择算法拥塞敏感，则在第二次接收到同样开销的流量运行 LS 算法时，节点 $y$ 会根据第一次的链路开销选择 `y -> z -> w` 的路径，由于在第一次情况下 `y -> x -> w` 总开销为 $e+1+e$ 而 `y -> z -> w` 的总开销只有 $0+1$ ，相类似的节点 $x$ 和 $z$ 都会选择顺时针方向发送流量
	3. 同样当第三次执行 LS 算法时所有的流量均逆时针发出，第四次则全为顺时针，造成振荡
	4. 防止这种情况出现的方法是让所有的路由器在同一周期的不同时刻运行 LS 算法，但是在运行一段时间后路由器会发生自同步现象，避免这种现象的方法是让每台路由器发送链路通告的时间随机化
## DV 算法
1. 分布式：每个节点都要从一个或多个直接相连邻居接收某些信息，执行计算，然后将其计算结果分发给邻居
2. 迭代：此过程一直要持续到邻居之间无更多信息要交换为止
3. 异步：不要求所有节点相互之间步伐一致地操作
4. Bellman-Ford 方程 $$d_x(y)=min_v\{c(x,v)+d_v(y)\}$$
	1. 遍历 $x$ 的所有相邻节点 $v$，从 $x$ 到 $y$ 的最低开销时所有相邻节点 $v$ 的 $c(x, v)+d_v(y)$ 的最小值 (待补充)
	2. 令 $v^{*}$ 为取得方程最小值的相邻节点，若节点 $x$ 要沿着最低开销路径向节点 $y$ 发送一个分组，它应当先向 $v^{*}$ 发送分组，所以节点 $x$ 的转发表指定节点 $v^{*}$ 作为下一跳路由器
5. 使用 DV 算法，每个节点维护一个下列路由选择信息
	1. 到所有相邻节点的开销 $v$ 
	2. 节点 $x$ 的距离向量 $D_x=[D_x(y):y\in N]$ 包含 $x$ 到 $N$ 中所有目的地 $y$ 的开销估计值，注意 $D_x(y)$ 只是该距离向量的一个分量 (之后的叙述中可能会将这两个概念混淆，因为发送的是完整的距离向量，然而在下文的例子中通常只更新其中一个分量)
	3. 每个邻居的距离向量 $D_v=[D_v(y):y\in N]$
6. 每个节点不时向每个邻居发送距离向量，当节点 $x$ 从任何一个邻居 $v$ 接收到新距离向量时，它保存该距离向量，然后使用 Bellman-Ford 方程更新自己的距离向量，如果 $x$ 的距离向量发生了变化，则 $x$ 向所有的邻居发送更新后的距离向量，从而让所有邻居更新自身的距离向量，只要所有的节点以异步方式交换自己的距离向量，则每个开销估计值 $D_x(y)$ 会收敛到 $d_x(y)$ (节点 $x$ 到节点 $y$ 的最低开销路径的开销)
7. 为了一个给定路径 $y$ 而更新转发表，节点 $x$ 关注的是沿着最短路径到 $y$ 的下一跳路由器邻居节点 $v^{*}(y)$ 
### 链路开销改变与链路故障
1. 如果运行 DV 算法的节点检测到从自己到邻居的链路开销发生变化时，它就更新自己的距离向量，如果到该邻居的距离向量分量发生了变化，则向所有邻居通知新的距离向量
2. 路由选择环路 (routing loop) ![[Pasted image 20231124103355.png|500]]
	1. 假设链路开销变化时，$D_y(x)=4$，$D_y(z)=1$，$D_z(y)=1$，$D_z(x)=5$ ，则 $t_0$ 时刻当 $y$ 检测到链路开销变化时 (从开销 4 变为 60)，$y$ 计算到 $x$ 的新的距离向量的分量 `y -> x -> x` 和 `y -> z -> x` 相比较 $$D_y(x)=\min\{c(y,x)+D_x(x),c(y,z)+D_z(x)\}=\min\{60+0,1+5\}=6$$
	2. 这时遇到了路由选择环路，发出的分组为了到达 $x$ ，$z$ 认为应该向 $y$ 转发，而 $y$ 认为应该向 $x$ 转发，分组于是在这两个节点之间不停地来回反复
	3. 此时节点 $y$ 计算出 $D_y(x)=6$ 所以在 $t_1$ 时刻将更新后的距离向量告诉 $z$
	4. 在 $t_2$ 时刻，$z$ 收到 $y$ 的新距离向量，指示了 $y$ 到 $x$ 的最低开销是 6 ，$z$ 计算到 $x$ 的最低开销 $D_z(x)=\min\{50+0,1+6\}=7$ (这时 $z$ 已经知道了 `z -> x` 的链路开销发生了变化)，并在计算完后 $t_3$ 时刻通知 $y$ 其新开销
	5. 当 $y$ 在 $t_4$ 时刻收到 $z$ 的通知时，计算到 $x$ 的最低开销 $D_y(x)=\min\{60+0,1+7\}=8$ 并向 $z$ 发送距离向量，随后 $z$ 计算得到 $D_z(x)=9$ 并向 $y$ 发送距离向量
	6. 如此反复直到 $y$ 向 $z$ 发送距离向量 $D_y(x)=50$ ，此时 $z$ 到 $x$ 的最低开销链路切换为 `z —> x`，再发送接收一个迭代后，进入静止状态，此时为了让分组到达 $x$ ，$z$ 会直接选择直接向 $x$ 转发，路由选择环路状态结束
### 增加毒性逆转 (poisoned reverse)[@SplitHorizonRoute2023]
1. 如果 $z$ 通过 $y$ 路由选择到目的地 $x$ ，则 $z$ 将通告 $y$ $D_z(x)=\infty$  ，此时 $y$ 相信 $z$ 没有到 $x$ 的路径，通过这个善意的谎言，$y$ 将不会试图经由 $z$ 路由选择到 $x$ 
2. $y$ 更新其距离向量，分量 $D_y(x)=\min\{60+0,1+\infty\}=60$ ，并将新的距离向量发送给 $z$ 
3. 此时 $z$ 更新距离向量并通知 $y$  $D_z(x)=50$
4. 收到 $z$ 的更新后 $y$ 用 $D_y(x)=51$ 更新距离表，但是为了毒化逆向路径，$y$ 向 $z$ 通告 $D_y(x)=\infty$
5. 注意如果涉及 3 个或更多节点无法用毒性逆转技术检测
### LS 和 DV 算法比较
1. LS 要求每个节点通过广播与**所有节点**通信，但只告诉所有节点与该节点之间相连的链路开销，以便确定全局信息
2. DV 中每个节点仅与所有**相邻节点**通信，但为相邻节点提供了自己到网络中所有节点的最低开销估计
3. LS 算法的的复杂性为 $O(|N|^2)$
4. LS 由于各节点执行各自的计算，提供了一定程度的健壮性，而 DV 算法一个不正确的节点计算值会扩散到整个网络
# 自治系统内部的路由选择：OSPF
1. 实践中上文介绍的模型有一些简单化，原因有
	1. 规模：随着路由器数目变得很大，涉及路由选择信息的通信、计算和存储的开销将高得不可实现
	2. 管理自治：在理想情况下，一个组织应当能够按自己的愿望运行和管理其网络，还要能将其网络与其他外部网络连接起来
2. 自治系统 (Autonomous System, AS)：每个 AS 由一组通常处在相同管理控制下的路由器组成，ISP 可将其网络划分为一个或多个 AS ，AS 号由 ICANN 所分配
3. 在一个 AS 中运行的路由选择算法叫做**自治系统内部路由选择协议 (intra-autonomous system routing protocol)**
4. 开放最短路优先 (OSPF) 是一种链路状态协议[@moyOSPFVersion1998]，使用洪泛链路状态信息和 Dijkstra 最低开销路径算法，路由器构建了关于整个自治系统的完整拓扑图，通过 Dijkstra ，路由器可以确定一个以自身为根节点到所有子网的最短路径树
5. 各条链路的开销可以由网络管理员配置，但 OSPF 不强制使用设置链路权值的策略
	1. 将每条链路开销设置为 1 可以实现最少跳路由选择
	2. 将链路权值与链路容量设为反比，不鼓励流量使用低带宽链路
6. 使用 OSPF 时，路由器向自治系统内所有其他路由器广播路由选择信息
	1. 每当链路的状态发生变化，路由器广播链路状态信息
	2. 链路的状态不发生变化，路由器也要周期广播链路状态，可以增加链路状态算法的健壮性
7. OSPF 协议报文直接由 IP 承载，所以 OSPF 需要自己实现可靠报文传输，链路状态广播等功能
8. OSPF 的优点
	1. 安全：使用鉴别机制
	2. 多条相同开销的路径
	3. 对单播和多播路由选择的总和支持
	4. 支持在单个 AS 中的层次结构：在每个区域内，一台或多台区域边界路由器向该区域内所有其他路由器广播其链路状态
# ISP 之间的路由选择：BGP
1. 分组跨越多个 AS 进行路由时，需要**自治系统间路由选择协议 (inter-autonomous system routing protocol)**
2. 因特网中，所有的 AS 运行相同的 AS 间选择协议，称为边界网关协议 (Broader Gateway Protocol, BGP)
## BGP 的作用
1. 对于相同 AS 中的目的地而言，在路由器转发表中的表项由 AS 内部路由选择协议决定
2. BGP 中分组不是路由到一个特定的目的地址，而是路由到 [[网络层-数据平面#^821595|CIDR]] 化的前缀
3. BGP 为每台路由器提供了一种完成以下任务的手段
	1. 从邻居 AS 获得前缀的可达性信息
	2. 确定该前缀的"最好的"路由
## 通告 BGP 路由信息
![[Pasted image 20231127104059.png]]
1. 对于每个 AS ，每台路由器要么是一台**网关路由器 (gateway router)**，要么是一台**内部路由器 (internal router)**，网关路由器位于 AS 边缘，内部路由器仅连接自己 AS 中的主机和路由器[@ShiMeShiBGPBGP]
2. 从高层次 (AS) 上考虑，若要向所有路由器通告前缀 $x$ 的可达性信息
	1. AS3 向 AS2 发送一个 BGP 报文 `AS3 x`，告诉  $x$ 存在并位于 AS3 中
	2. AS2 向 AS1 发送一个报文 `AS2 AS3 x`，告诉 $x$ 存在可通过 `-> AS2 -> AS3` 的途径到达 $x$
3. BGP 中，每对路由器通过使用 179 端口的半永久 (?) TCP 交换路由选择信息
4. 每条之间连接以及通过该连接发送的 BGP 报文称为 **BGP 连接 (BGP Connection)**，跨越两个 AS 的 BGP 连接称为**外部 BGP (eBGP)连接**，相同 AS 中的两台路由器之间的会话被称为**内部 BGP (iBGP) 连接**，每个路由器之间还有多条 iBGP 连接，应该指出的是，**使用 iBGP 并非使用 eBGP 的前提条件**。自治系统可从多种内部协议中选择，来连接内部网络上的路由器 ![[Pasted image 20231127110509.png]]
5. 再次考虑上述过程
	1. 路由器 3a 先向网关路由器 2c 发送一个 eBGP 报文 `AS3 x`
	2. 网关 2c 向 AS 中所有其他路由器发送 iBGP 报文 `AS3 x`
	3. 网关 2a 向 1c 发送一个 eBGP 报文 `AS2 AS3 x`
	4. 网关 1c 向 AS1 中所有路由器发送 iBGP 报文 `AS2 AS3 x`
6. 实际网络中从某个给定的路由器到目的地可能有多条不同的路径
## 确定最好的路径
