# 程序装入的方式
## 绝对装入
1. 编译程序生成绝对地址的目标代码，装入程序按照装入模块中的地址，将程序和数据装入内存
2. 只适用于单道程序的环境
## 可重定位装入
1. 编译、链接后的装入模块的地址从 0 开始，根据内存的当前状况，将装入模块装入到内存的适当位置，装入时对地址进行重定位
2. 在作业装入内存时，必须分配要求的全部空间
3. 作业进入内存不可以移动
## 动态运行时装入
1. 装入内存后所有的地址依然是逻辑地址，把地址转换推迟到程序真正要执行时才进行
2. 需要重定位寄存器的支持
3. 可以把程序分配到不连续的存储区中
4. 便于程序段的运行
# 链接的方式
1. 静态链接：程序运行之前，先将各目标模块及库函数链接成一个完整的可执行文件，之后不再拆开
2. 装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式
3. 运行时动态链接：在程序执行中需要目标模块才进行链接
# 内存管理的概念
1. 操作系统负责内存空间的分配与回收
2. 操作系统需要提供某种技术从逻辑上对内存空间进行扩充
3. 操作系统需要提供地址转换功能，负责程序的逻辑地址与物理地址的转换
4. 操作系统要保证各个进程在各自存储空间内运行，互不干扰，提供内存保护
	1. 设置上下限寄存器
	2. 采用重定位寄存器和界地址寄存器
# 进程的内存映像
![[Pasted image 20240604190834.png]]
1. 常量变量的值不能改变，会被存储在只读代码/数据区域中
2. 读/写数据和只读代码/数据中在进程启动时就确定大小
# 覆盖与交换
## 覆盖技术
1. 用来解决程序大小超过物理内存总和的问题
2. 内存中分为固定区和覆盖区
3. 程序的调用结构由程序员显式声明，对用户不透明
![[Pasted image 20240604191915.png]]
## 交换技术
1. 内存空间紧张，系统将内存中某些进程暂时换出外存，把外存中某些已具备运行条件的进程换入内存
2. 具有对换功能的操作系统中，通常把磁盘空间分为文件区和对换区两部分，文件区追求存储空间的利用率，采用离散分配方式。对换区主要追求换入换出速度，通常对对换区采用连续分配方式
3. 交换发生在系统有许多进程运行并且内存吃紧时 
4. 可优先换出阻塞进程，换出优先级低的进程，有些系统还会考虑进程在内存的驻留时间
5. PCB 不会被换出内存
# 连续分配管理方式
1. 内部碎片：分配给某进程的内存区域中，有些部分没有用上
2. 外部碎片：内存中的某些空闲分区由于太小而难以利用
## 单一连续分配
1. 内存被分为系统区和用户区
2. 内存中只能有一道用户程序，用户程序独占整个用户区空间
3. 优点：实现简单，无外部碎片，不一定实现内存保护
4. 缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率低
## 固定分区分配
1. 系统将整个用户空间划分为若干个固定大小的分区，在那个分区中只装入一道作业
2. 可以划分为分区大小相等和不等两种
3. 操作系统建立分区说明表来实现各个分区的分配与回收
4. 优点：实现简单，无外部碎片
5. 缺点：当用户程序太大时，需要采用覆盖技术满足要求，但又会降低性能，会产生内部碎片，内存利用率低
## 动态分区分配
1. 根据进程的大小动态地建立分区
2. 操作系统使用空闲分区表或空闲分区链记录内存的使用情况
3. 把新作业装入内存时，须按照一定的动态分区分配算法
4. 各表项的顺序不一定按照地址递增顺序排列，具体的排列方式需要依据动态分区分配算法来确定
5. 动态分区分配没有内部碎片，但是有外部碎片，可用“紧凑”技术来解决
# 动态分区分配算法
## 首次适应算法
1. 每次从低地址开始查找，找到一个能满足大小的空闲分区
2. 空闲分区以地址递增的次序排列，每次分配内存时顺序查找空闲分区链
## 最佳适应算法
1. 尽可能留下大片的空闲区，优先使用更小的空闲区
2. 空闲分区按容量递增次序链接，每次分配内存时顺序查找空闲分区链
3. 缺点：每次都选择最小的分区进行分配，会留下很多外部碎片
## 最坏适应算法
1. 每次分配时优先使用最大的连续空闲区
2. 空闲分区按容量递减次序链接，每次分配内存时顺序查找空闲分区链
3. 缺点：如果有大进程到达没有分区可用
## 邻近适应算法
1. 空闲分区以地址递增的顺序排列，每次分配内存时从上次查找结束的位置开始查找空闲分区链
# 分页存储管理
1. 系统将内存空间氛围一个个大小相等的分区 (比如 4 KB)，每个分区是一个页框 (页框=页帧=内存块=物理块=物理页面)
2. 将进程的逻辑地址空间分为与页框大小相等的一个个部分，每个部分称为一个页，每个页面用页号编号
3. 进程的页面与内存的页框有一一对应的关系
## 页表
1. 一个进程对应一张页表
2. 进程的每个页面对应一个页表项
3. 每个页表项由"页号"和"块号"组成
4. 为了方便页表的查询，常常会让一个页表项占据更多的字节，使得每个页面恰好可以装得下整数个页表项
5. 页表记录进程页面和实际存放的内存块见的映射关系
6. 页表项连续存放，页号可以是隐含的，不占存储空间，只有块号占用存储空间
7. 页表记录的是内存块号，不是内存块的起始地址
8. 为了方便找到页表项，页表一般是放在连续的内存块中的
## 地址转换
1. 进程的各个页面是离散存放的，但是页面内部是连续存放的
2. 要访问逻辑地址 A 
	1. 确定逻辑地址 A 对应的页号 P
	2. 找到 P 号页面在内存中的起始地址 (查页表)
	3. 确定逻辑地址 A 的页内偏移量 W
	4. 物理地址  = P 号页面在内存中的起始地址 + 页内偏移量 W
	5. 页号 = 逻辑地址 / 页面长度
	6. 页内偏移量 = 逻辑地址 % 页面长度
3. 如果每个页面大小为 $2^k$ B，用二进制数表示逻辑地址，末尾 K 位即为页内偏移量，其余部分为页号
# 基本地址变换机构
1. 系统中设置一个页表寄存器，用于存放页表在内存中的起始地址 F 和页表长度 M 
2. 进程未执行时，F 和 M 存放在 PCB 中
![[Pasted image 20240605103936.png]]
## 变换过程
1. 页面大小为 L ，逻辑地址 A 到物理地址 E 的变换过程如下
2. 计算页号和页内偏移量
3. 比较页号和页表长度 M，P >= M 则产生越界中断 (页号从 0 开始，页表长度至少是 1)
4. 页号 P 对应的页表项地址 = 页表起始地址 F + 页号 P * 页表项长度 (注意与页表长度区分)，取出该页表项内容 b，即内存块号
5. E = b * L + W
# 具有快表的地址变换机构
1. 快表，又称为联想寄存器 (TLB, translation lookaside buffer)，是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本，可以加速地址变换的速度，内存中的页表常称为慢表
2. 进程切换时进程会清空快表的内容
3. 最近使用过的页表项会放入快表，快表中存放的时页表的一部分副本
4. 若快表命中，访问某个逻辑地址只需要一次访存即可
5. 支持快表与慢表同时查找的系统，未命中时不需要加入查询快表的时间
6. TLB 和普通 Cache 的区别：TLB 中只有页表项的副本，普通 Cache 中可能有其他各种数据的副本
![[Pasted image 20240605122553.png]]
## 局部性原理
```c
int i = 0;
int a[100];
while (i < 100) {
	a[i] = i;
	i++;
}
```
1. 时间局部性：如果执行了程序中的某条指令，那么不久后这条指令很可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问
2. 空间局部性：程序访问了某个存储单元后，不久之后其附近的存储单元也很有可能被访问
# 两级页表
1. 若采用多级页表机制，则各级页表的大小不能超过一个页面
2. 两级页表的访存次数分析，N 级页表访问一个逻辑地址需要 N + 1 次访存 
## 单级页表存在的问题
1. 单级页表大占用多个连续的页框
2. 没必要让整个页表常驻内存，进程在一段时间内只需要访问某几个特定的页面
3. 可以在需要访问页面时才把页面掉入内存，可以在页表项中增加一个标志位，用于表示该页面是否已经掉入内存，若想访问的页面不在内存中，则产生缺页中断，操作系统将目标页面从外存调入内存
4. 因此需要为离散分配的页表再建立一张页表，称为页目录表 (外层页表，顶层页表)
## 地址变换
1. 按照地址结构将逻辑地址拆分成三部分
2. 从 PCB 中读出页目录表始址，根据一级页号查页目录表，找到下一级页表在内存中的存放位置
3. 根据二级页号查表，找到最终想访问的内存块号
4. 结合页内偏移量得到物理地址
# 基本分段存储管理
1. 进程的地址空间，按照程序自身的逻辑关系分为若干个段，每个段都有一个段名，每段从 0 开始编址
2. 内存分配以段为单位分配，每个段在内存中占据连续地址空间，但各段之间可以不相邻
3. 用户编程更方便，程序可读性高
4. 逻辑地址结构由段号 (段名) 和段内地址 (段内偏移量) 组成
5. 操作系统需要从物理内存中找到各个逻辑段的存放位置，需要为每个进程建立一张段映射表，简称段表
6. 段号可以是隐含的，不占存储空间
7. 需要对段内地址进行越界检查
![[Pasted image 20240605154846.png]]
## 分段分页管理对比
1. 页是信息的物理单位，主要为了实现离散分配，提高内存利用率，分页仅仅是系统管理上的需要，完全是系统行为，对用户是不可见的
2. 段是信息的逻辑单位，分段对用户是可见的
3. 分页的用户进程的地址空间是一维的
4. 分段的用户进程的地址空间是二维的
5. 分段比分页更容易实现信息的共享和保护
6. 在分段系统中也可引入快表机构，减少一次访存加快地址变换速度
# 段页式管理方式
1. 将进程按逻辑模块分段，再将各段分页
2. 再将内存空间分为大小相同的内存块/页框/页帧/物理块
3. 进程将各页面分别装入各内存块中
4. 段页式系统的逻辑地址由段号、页号、页内偏移量组成
5. 段页式管理的地址结构是一维的
6. 需要检查页号是否越界
![[Pasted image 20240605162233.png]]