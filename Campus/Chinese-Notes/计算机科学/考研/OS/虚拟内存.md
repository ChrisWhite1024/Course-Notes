# 基本概念
1. 传统存储管理方式的特征
	1. 一次性：作业必须一次性全部装入内存后才能运行，大作业无法运行，并且多道程序并发度下降
	2. 驻留性：一旦作业被装入内存，就会一直驻留在内存中，直至作业运行结束，内存中会驻留大量用不到的数据
## [[内存管理#局部性原理|局部性原理]]
1. 时间局部性
2. 空间局部性
## 定义
1. 将程序中很快就会用到的部分装入内存，暂时用不到的部分留在外存
2. 当访问的信息不再在内存时，由操作系统负责将所需信息从外存调入内存 (请求调页)
3. 内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存 (页面置换)
## 特征
1. 多次性：作业分多次调入内存
2. 对换行：作业无需一直常驻内存
3. 虚拟性：从逻辑上扩展的内存容量
# 请求分页管理方式
1. 页表项新增状态位，访问字段，修改位和外存地址
2. 当要访问的页面不在内存时，便产生一个缺页中断，然后由操作系统的缺页中断程序处理中断，此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放回就绪队列
3. 此时内存中有空闲块，为进程分配一个空闲块，将所缺页面装入该块，并修改页表中对应的页表项
4. 如果没有空闲块，需要由页面置换算法选择一个页面淘汰，若页面在内存期间被修改过，则要将其写回外存
5. 快表中有的页面一定是在内存中的，若某个页面被换出外存，则快表中对应的相应表项也要删除，否则可能访问错误的页面
6. 只有写指令才需要修改"修改位"，一般只要修改快表中的数据，只有将快表项删除时才需要写回内存中的慢表，这样可以减少缓存次数
7. 页面调入内存中时，需要修改慢表，同时也需要将表项复制到快表中
# 页面置换算法
1. 好的页面置换算法应该追求更少的缺页率
## 最佳置换算法 (OPT)
1. 淘汰页面后选择永不使用，或在最长时间内不再被访问的页面
2. 缺页时未必发生页面置换，如果有可用的空闲内存块，就不用进行页面置换
3. 操作系统无法预判访序列，在实际中是无法实现的
## 先进先出置换算法 (FIFO)
1. 每次选择淘汰的页面是最早进入内存的页面
2. Belady 异常：当进程分配的物理块数增大时，缺页次数不减反增的异常现象
3. 实现简单但算法性能差
## 最近最久未使用置换算法 (LRU)
1. 每次淘汰的页面时最近最久未使用的页面
2. 算法性能好，但实现困难，开销大
3. 做题时在逆向扫描过程中最后一个出现的页号就是要淘汰的页面
## 时钟置换算法 (CLOCK, NRU)
### 简单
1. 每个页面设置一个访问位，内存中的页面通过链接指针链接成一个循环队列
2. 当某页的访问位置为 1 时将它置为 0 ，暂不换出，若第一轮扫描中所有的页面都是 1，则将页面的访问位依次置 0 后在进行第二轮扫描，第二轮扫描中一定会有访问位为 0 的页面
### 改进
1. 如果被淘汰的页面没有被修改过，就不用执行 I/O 操作写回外存，只有被淘汰的页面被修改过时，才考虑写回外存
2. 使用 (访问位，修改位) 的形式表示各页面状态
3. 算法规则：将所有可能被置换的页面排成一个循环队列
	1. 第一轮： 从当前位置开始扫描到第一个 (0, 0) 的帧用于替换，不修改任何标志位
	2. 第二轮： 若第一轮扫描失败，重新扫描查找第一个 (0, 1) 的帧用于替换，将所有扫描过的帧访问位设为 0
	3. 第三轮：查找第一个(0, 0) 的帧用于替换，本轮扫描不修改任何标志位
	4. 第四轮：查找第一个(0, 1) 的帧用于替换
4. 第三轮，第四轮中一定会有一个帧被选中
# 页面分配策略