# 进程的概念
进程时进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
# 进程的组成
 1. 进程实体 (进程映像，进程运行某一时刻的快照) 由 PCB , 程序段和数据段组成
 2. 操作系统需要对并发运行的进程进行管理，管理时所需要用到的信息都会被放在进程控制快 (Process Control Block, PCB) 中
 3. PCB 是进程存在的唯一标志，在进程创建时创建，在进程结束时回收
 4. Linux kernel 的进程数据结构可以在 [Github](https://github.com/torvalds/linux/blob/96fca68c4fbf77a8185eb10f7557e23352732ea2/include/linux/sched.h#L748) 浏览
# 进程的特征
1. 动态性
2. 并发性：内存中有多个进程实体
3. 独立性
4. 异步性
5. 结构性：PCB
# 进程的状态与转换
1. 进程的状态
	1. 创建态 (New) ：操作系统为进程分配资源，初始化 PCB 
	2. 就绪态 (Ready)：已经具备运行条件，但没有空闲 CPU 
	3. 运行态 (Running)：单 CPU 下，同一时刻只会有一个程序处于运行态
	4. 阻塞态 (Waiting / Blocked)：进程运行过程中主动请求 (系统调用) 等待某个事件的发生，当等待的时间发生，操作系态将进程转换为就绪态
	5. 终止态 (Terminated)
![[Pasted image 20240417205834.png]]
# 进程的组织
1. 链式方式
2. 索引方式
# 进程控制
1. 进程控制的主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能
2. 操作系统实现进程控制时内核程序需要做两件事，所以进程控制的过程需要用原语来实现，否则会出现关键数据结构信息不统一的情况
	1. 修改进程状态变量
	2. 变更进程所在队列
3. 原语的原子性由关中断和开中断两个特权指令实现
	1. 正常情况下 CPU 每执行完一条指令后检查是否有外部中断信号需要处理
	2. 执行关中断指令后，CPU 不再例行检查中断信号，直到执行开中断指令后才会恢复检查，并执行未执行的中断处理程序
## 进程控制相关原语
1. 进程控制原语所做的事情
	1. 更新 PCB 中的信息 (修改进程状态，保存 / 恢复运行环境)
	2. 将 PCB 插入合适的队列
	3. 分配 / 回收资源
### 创建原语
![[Pasted image 20240422103831.png]]
1. 申请空白 PCB 
2. 为新进程分配所需资源
3. 初始化 PCB 
4. 将 PCB 插入就绪队列
#### 事件
1. 用户登录
2. 作业调度：多道批处理系统新的作业放入内存
3. 提供服务
4. 应用请求
### 撤销原语
![[Pasted image 20240422103844.png]]
1. 找到 PCB 
2. 若运行立即剥夺 CPU 并重新分配
3. 终止所有子进程
4. 将进程所有的资源归还给父进程或操作系统
5. 删除 PCB 
#### 事件
1. 正常结束：exit 调用
2. 异常结束：指令非法
3. 外界干预
### 阻塞原语
![[Pasted image 20240422104427.png]]
1. 找到 PCB 
2. 保护进程运行现场
3. PCB 插入等待队列
### 唤醒原语
1. 找到 PCB 
2. 从等待队列移除并设置进程为就绪态
3. 将 PCB 插入就绪队列
唤醒原语和阻塞原语成对出现
### 切换原语
![[Pasted image 20240422104527.png]]
1. 运行环境信息存入 PCB 
2. PCB 移入响应队列
3. 选择新进程并更新 PCB 
4. 根据 PCB 恢复新进程所需的运行环境
# 进程间通信
1. 进程间通信 (Inter-Process Communication, IPC) 是指两个进程之间产生数据交互，进程通信的实现需要操作系统的支持
2. 各进程拥有的内存地址空间相互独立
## 共享存储
1. 进程可以申请一片共享存储区
2. 共享存储区可以被多个进程使用
``` c
int shm_open();
void* mmap();
```
3. 使用共享存储区通信时需要保证互斥访问，可以使用操作系统内核提供的同步互斥工具
### 基于存储区
1. 共享存储区数据的形式、存放位置都由通信进程控制，速度快，属于高级通信方式
### 基于数据结构
1. 共享区域用数据结构的限制，可以理解为特殊的全局变量，共享方式速度慢，属于低级通信方式
## 消息传递
1. 进程间的数据交换以格式化的消息 (Message) 为单位。进程通过操作系统提供的"发送消息 / 接收消息"两个原语进行数据交换
### 直接通信方式
![[Pasted image 20240422111623.png]]
1. 发送进程需要指明接收进程的 ID
### 间接通信方式
1. 通过信箱间接发送消息
2. 进程 P 通过 OS 申请邮箱
3. 在自己的地址空间内完善消息体的信息
4. 进程 P 通过发送原语指明发送的信箱
## 管道通信
1. 写进程想管道一边写入数据，读进程从管道另一边取走数据，数据的流动是单向的
2. 管道是一个特殊的共享文件，实际上实在内存中开辟一个固定的内存缓冲区，和共享存储的区别是读取数据的顺序有限制，可以把管道的内存缓冲区理解为循环队列
3. 管道只能支持半双工通信，某一时间段内只能实现单向的传输，两个方向的数据传输不能同时进行
4. 各进程要互斥地访问管道 (操作系统实现)
5. 管道写满时，写进程需要被阻塞，管道读空时，读进程将阻塞
6. 多个读进程读一个管道时，会发生错乱，有两种解决方案
	1. 一个管道允许的多个写进程，一个读进程
	2. 一个管道允许多个写进程，多个读进程，操作系统会让各个读进程轮流从管道中读数据 (Linux)
# 线程的概念与特点
![[Pasted image 20240422123513.png]]
1. 有的进程可能需要同时做很多事，传统的进程只能串行执行一系列程序，所以引入线程来增加并发度
2. 引入线程后，线程成为程序执行流的最小单位
3. 线程时一个基本的 CPU 执行单元，也是程序执行流的最小单位
4. 引入线程后进程作为除 CPU 之外系统资源的分配单元
![[Pasted image 20240422123552.png]]
# 线程的实现方式
## 用户级线程 (User-Level Thread, ULT)
1. 早期的操作系统线程是由线程库实现的
2. 操作系统层面只能看到一个进程，而程序员通过线程库实现了逻辑上的线程
3. 只有用户才能感知到用户级线程的存在
### 优缺点
1. 优点：切换在用户空间即可完成，不需要变态，线程管理的系统开销小，效率高
2. 缺点：只要其中一个线程被阻塞，则整个进程都会被阻塞，多个线程不可在多处理机上并行运行
## 内核级线程 (Kernel-Level Thread, KLT)
1. 操作系统为每个内核级线程建立相应的线程控制块 (Thread Control Block, TCB)
2. 操作系统只看得见内核级线程，只有内核级线程是处理机分配的单位
### 优缺点
1. 优点：一个线程被阻塞其他线程仍能执行，并发能力强，多线程可在多核处理机上并行执行
2. 缺点：一个用户进程会占用多个内核级线程，线程切换优操作系统内核完成，需要切换到核心态，开销大
## 多线程模型
### 一对一模型
### 多对一模型
### 多对多模型
![[Pasted image 20240422125608.png]]
1. N 用户级线程映射到 m 个内核级线程 (n >= m)，每个用户线程对应 m 个内核级线程
2. 用户级线程是代码逻辑的载体，内核级线程是运行机会的载体
# 线程的状态与转换
![[Pasted image 20240422125847.png]]
1. 线程的状态与转换与进程相类似
![[Pasted image 20240422125958.png]]
# 调度的概念和层次
1. 资源有限时，需要确定某种规则来决定处理任务的顺序
## 高级调度
1. 作业：一个具体的任务
2. 高级调度 (作业调度)：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业在声明周期内只被调入调出一次
## 低级调度
1. 低级调度 (进程调度 / 处理机调度)：按照某种策略从就绪队列中选择进程
## 中级调度
1. 中级调度 (内存调度)：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存
## 进程的挂起态
![[Pasted image 20240424095359.png]]
1. 挂起态又可以细分为就绪挂起和阻塞挂起两种状态
# 调度算法的评价指标
## CPU 利用率
1. CPU 处于忙碌的时间占总时间的比例
2. $$
利用率 = \frac{忙碌的时间}{总时间}
$$
## 系统吞吐量
1. 单位时间内完成作业的数量
2. $$
系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}
$$
## 周转时间
1. 作业被提交给系统，到作业完成为止的时间间隔
2. 包括高级调度，低级调度，上 CPU 执行，等待 IO 四个部分
3. 待权周转时间$$
\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间 - 作业提交时间}{作业实际运行的时间}
$$
## 等待时间
1. 进程 / 作业处于等待处理机状态时间之和
2. 对于进程来说，指进程建立后等待被服务的时间之和，等待 IO 完成的期间进程被 IO 设备服务不计入等待时间
3. 对于作业来说，还需要加上在外存后备队列中等待的时间
## 响应时间
1. 指用户提交请求到首次产生响应的时间
# 进程调度的时机
1. 当前已运行的进程主动放弃处理机
	1. 进程正常终止
	2. 运行过程中异常终止
	3. 进程主动请求阻塞 (如等待 IO )
2. 被动放弃处理机
	1. 时间片用完
	2. 更紧急的事 (如 IO 中断)
	3. 更高优先级的进程进入就绪队列
3. 不能进程调度和切换
	1. 处理中断过程
	2. 进程在**操作系统内核程序**临界区
		1. 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
		2. 临界区：访问临界资源的代码
		3. 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，可以进行进程调度和切换
	3. 在原子操作过程中
# 进程调度的方式
## 非剥夺调度方式 (非抢占方式)
1. 只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态
2. 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
## 剥夺调度方式 (抢占方式)
1. 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程
2. 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能
# 进程的切换
1. 狭义的进程调度：从就绪队列中选中一个要运行的进程
2. 进程切换：一个进程让出处理机，由另一个进程占用处理机的过程
3. 广义的进程调度包含选择一个进程和进程切换两个步骤
4. 进程切换的过程主要完成
	1. 对原来运行进程各种数据的保存
	2. 对新进程各种数据的恢复
	3. PSW PC REG 等保存在 PCB 中
5. 进程的切换是有代价的，如果调度过于频繁会导致系统效率降低
# 调度器
![[Pasted image 20240424105033.png]]
## 触发调度程序的时机
1. 创建新进程
2. 进程退出
3. 进程阻塞
4. I/O 中断发生
## 闲逛进程
1. 没有其他进程运行时，运行闲逛进程
2. 优先级最低
3. 0 地址指令，占完整的指令周期，例行检查中断
4. 能耗低
# 调度算法
1. 先来先服务、短作业优先和高响应比优先通常用于早期的批处理操作系统
2. 时间片轮转、优先级调度和多级反馈队列算法使用于交互式系统
## 先来先服务
1. 先到达后备队列 (作业调度) / 就绪队列 (进程调度) 先服务
2. 优点：公平，实现简单
3. 缺点：对长作业有利，对短作业不利
## 短作业优先
1. 追求更少的平均等待时间，平均周转时间，平均带权周转时间
2. 最短的作业/进程优先得到服务
3. 非抢占式算法 (默认)
4. 抢占式的短作业优先算法称为最短剩余时间优先算法 (SRTN)：当新来进程的剩余时间比当前运行进程的剩余时间更短，由新进程抢占处理机
5. 在所有进程几乎同时到达时，采用 SJF 调度算法的平均等待时间、平均周转时间最少
6. 抢占式短作业/进程优先调度算法的平均等待时间、平均周转时间最少
7. 优点：短的平均等待时间、平均周转时间
8. 缺点：不公平。对短作业有利，对长作业不利，可能产生饥饿现象
## 高响应比优先
1. 在每次调度是计算各个作业的响应比，选择最高的作业/进程为其服务
2. 非抢占式的调度算法
3. 可用于作业调度，也可用于进程调度
## 时间片轮转 (RR)
1. 公平、轮流地为各个进程服务
2. 用于进程调度
3. 抢占式算法
4. 常用于分时操作系统，更注重响应时间
5. 在题目中默认新到达的进程先进入就绪队列
6. 时间片太大时间片轮转调度算法会退化为先来先服务调度算法，并且会增大进程响应时间
7. 时间片太小导致进程切换过于频繁
## 优先级调度算法
1. 为每个作业 / 进程设置优先级。调度时选择优先级最高的作业 / 进程
2. 有抢占式和非抢占式
3. 如何合理地设置各类进程的优先级
	1. 系统进程高于用户进程
	2. 前台进程高于后台进程
	3. 操作系统更偏好 I/O 型进程
4. 采用动态优先级什么时候应该调整
	1. 进程在就绪队列中等待了很长时间，适当提高
	2. 占用处理机很长时间，适当降低
	3. 进程 I/O 繁忙
## 多级反馈队列
1. 抢占式算法
2. 被抢占处理机的进程重新放回原队列队尾
3. 对各类进程相对公平，每个新到达的进程可以很快得到响应，短进程只用较少的时间就可完成，不必实现估计进程的运行时间
4. 可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程可以保持较高优先级
## 多级队列调度算法
1. 系统按进程类型设置多个队列。进程创建成功后插入某个队列
2. 系统进程 > 交互式进程 > 批处理进程
3. 时间片划分，不同队列分配不同比例的时间
4. 各队列可以采用不同的调度策略
# 同步与互斥