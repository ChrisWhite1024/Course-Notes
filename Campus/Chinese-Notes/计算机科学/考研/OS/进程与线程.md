# 进程的概念
进程时进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
# 进程的组成
 1. 进程实体 (进程映像，进程运行某一时刻的快照) 由 PCB , 程序段和数据段组成
 2. 操作系统需要对并发运行的进程进行管理，管理时所需要用到的信息都会被放在进程控制快 (Process Control Block, PCB) 中
 3. PCB 是进程存在的唯一标志，在进程创建时创建，在进程结束时回收
 4. Linux kernel 的进程数据结构可以在 [Github](https://github.com/torvalds/linux/blob/96fca68c4fbf77a8185eb10f7557e23352732ea2/include/linux/sched.h#L748) 浏览
# 进程的特征
1. 动态性
2. 并发性：内存中有多个进程实体
3. 独立性
4. 异步性
5. 结构性：PCB
# 进程的状态与转换
1. 进程的状态
	1. 创建态 (New) ：操作系统为进程分配资源，初始化 PCB 
	2. 就绪态 (Ready)：已经具备运行条件，但没有空闲 CPU 
	3. 运行态 (Running)：单 CPU 下，同一时刻只会有一个程序处于运行态
	4. 阻塞态 (Waiting / Blocked)：进程运行过程中主动请求 (系统调用) 等待某个事件的发生，当等待的时间发生，操作系态将进程转换为就绪态
	5. 终止态 (Terminated)
![[Pasted image 20240417205834.png]]
# 进程的组织
1. 链式方式
2. 索引方式
# 进程控制
1. 进程控制的主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能
2. 操作系统实现进程控制时内核程序需要做两件事，所以进程控制的过程需要用原语来实现，否则会出现关键数据结构信息不统一的情况
	1. 修改进程状态变量
	2. 变更进程所在队列
3. 原语的原子性由关中断和开中断两个特权指令实现
	1. 正常情况下 CPU 每执行完一条指令后检查是否有外部中断信号需要处理
	2. 执行关中断指令后，CPU 不再例行检查中断信号，直到执行开中断指令后才会恢复检查，并执行未执行的中断处理程序
## 进程控制相关原语
1. 进程控制原语所做的事情
	1. 更新 PCB 中的信息 (修改进程状态，保存 / 恢复运行环境)
	2. 将 PCB 插入合适的队列
	3. 分配 / 回收资源
### 创建原语
![[Pasted image 20240422103831.png]]
1. 申请空白 PCB 
2. 为新进程分配所需资源
3. 初始化 PCB 
4. 将 PCB 插入就绪队列
#### 事件
1. 用户登录
2. 作业调度：多道批处理系统新的作业放入内存
3. 提供服务
4. 应用请求
### 撤销原语
![[Pasted image 20240422103844.png]]
1. 找到 PCB 
2. 若运行立即剥夺 CPU 并重新分配
3. 终止所有子进程
4. 将进程所有的资源归还给父进程或操作系统
5. 删除 PCB 
#### 事件
1. 正常结束：exit 调用
2. 异常结束：指令非法
3. 外界干预
### 阻塞原语
![[Pasted image 20240422104427.png]]
1. 找到 PCB 
2. 保护进程运行现场
3. PCB 插入等待队列
### 唤醒原语
1. 找到 PCB 
2. 从等待队列移除并设置进程为就绪态
3. 将 PCB 插入就绪队列
唤醒原语和阻塞原语成对出现
### 切换原语
![[Pasted image 20240422104527.png]]
1. 运行环境信息存入 PCB 
2. PCB 移入响应队列
3. 选择新进程并更新 PCB 
4. 根据 PCB 恢复新进程所需的运行环境
# 进程间通信
1. 进程间通信 (Inter-Process Communication, IPC) 是指两个进程之间产生数据交互，进程通信的实现需要操作系统的支持
2. 各进程拥有的内存地址空间相互独立
## 共享存储
1. 进程可以申请一片共享存储区
2. 共享存储区可以被多个进程使用
``` c
int shm_open();
void* mmap();
```
3. 使用共享存储区通信时需要保证互斥访问，可以使用操作系统内核提供的同步互斥工具
### 基于存储区
1. 共享存储区数据的形式、存放位置都由通信进程控制，速度快，属于高级通信方式
### 基于数据结构
1. 共享区域用数据结构的限制，可以理解为特殊的全局变量，共享方式速度慢，属于低级通信方式
## 消息传递
1. 进程间的数据交换以格式化的消息 (Message) 为单位。进程通过操作系统提供的"发送消息 / 接收消息"两个原语进行数据交换
### 直接通信方式
![[Pasted image 20240422111623.png]]
1. 发送进程需要指明接收进程的 ID
### 间接通信方式
1. 通过信箱间接发送消息
2. 进程 P 通过 OS 申请邮箱
3. 在自己的地址空间内完善消息体的信息
4. 进程 P 通过发送原语指明发送的信箱
## 管道通信
1. 写进程想管道一边写入数据，读进程从管道另一边取走数据，数据的流动是单向的
2. 管道是一个特殊的共享文件，实际上实在内存中开辟一个固定的内存缓冲区，和共享存储的区别是读取数据的顺序有限制，可以把管道的内存缓冲区理解为循环队列
3. 管道只能支持半双工通信，某一时间段内只能实现单向的传输，两个方向的数据传输不能同时进行
4. 各进程要互斥地访问管道 (操作系统实现)
5. 管道写满时，写进程需要被阻塞，管道读空时，读进程将阻塞
6. 多个读进程读一个管道时，会发生错乱，有两种解决方案
	1. 一个管道允许的多个写进程，一个读进程
	2. 一个管道允许多个写进程，多个读进程，操作系统会让各个读进程轮流从管道中读数据 (Linux)
# 线程的概念与特点
![[Pasted image 20240422123513.png]]
1. 有的进程可能需要同时做很多事，传统的进程只能串行执行一系列程序，所以引入线程来增加并发度
2. 引入线程后，线程成为程序执行流的最小单位
3. 线程时一个基本的 CPU 执行单元，也是程序执行流的最小单位
4. 引入线程后进程作为除 CPU 之外系统资源的分配单元
![[Pasted image 20240422123552.png]]
# 线程的实现方式
## 用户级线程 (User-Level Thread, ULT)
1. 早期的操作系统线程是由线程库实现的
2. 操作系统层面只能看到一个进程，而程序员通过线程库实现了逻辑上的线程
3. 只有用户才能感知到用户级线程的存在
### 优缺点
1. 优点：切换在用户空间即可完成，不需要变态，线程管理的系统开销小，效率高
2. 缺点：只要其中一个线程被阻塞，则整个进程都会被阻塞，多个线程不可在多处理机上并行运行
## 内核级线程 (Kernel-Level Thread, KLT)
1. 操作系统为每个内核级线程建立相应的线程控制块 (Thread Control Block, TCB)
2. 操作系统只看得见内核级线程，只有内核级线程是处理机分配的单位
### 优缺点
1. 优点：一个线程被阻塞其他线程仍能执行，并发能力强，多线程可在多核处理机上并行执行
2. 缺点：一个用户进程会占用多个内核级线程，线程切换优操作系统内核完成，需要切换到核心态，开销大
## 多线程模型
### 一对一模型
### 多对一模型
### 多对多模型
![[Pasted image 20240422125608.png]]
1. N 用户级线程映射到 m 个内核级线程 (n >= m)，每个用户线程对应 m 个内核级线程
2. 用户级线程是代码逻辑的载体，内核级线程是运行机会的载体
# 线程的状态与转换
![[Pasted image 20240422125847.png]]
1. 线程的状态与转换与进程相类似
![[Pasted image 20240422125958.png]]
# 调度的概念和层次
1. 资源有限时，需要确定某种规则来决定处理任务的顺序
## 高级调度
1. 作业：一个具体的任务
2. 高级调度 (作业调度)：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。每个作业在声明周期内只被调入调出一次
## 低级调度
1. 低级调度 (进程调度 / 处理机调度)：按照某种策略从就绪队列中选择进程
## 中级调度
1. 中级调度 (内存调度)：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存
## 进程的挂起态
![[Pasted image 20240424095359.png]]
1. 挂起态又可以细分为就绪挂起和阻塞挂起两种状态
# 调度算法的评价指标
## CPU 利用率
1. CPU 处于忙碌的时间占总时间的比例
2. $$
利用率 = \frac{忙碌的时间}{总时间}
$$
## 系统吞吐量
1. 单位时间内完成作业的数量
2. $$
系统吞吐量 = \frac{总共完成了多少道作业}{总共花了多少时间}
$$
## 周转时间
1. 作业被提交给系统，到作业完成为止的时间间隔
2. 包括高级调度，低级调度，上 CPU 执行，等待 IO 四个部分
3. 待权周转时间$$
\frac{作业周转时间}{作业实际运行的时间}=\frac{作业完成时间 - 作业提交时间}{作业实际运行的时间}
$$
## 等待时间
1. 进程 / 作业处于等待处理机状态时间之和
2. 对于进程来说，指进程建立后等待被服务的时间之和，等待 IO 完成的期间进程被 IO 设备服务不计入等待时间
3. 对于作业来说，还需要加上在外存后备队列中等待的时间
## 响应时间
1. 指用户提交请求到首次产生响应的时间
# 进程调度的时机
1. 当前已运行的进程主动放弃处理机
	1. 进程正常终止
	2. 运行过程中异常终止
	3. 进程主动请求阻塞 (如等待 IO )
2. 被动放弃处理机
	1. 时间片用完
	2. 更紧急的事 (如 IO 中断)
	3. 更高优先级的进程进入就绪队列
3. 不能进程调度和切换
	1. 处理中断过程
	2. 进程在**操作系统内核程序**临界区
		1. 临界资源：一个时间段内只允许一个进程使用的资源。各进程需要互斥地访问临界资源。
		2. 临界区：访问临界资源的代码
		3. 普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，可以进行进程调度和切换
	3. 在原子操作过程中
# 进程调度的方式
## 非剥夺调度方式 (非抢占方式)
1. 只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态
2. 实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统
## 剥夺调度方式 (抢占方式)
1. 当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程
2. 可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能
# 进程的切换
1. 狭义的进程调度：从就绪队列中选中一个要运行的进程
2. 进程切换：一个进程让出处理机，由另一个进程占用处理机的过程
3. 广义的进程调度包含选择一个进程和进程切换两个步骤
4. 进程切换的过程主要完成
	1. 对原来运行进程各种数据的保存
	2. 对新进程各种数据的恢复
	3. PSW PC REG 等保存在 PCB 中
5. 进程的切换是有代价的，如果调度过于频繁会导致系统效率降低
# 调度器
![[Pasted image 20240424105033.png]]
## 触发调度程序的时机
1. 创建新进程
2. 进程退出
3. 进程阻塞
4. I/O 中断发生
## 闲逛进程
1. 没有其他进程运行时，运行闲逛进程
2. 优先级最低
3. 0 地址指令，占完整的指令周期，例行检查中断
4. 能耗低
# 调度算法
1. 先来先服务、短作业优先和高响应比优先通常用于早期的批处理操作系统
2. 时间片轮转、优先级调度和多级反馈队列算法使用于交互式系统
## 先来先服务
1. 先到达后备队列 (作业调度) / 就绪队列 (进程调度) 先服务
2. 优点：公平，实现简单
3. 缺点：对长作业有利，对短作业不利
## 短作业优先
1. 追求更少的平均等待时间，平均周转时间，平均带权周转时间
2. 最短的作业/进程优先得到服务
3. 非抢占式算法 (默认)
4. 抢占式的短作业优先算法称为最短剩余时间优先算法 (SRTN)：当新来进程的剩余时间比当前运行进程的剩余时间更短，由新进程抢占处理机
5. 在所有进程几乎同时到达时，采用 SJF 调度算法的平均等待时间、平均周转时间最少
6. 抢占式短作业/进程优先调度算法的平均等待时间、平均周转时间最少
7. 优点：短的平均等待时间、平均周转时间
8. 缺点：不公平。对短作业有利，对长作业不利，可能产生饥饿现象
## 高响应比优先
1. 在每次调度是计算各个作业的响应比，选择最高的作业/进程为其服务
2. 非抢占式的调度算法
3. 可用于作业调度，也可用于进程调度
## 时间片轮转 (RR)
1. 公平、轮流地为各个进程服务
2. 用于进程调度
3. 抢占式算法
4. 常用于分时操作系统，更注重响应时间
5. 在题目中默认新到达的进程先进入就绪队列
6. 时间片太大时间片轮转调度算法会退化为先来先服务调度算法，并且会增大进程响应时间
7. 时间片太小导致进程切换过于频繁
## 优先级调度算法
1. 为每个作业 / 进程设置优先级。调度时选择优先级最高的作业 / 进程
2. 有抢占式和非抢占式
3. 如何合理地设置各类进程的优先级
	1. 系统进程高于用户进程
	2. 前台进程高于后台进程
	3. 操作系统更偏好 I/O 型进程
4. 采用动态优先级什么时候应该调整
	1. 进程在就绪队列中等待了很长时间，适当提高
	2. 占用处理机很长时间，适当降低
	3. 进程 I/O 繁忙
## 多级反馈队列
1. 抢占式算法
2. 被抢占处理机的进程重新放回原队列队尾
3. 对各类进程相对公平，每个新到达的进程可以很快得到响应，短进程只用较少的时间就可完成，不必实现估计进程的运行时间
4. 可以将因 I/O 而阻塞的进程重新放回原队列，这样 I/O 型进程可以保持较高优先级
## 多级队列调度算法
1. 系统按进程类型设置多个队列。进程创建成功后插入某个队列
2. 系统进程 > 交互式进程 > 批处理进程
3. 时间片划分，不同队列分配不同比例的时间
4. 各队列可以采用不同的调度策略
# 同步与互斥
## 基本概念
1. 进程具有异步性，进程推进的顺序是不可预知的
2. 同步也称直接制约关系，进程需要在某些位置上协调工作次序
### 进程互斥
1. 临界资源：一个时间段内只允许一个进程使用的资源
2. 临界区：访问临界资源的那段代码
3. 进入区和退出区是负责互斥的代码段
4. 对临界资源的互斥访问需要遵循一下原则
	1. 空闲让进
	2. 忙则等待
	3. 有限等待
	4. 让权等待
## 软件实现方法
### 单标志法
1. 通过 turn 表示当前允许进入临界区的进程号
2. 两个进程访问完临界区后会把使用临界区的权限转交给另一个进程
3. 该算法可以实现互斥
4. 违反了空闲让进的原则
### 双标志先检查法
1. 每个进程在进入区检查对方是否想进入临界区
2. 如果对方不想使用资源表达自己想使用资源的意愿
3. 当执行第一句时发生进程切换，两个并发进行的进程会同时进入临界区
4. 违反了忙则等待的原则，检查和上锁的动作不能同时完成
### 双标志后检查法
1. 先上锁后检查
2. 违背了空闲让进和有限等待原则，各进程会长期无法访问临界资源从而产生饥饿现象
### Peterson 算法
1. 结合双标志法、单标志法的思想
2. 在进入区主动争取，主动谦让，检查对方是否也想使用
3. 用软件方法解决了进程互斥问题，遵循了空闲让进、忙则等待和有限等待三个原则，但并未遵守让权等待原则
## 硬件实现方法
### 中断屏蔽方法
1. 进程访问临界区之前执行关中断指令
2. 不适用于多处理机系统，只适用于操作系统内核进程，不适用于用户进程
3. TestAndSet 指令，又称 TSL 指令，把上锁和检查操作用硬件的方式，变成了一气呵成的原子操作，实现简单，使用于多处理机环境，但不满足让权等待规则
4. Swap (XCHG) 指令
## 互斥锁
1. 进程进入临界区时应获得锁，在退出临界区时释放锁
2. 需要循环忙等的互斥锁，都可成为自选锁，如 TSL 指令、swap 指令、单标志法
3. 违反让权等待
4. 等待期间不用切换进程上下文，多处理器系统中若上锁时间短，则等待代价很低
## 信号量机制
1. 用户可以通过操作系统提供的一对原语来对信号量进行操作
2. 信号量其实就是一个变量 (整型或记录型)，可以用信号量表示系统中某种资源的数量
3. wait、signal 原语常简称为 P、V 操作
### 整型信号量
```c
int S = 1；

void wait (int S) {
	while (S <= 0);
	S = S - 1;
}

void signal (int S) {
	S = S + 1;
}
 ```
 1. 两个操作和双标志先检查法的先检查后上锁是一样的，只是使用了原语实现避免了两个进程同时进入临界区的问题
 2. 不满足让权等待原则
### 记录型信号量
```c
typedef struct {
	int value;
	struct process *L; 
} semaphore;

void wait(semaphore S) {
	S.value--;
	if (S.value < 0) {
		block(S.L);
	}
}

void signal(semaphore S) {
	S.value++;
	if (S.value <= 0) {
		wakeup(S.L);
	}
}
```
1. 记录型信号量遵循的让权等待原则
2. 考试中出现的 P(S)、V(S)的操作，除非特别说明，否则默认 S 为记录型信号量
## 信号量机制
### 进程互斥
1. 划定临界区
2. 对于不同的临界资源需要设置不同的互斥信号量
```c
semphore mutex = 1;

P1() {
	...
	P(mutex);
	临界区代码段
	V(mutex);
	...
}

P2() {
	...
	P(mutex);
	临界区代码段
	V(mutex);
	...
}
```
### 进程同步
1. 进程同步：让各并发进程按要求有序地推进
2. 分析需要实现同步关系的位置
3. 设置同步信号量 S ，初始值为 0
4. 前 V 后 P 
```c
semaphore S = 0;

P1() {
	code 1;
	code 2
	V(S);
	code 3;
}

P2() {
	P(S);
	code 4;
	code 5;
	code 6;
}
```
### 进程前驱关系
## 进程同步互斥问题
### 生产者-消费者问题
1. 缓冲区没满生产者才能生产，缓冲区不空时，消费者才能从中取出产品，否则必须等待
2. 缓冲区是临界资源，各进程必须互斥地访问
3. 互斥关系是在同一进程中进行一对 PV 操作，同步关系是在一个进程中执行 P，一个进程中执行 V 
```c
semaphore mutex = 1;
semaphore empty = n;
semaphore full = 0;

producer () {
	while (1) {
		生产一个产品;
		P(empty);
		P(mutex);
		把产品放入缓冲区;
		V(mutex);
		V(full);
	}
}

consumer () {
	while (1) {
		P(full);
		P(mutex);
		从缓冲区中取出一个产品;
		V(mutex);
		V(empty);
		使用产品;
	}
}
```
### 多生产者-多消费者问题
1. 如果在生产者消费者问题中出现缓冲区大于 1 的情况，需要设置一个互斥信号量 mutex 来保证缓冲区的互斥访问
2. 注意互斥的 P 操作一定要在实现同步的 P 操作之后，否则有可能引起死锁
## 吸烟者问题
1. 假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料:烟草、纸和胶水。三个抽烟者中，第一个拥有烟草、第二个拥有纸、第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复(让三个抽烟者轮流地抽烟)
2. 同步关系
	1. 桌上有组合一----第一个抽烟者取走东西
	2. 桌上有组合二----第二个抽烟者取走东西
	3. ...
	4. 发出完成信号----供应者将下一个组合放到桌上
```c
semaphore offer1 = 0;
semaphore offer2 = 0;
semaphore offer3 = 0;
semaphore finish = 0;
int i = 0;

provider () {
	while (1) {
		if (i == 0) {
			将组合一放桌上;
			V(offer1);
		} else if (i == 1) {
			将组合二放桌上;
			V(offer2);
		} else if (i == 2) {
			将组合三放桌上;
			V(offer3);
		}
		i = (i + 1) % 3;
		P(finish);
	}
}

smoker1 () {
	while (1) {
		P(offer1);
		从桌上拿走组合一;
		卷烟;
		抽掉;
		V(finish);
	}
}

...
```
### 读者-写者问题
1. 允许多个读者可以同时读文件
2. 允许一个写者往文件中写信息
3. 任一写者完成写操作前不允许其他读者或写者工作
4. 写者执行写操作前，应让已有的读者和写者全部退出
5. 核心思想在于设置了计数器 count 用来记录当前正在访问共享文件的读进程数
```c
semaphore rw = 1;
int count = 0;
semaphore mutex = 1;
semaphore w = 1; // 实现相对公平的先来先服务

writer () {
	while(1) {
		P(w);
		P(rw);
		写文件...
		V(rw);
		V(w);
	}
}

reader () {
	while(1) {
		P(w);
		P(mutex);
		if(count == 0)
			P(rw);
		count++;
		V(mutex);
		V(w);
		读文件...
		P(mutex);
		count--;
		if(count == 0)
			V(rw);
		V(mutex);
	}
}
```
### 哲学家进餐问题
1. 防止死锁的状态的发生：
	1. 最多允许四个哲学家同时进餐
	2. 奇数号哲学家先拿左边的筷子，偶数号哲学家恰好相反
	3. 仅当一个哲学家左右两支筷子都可用时才允许抓起筷子
```c
semaphore mutex = 1;
semaphore chopstick[5] = {1, 1, 1, 1, 1};

Pi () {
	while(1) {
		P(mutex);
		P(chopstick[i]);
		P(chopstick[(i + 1) % 5]);
		V(mutex);
		吃饭...
		V(chopstick[i]);
		V(chopstick[(i + 1) % 5]);
		思考...
	}
}
```
## 管程
### 管程的定义和基本特征
1. 信号量机制编写程序困难、易出错
2. 管程是一种特殊的软件模块，由这些部分组成
	1. 局部于管程的共享数据结构说明
	2. 对该数据结构进行操作的一组过程
	3. 对局部于管程的共享数据设置初始值的语句
	4. 管程有一个名字
3. 基本特征
	1. 每次仅允许一个进程在管程内执行某个内部过程
	2. 由编译器负责实现各进程互斥地进入管程中的过程
# 死锁
## 死锁的概念
1. 死锁：各进程互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象，至少有两个或两个以上的进程同时发生死锁
2. 饥饿：由于长期得不到想要的资源，某进程无法向前推进的现象，有可能是阻塞态(长期得不到需要的 I/O 设备)，也可能是就绪态(长期得不到处理机)
## 产生的必要条件
1. 互斥条件
2. 不剥夺条件
3. 请求和保持条件
4. 循环等待条件 (发生死锁一定有循环等待，但是发生循环等待时未必死锁)
	1. 如果同类资源数大于 1，则即使有循环等待，也未必发生死锁
## 死锁的处理策略
1. 预防死锁
2. 避免死锁 (银行家算法)
3. 死锁的检测和解除
## 预防死锁
### 破坏互斥条件
1. 互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁
2. 如 SPOOLing 技术可以把独占设备在逻辑上改造成共享设备
3. 缺点：不是所有资源都可以改造成可共享使用的资源。并且为了系统安全很多多方都比西保护这种互斥性
### 破坏不剥夺条件
1. 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时重新申请
2. 方案二：当某个进程需要的资源被其他进程所占有时，可以由操作系统协助，将想要的资源强行剥夺
3. 缺点
	1. 实现复杂
	2. 释放已获得的资源可能造成前一阶段工作的失败
	3. 反复的申请和释放资源会增加系统开销，降低系统吞吐量
	4. 采用方案一可能会导致进程饥饿
### 破坏请求和保持条件
1. 采用静态分配方法进程在运行前一次申请完所需要的全部资源
2. 容易造成资源浪费，资源利用率低，有可能导致进程饥饿
### 破坏循环等待条件
1. 采用顺序资源分配法：规定每个进程必须按编号递增的顺序请求资源，同类资源需要一次申请完
2. 缺点：
	1. 不方便增加新的设备
	2. 进程实际使用资源的顺序可能与编号递增顺序不一致，会导致资源浪费
	3. 必须按规定次序申请资源，用户编程麻烦
## 避免死锁
### 银行家算法
1. 核心思想：在进程提出资源申请时，预先判断此次分配是否会导致系统进入不安全状态，如果会进入不安全状态，就暂时不答应这次请求，让该进程先阻塞等待
2. 待补充
## 死锁的检测与解除
### 死锁的检测
1. 用某种数据结构来保存资源的请求和分配信息
2. 提供一种算法，利用上述信息来检测系统是否已进入死锁状态
3. 资源分配图![[Pasted image 20240603104619.png]]
4. 如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。如果最终能消除所有边，则称这个图是可完全简化的。此时一定没有发生死锁
### 死锁的解除
1. 资源剥夺法：挂起某些死锁进程，并抢占它的资源
2. 撤销进程法
3. 进程回退法：操作系统需要记录进程的历史信息，设置还原点
4. 考虑对哪个进程进行操作
	1. 进程优先级
	2. 已执行多长时间
	3. 还要多久完成
	4. 交互式还是批处理式
