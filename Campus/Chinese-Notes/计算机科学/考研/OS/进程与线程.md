# 进程的概念
进程时进程实体的运行过程，是系统进行资源分配和调度的一个独立单位
# 进程的组成
 1. 进程实体 (进程映像，进程运行某一时刻的快照) 由 PCB , 程序段和数据段组成
 2. 操作系统需要对并发运行的进程进行管理，管理时所需要用到的信息都会被放在进程控制快 (Process Control Block, PCB) 中
 3. PCB 是进程存在的唯一标志，在进程创建时创建，在进程结束时回收
 4. Linux kernel 的进程数据结构可以在 [Github](https://github.com/torvalds/linux/blob/96fca68c4fbf77a8185eb10f7557e23352732ea2/include/linux/sched.h#L748) 浏览
# 进程的特征
1. 动态性
2. 并发性：内存中有多个进程实体
3. 独立性
4. 异步性
5. 结构性：PCB
# 进程的状态与转换
1. 进程的状态
	1. 创建态 (New) ：操作系统为进程分配资源，初始化 PCB 
	2. 就绪态 (Ready)：已经具备运行条件，但没有空闲 CPU 
	3. 运行态 (Running)：单 CPU 下，同一时刻只会有一个程序处于运行态
	4. 阻塞态 (Waiting / Blocked)：进程运行过程中主动请求 (系统调用) 等待某个事件的发生，当等待的时间发生，操作系态将进程转换为就绪态
	5. 终止态 (Terminated)
![[Pasted image 20240417205834.png]]
# 进程的组织
1. 链式方式
2. 索引方式
# 进程控制
1. 进程控制的主要功能是对系统中的所有进程实施有效的管理，具有创建新进程、撤销已有进程、实现进程状态转换等功能
2. 操作系统实现进程控制时内核程序需要做两件事，所以进程控制的过程需要用原语来实现，否则会出现关键数据结构信息不统一的情况
	1. 修改进程状态变量
	2. 变更进程所在队列
3. 原语的原子性由关中断和开中断两个特权指令实现
	1. 正常情况下 CPU 每执行完一条指令后检查是否有外部中断信号需要处理
	2. 执行关中断指令后，CPU 不再例行检查中断信号，直到执行开中断指令后才会恢复检查，并执行未执行的中断处理程序
## 进程控制相关原语
1. 进程控制原语所做的事情
	1. 更新 PCB 中的信息 (修改进程状态，保存 / 恢复运行环境)
	2. 将 PCB 插入合适的队列
	3. 分配 / 回收资源
### 创建原语
![[Pasted image 20240422103831.png]]
1. 申请空白 PCB 
2. 为新进程分配所需资源
3. 初始化 PCB 
4. 将 PCB 插入就绪队列
#### 事件
1. 用户登录
2. 作业调度：多道批处理系统新的作业放入内存
3. 提供服务
4. 应用请求
### 撤销原语
![[Pasted image 20240422103844.png]]
1. 找到 PCB 
2. 若运行立即剥夺 CPU 并重新分配
3. 终止所有子进程
4. 将进程所有的资源归还给父进程或操作系统
5. 删除 PCB 
#### 事件
1. 正常结束：exit 调用
2. 异常结束：指令非法
3. 外界干预
### 阻塞原语
![[Pasted image 20240422104427.png]]
1. 找到 PCB 
2. 保护进程运行现场
3. PCB 插入等待队列
### 唤醒原语
1. 找到 PCB 
2. 从等待队列移除并设置进程为就绪态
3. 将 PCB 插入就绪队列
唤醒原语和阻塞原语成对出现
### 切换原语
![[Pasted image 20240422104527.png]]
1. 运行环境信息存入 PCB 
2. PCB 移入响应队列
3. 选择新进程并更新 PCB 
4. 根据 PCB 恢复新进程所需的运行环境
# 进程间通信
1. 进程间通信 (Inter-Process Communication, IPC) 是指两个进程之间产生数据交互，进程通信的实现需要操作系统的支持
2. 各进程拥有的内存地址空间相互独立
## 共享存储
1. 进程可以申请一片共享存储区
2. 共享存储区可以被多个进程使用
``` c
int shm_open();
void* mmap();
```
3. 使用共享存储区通信时需要保证互斥访问，可以使用操作系统内核提供的同步互斥工具
### 基于存储区
1. 共享存储区数据的形式、存放位置都由通信进程控制，速度快，属于高级通信方式
### 基于数据结构
1. 共享区域用数据结构的限制，可以理解为特殊的全局变量，共享方式速度慢，属于低级通信方式
## 消息传递
1. 进程间的数据交换以格式化的消息 (Message) 为单位。进程通过操作系统提供的"发送消息 / 接收消息"两个原语进行数据交换
### 直接通信方式
![[Pasted image 20240422111623.png]]
1. 发送进程需要指明接收进程的 ID
### 间接通信方式
1. 通过信箱间接发送消息
2. 进程 P 通过 OS 申请邮箱
3. 在自己的地址空间内完善消息体的信息
4. 进程 P 通过发送原语指明发送的信箱
## 管道通信
1. 写进程想管道一边写入数据，读进程从管道另一边取走数据，数据的流动是单向的
2. 管道是一个特殊的共享文件，实际上实在内存中开辟一个固定的内存缓冲区，和共享存储的区别是读取数据的顺序有限制，可以把管道的内存缓冲区理解为循环队列
3. 管道只能支持半双工通信，某一时间段内只能实现单向的传输，两个方向的数据传输不能同时进行
4. 各进程要互斥地访问管道 (操作系统实现)
5. 管道写满时，写进程需要被阻塞，管道读空时，读进程将阻塞
6. 多个读进程读一个管道时，会发生错乱，有两种解决方案
	1. 一个管道允许的多个写进程，一个读进程
	2. 一个管道允许多个写进程，多个读进程，操作系统会让各个读进程轮流从管道中读数据 (Linux)
# 线程的概念与特点
![[Pasted image 20240422123513.png]]
1. 有的进程可能需要同时做很多事，传统的进程只能串行执行一系列程序，所以引入线程来增加并发度
2. 引入线程后，线程成为程序执行流的最小单位
3. 线程时一个基本的 CPU 执行单元，也是程序执行流的最小单位
4. 引入线程后进程作为除 CPU 之外系统资源的分配单元
![[Pasted image 20240422123552.png]]
# 线程的实现方式
## 用户级线程 (User-Level Thread, ULT)
1. 早期的操作系统线程是由线程库实现的
2. 操作系统层面只能看到一个进程，而程序员通过线程库实现了逻辑上的线程
3. 只有用户才能感知到用户级线程的存在
### 优缺点
1. 优点：切换在用户空间即可完成，不需要变态，线程管理的系统开销小，效率高
2. 缺点：只要其中一个线程被阻塞，则整个进程都会被阻塞，多个线程不可在多处理机上并行运行
## 内核级线程 (Kernel-Level Thread, KLT)
1. 操作系统为每个内核级线程建立相应的线程控制块 (Thread Control Block, TCB)
2. 操作系统只看得见内核级线程，只有内核级线程是处理机分配的单位
### 优缺点
1. 优点：一个线程被阻塞其他线程仍能执行，并发能力强，多线程可在多核处理机上并行执行
2. 缺点：一个用户进程会占用多个内核级线程，线程切换优操作系统内核完成，需要切换到核心态，开销大
## 多线程模型
### 一对一模型
### 多对一模型
### 多对多模型
![[Pasted image 20240422125608.png]]
1. N 用户级线程映射到 m 个内核级线程 (n >= m)，每个用户线程对应 m 个内核级线程
2. 用户级线程是代码逻辑的载体，内核级线程是运行机会的载体
# 线程的状态与转换
![[Pasted image 20240422125847.png]]
1. 线程的状态与转换与进程相类似
![[Pasted image 20240422125958.png]]