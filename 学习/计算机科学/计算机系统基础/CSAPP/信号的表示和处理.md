# 信息存储
- 字节 (byte)：大多数计算机最小的可寻址的内存单位
- 虚拟内存 (virtual memory)：机器级程序将内存视为一个非常大的字节数组
- 地址 (address)：表示内存的每个字节的唯一数字
- 虚拟地址空间 (virtual address space)：所有可能地址的集合
## 字数据大小
- 字长 (word size)：用于指明指针数据的标称大小，字长为 $w$ 位的机器虚拟地址的范围为 $0\sim(2^w-1)$
- 指针使用程序的全字长
## 寻址和字节顺序
- 小端法 (little endian)：最低有效字节在最低位
- 大端法 (big endian)：最高有效字节在最低位
- 书写字节序列的自然方式是最低位字节在左边，最高位字节在右边
- 当编写规避正常类型系统的程序时，字节顺序变得重要
- 文本数据比二进制数据具有更强的平台独立性
# 整数表示
- 补码 (two's-complement)：将字的最高有效位解释为负权 (negetive weight)
	- 非负数用 $2^w-x$ 计算 $-x$ 的 $w$ 位表示 
$$
B2T_w(\vec{x})\dot{=}-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i
$$
- 反码 (ones' complement)：最高有效位的权是 $-(2^{w-1}-1)$
$$
B2O_w(\vec{x})\dot{=}-x_{w-1}(2^{w-1}-1)+\sum\limits_{i=0}^{w-2}x_i2^i
$$
- 原码 (Sign-Magnitude)：最高有效位是符号位
$$
B2S_w(\vec{x})\dot{=}(-1)^{x_{w-1}}\cdot(\sum\limits_{i=0}^{w-2}x_i2^i)
$$
## 有符号数和无符号数之间的转换

```c
short int v = -12345
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", u, uv);
```
- 处理相同字长的有符号数和无符号数之间的转换的一般规则是：数值可能会改变，但是位模式不变
- 补码转换为无符号数
$$
T2U_w(x)=\begin{cases}x+2^w,&x<0\\x&x\geqslant0\end{cases}
$$
- 无符号数转换为补码
$$
U2T_w(x)=\begin{cases}u,&u\leqslant Tmax_w\\u-2^w&u>Tmax_w\end{cases}
$$
