# 信息存储
- 字节 (byte)：大多数计算机最小的可寻址的内存单位
- 虚拟内存 (virtual memory)：机器级程序将内存视为一个非常大的字节数组
- 地址 (address)：表示内存的每个字节的唯一数字
- 虚拟地址空间 (virtual address space)：所有可能地址的集合
## 字数据大小
- 字长 (word size)：用于指明指针数据的标称大小，字长为 $w$ 位的机器虚拟地址的范围为 $0\sim(2^w-1)$
- 指针使用程序的全字长
## 寻址和字节顺序
- 小端法 (little endian)：最低有效字节在最低位
- 大端法 (big endian)：最高有效字节在最低位
- 书写字节序列的自然方式是最低位字节在左边，最高位字节在右边
- 当编写规避正常类型系统的程序时，字节顺序变得重要
- 文本数据比二进制数据具有更强的平台独立性
# 整数表示
- 补码 (two's-complement)：将字的最高有效位解释为负权 (negetive weight)
	- 非负数用 $2^w-x$ 计算 $-x$ 的 $w$ 位表示 
$$
B2T_w(\vec{x})\dot{=}-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i
$$
- 反码 (ones' complement)：最高有效位的权是 $-(2^{w-1}-1)$
$$
B2O_w(\vec{x})\dot{=}-x_{w-1}(2^{w-1}-1)+\sum\limits_{i=0}^{w-2}x_i2^i
$$
- 原码 (Sign-Magnitude)：最高有效位是符号位
$$
B2S_w(\vec{x})\dot{=}(-1)^{x_{w-1}}\cdot(\sum\limits_{i=0}^{w-2}x_i2^i)
$$
## 有符号数和无符号数之间的转换

```c
short int v = -12345
unsigned short uv = (unsigned short) v;
printf("v = %d, uv = %u\n", u, uv);
```
- 处理相同字长的有符号数和无符号数之间的转换的一般规则是：数值可能会改变，但是位模式不变
- 补码转换为无符号数
$$
T2U_w(x)=\begin{cases}x+2^w,&x<0\\x&x\geqslant0\end{cases}
$$
- 无符号数转换为补码
$$
U2T_w(x)=\begin{cases}u,&u\leqslant Tmax_w\\u-2^w&u>Tmax_w\end{cases}
$$
 - 转换可以显示表示也可以隐式表示 (当一种类型的表达式被复制给另一种类型的变量时)
 - printf 可以用%u 来输出类型为 int 的数值，也可以用%d 输出类型为 unsigned 的数值
 - 当执行一个运算时如果一个运算数有符号另一个无符号，C 语言隐式将有符号强制转换为无符号数，并假设两者都是非负的
## 扩展数字的位表示
 - 无符号数扩展开头补 0，有符号数扩展开符号扩展一位
 - 当把 short 转换成 unsigned 时先改变大小，再完成有符号到无符号的转换
## 整数运算
