# 第二章
## 2.5
A.小端法：21 大端法：87
B.小端法：21 43 大端法：87 65
C.小端法：21 43 65 大端法：87 65 43
## 2.6
A. 0011 0101 1001 0001 0100 0001
0100 1010 0101 0110 0100 0101 0000 0100
B. 
C.
## 2.7
61 62 63 64 65 66 00
## 2.8
10010110
10101010
01000001
01111101
00111100
## 2.9
A.
黑色-白色
蓝色-黄色
绿色-红紫色
蓝绿色-红色
B.
蓝绿色
绿色
蓝色
## 2.10
a a^b
b a^b
b a
## 2.11
A.k+1
B.因为第一步异或就把指针指向的值设为 0 了
C.first <= last 改为 first < last
## 2.13
```c
int bis(int x, int m) {
	return x|m;
}

int bic(int x, int m) {
	return x&(~m);
}

int bool_or(int x, int y) {
	int result = bis(x, y);
	return result;
}

int bool_xor(int x, int y) {
	int result = 
	return result;
}
```
## 2.14
| 表达式   | 值   |
| -------- | ---- |
| x&y      | 0x20 |
| x&&y     | 0x01 |
| x \| y   | 0x7F |
| x\|\|y   | 0x01 |
| ~x\|~y   | 0xDF |
| !x\|\|!y | 0x00 |
| x&!y     |0x46|
|x&&~y|0x01|
## 2.15
```c
int equal(int x, int y) {
	int result = !(x ^ y)
	return result;  
}
```

## 2.16
| x十六进制    | x二进制   | x<<3二进制   | 十六进制   | x>>2(逻辑的)二进制   | 十六进制   | x>>2(算数的)二进制   | 十六进制   |
| ---- | --- | --- | --- | --- | --- | --- | --- |
| 0xC3 | 11000011    | 00011000    | 0x18    | 00110000    | 0x30    | 11110000    | 0xF0    |
| 0x75 | 01110101    | 10101000    | 0xA8    | 00011101    | 0x1D    | 00011101    | 0x1D    |
| 0x87     |10000111     | 00111000    | 0x38    | 00001110    | 0x0E    | 11111110    | 0xFE    |
| 0x66     | 01100110    | 00110000    | 0x30    | 00001100    | 0x0C    |00001100     | 0x0C    |
## 2.17
| 十六进制 | 二进制 | $B2U_4(\vec{x})$     | $B2T_4(\vec{x})$      |
| -------- | ------ | -------------------- | --------------------- |
| 0x0      | [0000] | 0                    | 0                     |
| 0x5      | [0101] | $2^2+2^0=5$          | $2^2+2^0=5$           |
| 0x8      | [1000] | $2^3=8$              | $-2^3=-8$             |
| 0xD      | [1101] | $2^3+2^2+2^0=13$     | $-2^3+2^2+2^0=-3$     |
| 0xF      | [1111] | $2^3+2^2+2^1+2^0=15$ | $-2^3+2^2+2^1+2^0=-1$ |
## 2.18
## 2.19
| x   | $T2U_4(x)$ |
| --- | ---------- |
| -8  | 8          |
| -3  | 13         |
| -2  | 14         |
| -1  | 15         |
| 0   | 0          |
| 5    | 5           |
## 2.20
易得
## 2.21
| 类型   | 求值 |
| ------ | ---- |
| 无符号 | 1*   |
| 有符号 | 1    |
| 无符号 | 0*   |
| 有符号 | 1    |
| 无符号 | 0*   |
## 2.22
A. $-2^3+2^1+2^0=-5$
B. $-2^4+2^3+2^1+2^0=-5$
C. $-2^5+2^4+2^3+2^1+2^0=-5$
## 2.23
| fun1(w)    | fun2(w)    |
| ---------- | ---------- |
| 0x00000076 | 0xffffff76 |
| 0x00000021 | 0xffffff21 |
| 0x000000C9 | 0xffffffC9 |
| 0x00000087 | 0xffffff87 |
B. fun1取 unsigned 的最小字节并转换为 int
fun2 将最大的 3 字节全部填充为 1
## 2.24
| 无符号截断值 | 补码截断值 |
| ------------ | ---------- |
| 0            | 0          |
| 2            | 2          |
| 1            | 1          |
| 3            | 3          |
| 7            | -1         | 
## 2.25
因为 unsigned 的每一位都是 0 了此时进行减法运算是未定义的
修改：如果要令函数的参数仍为 unsigned 而不出错就需要对 length 进行类型转换，但当 unsigned 过大时转换为 int 会出现溢出的问题一种解决方案是规定 length 的输入大小，令其小于 INT_MAX 并强制类型转换为 int 或者使用位更多的有符号数来作为遍历的计数器
## 2.26
A.
B.
C. 
